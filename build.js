System.registerDynamic("npm:react-redux@4.0.6/lib/components/Provider", ["npm:react@0.14.6", "npm:react-redux@4.0.6/lib/utils/storeShape"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  var _require = $__require('npm:react@0.14.6');
  var Component = _require.Component;
  var PropTypes = _require.PropTypes;
  var Children = _require.Children;
  var storeShape = $__require('npm:react-redux@4.0.6/lib/utils/storeShape');
  var didWarnAboutReceivingStore = false;
  function warnAboutReceivingStore() {
    if (didWarnAboutReceivingStore) {
      return;
    }
    didWarnAboutReceivingStore = true;
    console.error('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/rackt/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
  }
  var Provider = (function(_Component) {
    _inherits(Provider, _Component);
    Provider.prototype.getChildContext = function getChildContext() {
      return {store: this.store};
    };
    function Provider(props, context) {
      _classCallCheck(this, Provider);
      var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));
      _this.store = props.store;
      return _this;
    }
    Provider.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var store = this.store;
      var nextStore = nextProps.store;
      if (store !== nextStore) {
        warnAboutReceivingStore();
      }
    };
    Provider.prototype.render = function render() {
      var children = this.props.children;
      return Children.only(children);
    };
    return Provider;
  })(Component);
  Provider.propTypes = {
    store: storeShape.isRequired,
    children: PropTypes.element.isRequired
  };
  Provider.childContextTypes = {store: storeShape.isRequired};
  module.exports = Provider;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react-redux@4.0.6/lib/utils/storeShape", ["npm:react@0.14.6"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _require = $__require('npm:react@0.14.6');
  var PropTypes = _require.PropTypes;
  var storeShape = PropTypes.shape({
    subscribe: PropTypes.func.isRequired,
    dispatch: PropTypes.func.isRequired,
    getState: PropTypes.func.isRequired
  });
  module.exports = storeShape;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react-redux@4.0.6/lib/utils/shallowEqual", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function shallowEqual(objA, objB) {
    if (objA === objB) {
      return true;
    }
    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) {
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty;
    for (var i = 0; i < keysA.length; i++) {
      if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
        return false;
      }
    }
    return true;
  }
  module.exports = shallowEqual;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react-redux@4.0.6/lib/utils/isPlainObject", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function _typeof(obj) {
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
  }
  var fnToString = function fnToString(fn) {
    return Function.prototype.toString.call(fn);
  };
  function isPlainObject(obj) {
    if (!obj || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {
      return false;
    }
    var proto = typeof obj.constructor === 'function' ? Object.getPrototypeOf(obj) : Object.prototype;
    if (proto === null) {
      return true;
    }
    var constructor = proto.constructor;
    return typeof constructor === 'function' && constructor instanceof constructor && fnToString(constructor) === fnToString(Object);
  }
  module.exports = isPlainObject;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react-redux@4.0.6/lib/utils/wrapActionCreators", ["npm:redux@3.0.5"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _redux = $__require('npm:redux@3.0.5');
  function wrapActionCreators(actionCreators) {
    return function(dispatch) {
      return (0, _redux.bindActionCreators)(actionCreators, dispatch);
    };
  }
  module.exports = wrapActionCreators;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:hoist-non-react-statics@1.0.3/index", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    mixins: true,
    propTypes: true,
    type: true
  };
  var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    arguments: true,
    arity: true
  };
  module.exports = function hoistNonReactStatics(targetComponent, sourceComponent) {
    var keys = Object.getOwnPropertyNames(sourceComponent);
    for (var i = 0; i < keys.length; ++i) {
      if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]]) {
        targetComponent[keys[i]] = sourceComponent[keys[i]];
      }
    }
    return targetComponent;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:hoist-non-react-statics@1.0.3", ["npm:hoist-non-react-statics@1.0.3/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:hoist-non-react-statics@1.0.3/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:invariant@2.2.0/browser", ["github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = function(condition, format, a, b, c, d, e, f) {
      if (process.env.NODE_ENV !== 'production') {
        if (format === undefined) {
          throw new Error('invariant requires an error message argument');
        }
      }
      if (!condition) {
        var error;
        if (format === undefined) {
          error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(format.replace(/%s/g, function() {
            return args[argIndex++];
          }));
          error.name = 'Invariant Violation';
        }
        error.framesToPop = 1;
        throw error;
      }
    };
    module.exports = invariant;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:invariant@2.2.0", ["npm:invariant@2.2.0/browser"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:invariant@2.2.0/browser');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react-redux@4.0.6/lib/components/connect", ["npm:react@0.14.6", "npm:react-redux@4.0.6/lib/utils/storeShape", "npm:react-redux@4.0.6/lib/utils/shallowEqual", "npm:react-redux@4.0.6/lib/utils/isPlainObject", "npm:react-redux@4.0.6/lib/utils/wrapActionCreators", "npm:hoist-non-react-statics@1.0.3", "npm:invariant@2.2.0", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }});
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var _require = $__require('npm:react@0.14.6');
    var Component = _require.Component;
    var createElement = _require.createElement;
    var storeShape = $__require('npm:react-redux@4.0.6/lib/utils/storeShape');
    var shallowEqual = $__require('npm:react-redux@4.0.6/lib/utils/shallowEqual');
    var isPlainObject = $__require('npm:react-redux@4.0.6/lib/utils/isPlainObject');
    var wrapActionCreators = $__require('npm:react-redux@4.0.6/lib/utils/wrapActionCreators');
    var hoistStatics = $__require('npm:hoist-non-react-statics@1.0.3');
    var invariant = $__require('npm:invariant@2.2.0');
    var defaultMapStateToProps = function defaultMapStateToProps(state) {
      return {};
    };
    var defaultMapDispatchToProps = function defaultMapDispatchToProps(dispatch) {
      return {dispatch: dispatch};
    };
    var defaultMergeProps = function defaultMergeProps(stateProps, dispatchProps, parentProps) {
      return _extends({}, parentProps, stateProps, dispatchProps);
    };
    function getDisplayName(WrappedComponent) {
      return WrappedComponent.displayName || WrappedComponent.name || 'Component';
    }
    var nextVersion = 0;
    function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
      var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
      var shouldSubscribe = Boolean(mapStateToProps);
      var finalMapStateToProps = mapStateToProps || defaultMapStateToProps;
      var finalMapDispatchToProps = isPlainObject(mapDispatchToProps) ? wrapActionCreators(mapDispatchToProps) : mapDispatchToProps || defaultMapDispatchToProps;
      var finalMergeProps = mergeProps || defaultMergeProps;
      var doStatePropsDependOnOwnProps = finalMapStateToProps.length !== 1;
      var doDispatchPropsDependOnOwnProps = finalMapDispatchToProps.length !== 1;
      var _options$pure = options.pure;
      var pure = _options$pure === undefined ? true : _options$pure;
      var _options$withRef = options.withRef;
      var withRef = _options$withRef === undefined ? false : _options$withRef;
      var version = nextVersion++;
      function computeStateProps(store, props) {
        var state = store.getState();
        var stateProps = doStatePropsDependOnOwnProps ? finalMapStateToProps(state, props) : finalMapStateToProps(state);
        invariant(isPlainObject(stateProps), '`mapStateToProps` must return an object. Instead received %s.', stateProps);
        return stateProps;
      }
      function computeDispatchProps(store, props) {
        var dispatch = store.dispatch;
        var dispatchProps = doDispatchPropsDependOnOwnProps ? finalMapDispatchToProps(dispatch, props) : finalMapDispatchToProps(dispatch);
        invariant(isPlainObject(dispatchProps), '`mapDispatchToProps` must return an object. Instead received %s.', dispatchProps);
        return dispatchProps;
      }
      function computeMergedProps(stateProps, dispatchProps, parentProps) {
        var mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps);
        invariant(isPlainObject(mergedProps), '`mergeProps` must return an object. Instead received %s.', mergedProps);
        return mergedProps;
      }
      return function wrapWithConnect(WrappedComponent) {
        var Connect = (function(_Component) {
          _inherits(Connect, _Component);
          Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
            return !pure || this.haveOwnPropsChanged || this.hasStoreStateChanged;
          };
          function Connect(props, context) {
            _classCallCheck(this, Connect);
            var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));
            _this.version = version;
            _this.store = props.store || context.store;
            invariant(_this.store, 'Could not find "store" in either the context or ' + ('props of "' + _this.constructor.displayName + '". ') + 'Either wrap the root component in a <Provider>, ' + ('or explicitly pass "store" as a prop to "' + _this.constructor.displayName + '".'));
            var storeState = _this.store.getState();
            _this.state = {storeState: storeState};
            _this.clearCache();
            return _this;
          }
          Connect.prototype.updateStatePropsIfNeeded = function updateStatePropsIfNeeded() {
            var nextStateProps = computeStateProps(this.store, this.props);
            if (this.stateProps && shallowEqual(nextStateProps, this.stateProps)) {
              return false;
            }
            this.stateProps = nextStateProps;
            return true;
          };
          Connect.prototype.updateDispatchPropsIfNeeded = function updateDispatchPropsIfNeeded() {
            var nextDispatchProps = computeDispatchProps(this.store, this.props);
            if (this.dispatchProps && shallowEqual(nextDispatchProps, this.dispatchProps)) {
              return false;
            }
            this.dispatchProps = nextDispatchProps;
            return true;
          };
          Connect.prototype.updateMergedProps = function updateMergedProps() {
            this.mergedProps = computeMergedProps(this.stateProps, this.dispatchProps, this.props);
          };
          Connect.prototype.isSubscribed = function isSubscribed() {
            return typeof this.unsubscribe === 'function';
          };
          Connect.prototype.trySubscribe = function trySubscribe() {
            if (shouldSubscribe && !this.unsubscribe) {
              this.unsubscribe = this.store.subscribe(this.handleChange.bind(this));
              this.handleChange();
            }
          };
          Connect.prototype.tryUnsubscribe = function tryUnsubscribe() {
            if (this.unsubscribe) {
              this.unsubscribe();
              this.unsubscribe = null;
            }
          };
          Connect.prototype.componentDidMount = function componentDidMount() {
            this.trySubscribe();
          };
          Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
            if (!pure || !shallowEqual(nextProps, this.props)) {
              this.haveOwnPropsChanged = true;
            }
          };
          Connect.prototype.componentWillUnmount = function componentWillUnmount() {
            this.tryUnsubscribe();
            this.clearCache();
          };
          Connect.prototype.clearCache = function clearCache() {
            this.dispatchProps = null;
            this.stateProps = null;
            this.mergedProps = null;
            this.haveOwnPropsChanged = true;
            this.hasStoreStateChanged = true;
            this.renderedElement = null;
          };
          Connect.prototype.handleChange = function handleChange() {
            if (!this.unsubscribe) {
              return;
            }
            var prevStoreState = this.state.storeState;
            var storeState = this.store.getState();
            if (!pure || prevStoreState !== storeState) {
              this.hasStoreStateChanged = true;
              this.setState({storeState: storeState});
            }
          };
          Connect.prototype.getWrappedInstance = function getWrappedInstance() {
            invariant(withRef, 'To access the wrapped instance, you need to specify ' + '{ withRef: true } as the fourth argument of the connect() call.');
            return this.refs.wrappedInstance;
          };
          Connect.prototype.render = function render() {
            var haveOwnPropsChanged = this.haveOwnPropsChanged;
            var hasStoreStateChanged = this.hasStoreStateChanged;
            var renderedElement = this.renderedElement;
            this.haveOwnPropsChanged = false;
            this.hasStoreStateChanged = false;
            var shouldUpdateStateProps = true;
            var shouldUpdateDispatchProps = true;
            if (pure && renderedElement) {
              shouldUpdateStateProps = hasStoreStateChanged || haveOwnPropsChanged && doStatePropsDependOnOwnProps;
              shouldUpdateDispatchProps = haveOwnPropsChanged && doDispatchPropsDependOnOwnProps;
            }
            var haveStatePropsChanged = false;
            var haveDispatchPropsChanged = false;
            if (shouldUpdateStateProps) {
              haveStatePropsChanged = this.updateStatePropsIfNeeded();
            }
            if (shouldUpdateDispatchProps) {
              haveDispatchPropsChanged = this.updateDispatchPropsIfNeeded();
            }
            var haveMergedPropsChanged = true;
            if (haveStatePropsChanged || haveDispatchPropsChanged || haveOwnPropsChanged) {
              this.updateMergedProps();
            } else {
              haveMergedPropsChanged = false;
            }
            if (!haveMergedPropsChanged && renderedElement) {
              return renderedElement;
            }
            if (withRef) {
              this.renderedElement = createElement(WrappedComponent, _extends({}, this.mergedProps, {ref: 'wrappedInstance'}));
            } else {
              this.renderedElement = createElement(WrappedComponent, this.mergedProps);
            }
            return this.renderedElement;
          };
          return Connect;
        })(Component);
        Connect.displayName = 'Connect(' + getDisplayName(WrappedComponent) + ')';
        Connect.WrappedComponent = WrappedComponent;
        Connect.contextTypes = {store: storeShape};
        Connect.propTypes = {store: storeShape};
        if (process.env.NODE_ENV !== 'production') {
          Connect.prototype.componentWillUpdate = function componentWillUpdate() {
            if (this.version === version) {
              return;
            }
            this.version = version;
            this.trySubscribe();
            this.clearCache();
          };
        }
        return hoistStatics(Connect, WrappedComponent);
      };
    }
    module.exports = connect;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react-redux@4.0.6/lib/index", ["npm:react-redux@4.0.6/lib/components/Provider", "npm:react-redux@4.0.6/lib/components/connect"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Provider = $__require('npm:react-redux@4.0.6/lib/components/Provider');
  var connect = $__require('npm:react-redux@4.0.6/lib/components/connect');
  module.exports = {
    Provider: Provider,
    connect: connect
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react-redux@4.0.6", ["npm:react-redux@4.0.6/lib/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:react-redux@4.0.6/lib/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactServerBatchingStrategy", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ReactServerBatchingStrategy = {
    isBatchingUpdates: false,
    batchedUpdates: function(callback) {}
  };
  module.exports = ReactServerBatchingStrategy;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactServerRenderingTransaction", ["npm:react@0.14.6/lib/PooledClass", "npm:react@0.14.6/lib/CallbackQueue", "npm:react@0.14.6/lib/Transaction", "npm:react@0.14.6/lib/Object.assign", "npm:fbjs@0.6.1/lib/emptyFunction"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var PooledClass = $__require('npm:react@0.14.6/lib/PooledClass');
  var CallbackQueue = $__require('npm:react@0.14.6/lib/CallbackQueue');
  var Transaction = $__require('npm:react@0.14.6/lib/Transaction');
  var assign = $__require('npm:react@0.14.6/lib/Object.assign');
  var emptyFunction = $__require('npm:fbjs@0.6.1/lib/emptyFunction');
  var ON_DOM_READY_QUEUEING = {
    initialize: function() {
      this.reactMountReady.reset();
    },
    close: emptyFunction
  };
  var TRANSACTION_WRAPPERS = [ON_DOM_READY_QUEUEING];
  function ReactServerRenderingTransaction(renderToStaticMarkup) {
    this.reinitializeTransaction();
    this.renderToStaticMarkup = renderToStaticMarkup;
    this.reactMountReady = CallbackQueue.getPooled(null);
    this.useCreateElement = false;
  }
  var Mixin = {
    getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    },
    getReactMountReady: function() {
      return this.reactMountReady;
    },
    destructor: function() {
      CallbackQueue.release(this.reactMountReady);
      this.reactMountReady = null;
    }
  };
  assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
  PooledClass.addPoolingTo(ReactServerRenderingTransaction);
  module.exports = ReactServerRenderingTransaction;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactServerRendering", ["npm:react@0.14.6/lib/ReactDefaultBatchingStrategy", "npm:react@0.14.6/lib/ReactElement", "npm:react@0.14.6/lib/ReactInstanceHandles", "npm:react@0.14.6/lib/ReactMarkupChecksum", "npm:react@0.14.6/lib/ReactServerBatchingStrategy", "npm:react@0.14.6/lib/ReactServerRenderingTransaction", "npm:react@0.14.6/lib/ReactUpdates", "npm:fbjs@0.6.1/lib/emptyObject", "npm:react@0.14.6/lib/instantiateReactComponent", "npm:fbjs@0.6.1/lib/invariant", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactDefaultBatchingStrategy = $__require('npm:react@0.14.6/lib/ReactDefaultBatchingStrategy');
    var ReactElement = $__require('npm:react@0.14.6/lib/ReactElement');
    var ReactInstanceHandles = $__require('npm:react@0.14.6/lib/ReactInstanceHandles');
    var ReactMarkupChecksum = $__require('npm:react@0.14.6/lib/ReactMarkupChecksum');
    var ReactServerBatchingStrategy = $__require('npm:react@0.14.6/lib/ReactServerBatchingStrategy');
    var ReactServerRenderingTransaction = $__require('npm:react@0.14.6/lib/ReactServerRenderingTransaction');
    var ReactUpdates = $__require('npm:react@0.14.6/lib/ReactUpdates');
    var emptyObject = $__require('npm:fbjs@0.6.1/lib/emptyObject');
    var instantiateReactComponent = $__require('npm:react@0.14.6/lib/instantiateReactComponent');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    function renderToString(element) {
      !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToString(): You must pass a valid ReactElement.') : invariant(false) : undefined;
      var transaction;
      try {
        ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);
        var id = ReactInstanceHandles.createReactRootID();
        transaction = ReactServerRenderingTransaction.getPooled(false);
        return transaction.perform(function() {
          var componentInstance = instantiateReactComponent(element, null);
          var markup = componentInstance.mountComponent(id, transaction, emptyObject);
          return ReactMarkupChecksum.addChecksumToMarkup(markup);
        }, null);
      } finally {
        ReactServerRenderingTransaction.release(transaction);
        ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
      }
    }
    function renderToStaticMarkup(element) {
      !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(false) : undefined;
      var transaction;
      try {
        ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);
        var id = ReactInstanceHandles.createReactRootID();
        transaction = ReactServerRenderingTransaction.getPooled(true);
        return transaction.perform(function() {
          var componentInstance = instantiateReactComponent(element, null);
          return componentInstance.mountComponent(id, transaction, emptyObject);
        }, null);
      } finally {
        ReactServerRenderingTransaction.release(transaction);
        ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
      }
    }
    module.exports = {
      renderToString: renderToString,
      renderToStaticMarkup: renderToStaticMarkup
    };
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactDOMServer", ["npm:react@0.14.6/lib/ReactDefaultInjection", "npm:react@0.14.6/lib/ReactServerRendering", "npm:react@0.14.6/lib/ReactVersion"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ReactDefaultInjection = $__require('npm:react@0.14.6/lib/ReactDefaultInjection');
  var ReactServerRendering = $__require('npm:react@0.14.6/lib/ReactServerRendering');
  var ReactVersion = $__require('npm:react@0.14.6/lib/ReactVersion');
  ReactDefaultInjection.inject();
  var ReactDOMServer = {
    renderToString: ReactServerRendering.renderToString,
    renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
    version: ReactVersion
  };
  module.exports = ReactDOMServer;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/mapObject", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function mapObject(object, callback, context) {
    if (!object) {
      return null;
    }
    var result = {};
    for (var name in object) {
      if (hasOwnProperty.call(object, name)) {
        result[name] = callback.call(context, object[name], name, object);
      }
    }
    return result;
  }
  module.exports = mapObject;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactDOMFactories", ["npm:react@0.14.6/lib/ReactElement", "npm:react@0.14.6/lib/ReactElementValidator", "npm:fbjs@0.6.1/lib/mapObject", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactElement = $__require('npm:react@0.14.6/lib/ReactElement');
    var ReactElementValidator = $__require('npm:react@0.14.6/lib/ReactElementValidator');
    var mapObject = $__require('npm:fbjs@0.6.1/lib/mapObject');
    function createDOMFactory(tag) {
      if (process.env.NODE_ENV !== 'production') {
        return ReactElementValidator.createFactory(tag);
      }
      return ReactElement.createFactory(tag);
    }
    var ReactDOMFactories = mapObject({
      a: 'a',
      abbr: 'abbr',
      address: 'address',
      area: 'area',
      article: 'article',
      aside: 'aside',
      audio: 'audio',
      b: 'b',
      base: 'base',
      bdi: 'bdi',
      bdo: 'bdo',
      big: 'big',
      blockquote: 'blockquote',
      body: 'body',
      br: 'br',
      button: 'button',
      canvas: 'canvas',
      caption: 'caption',
      cite: 'cite',
      code: 'code',
      col: 'col',
      colgroup: 'colgroup',
      data: 'data',
      datalist: 'datalist',
      dd: 'dd',
      del: 'del',
      details: 'details',
      dfn: 'dfn',
      dialog: 'dialog',
      div: 'div',
      dl: 'dl',
      dt: 'dt',
      em: 'em',
      embed: 'embed',
      fieldset: 'fieldset',
      figcaption: 'figcaption',
      figure: 'figure',
      footer: 'footer',
      form: 'form',
      h1: 'h1',
      h2: 'h2',
      h3: 'h3',
      h4: 'h4',
      h5: 'h5',
      h6: 'h6',
      head: 'head',
      header: 'header',
      hgroup: 'hgroup',
      hr: 'hr',
      html: 'html',
      i: 'i',
      iframe: 'iframe',
      img: 'img',
      input: 'input',
      ins: 'ins',
      kbd: 'kbd',
      keygen: 'keygen',
      label: 'label',
      legend: 'legend',
      li: 'li',
      link: 'link',
      main: 'main',
      map: 'map',
      mark: 'mark',
      menu: 'menu',
      menuitem: 'menuitem',
      meta: 'meta',
      meter: 'meter',
      nav: 'nav',
      noscript: 'noscript',
      object: 'object',
      ol: 'ol',
      optgroup: 'optgroup',
      option: 'option',
      output: 'output',
      p: 'p',
      param: 'param',
      picture: 'picture',
      pre: 'pre',
      progress: 'progress',
      q: 'q',
      rp: 'rp',
      rt: 'rt',
      ruby: 'ruby',
      s: 's',
      samp: 'samp',
      script: 'script',
      section: 'section',
      select: 'select',
      small: 'small',
      source: 'source',
      span: 'span',
      strong: 'strong',
      style: 'style',
      sub: 'sub',
      summary: 'summary',
      sup: 'sup',
      table: 'table',
      tbody: 'tbody',
      td: 'td',
      textarea: 'textarea',
      tfoot: 'tfoot',
      th: 'th',
      thead: 'thead',
      time: 'time',
      title: 'title',
      tr: 'tr',
      track: 'track',
      u: 'u',
      ul: 'ul',
      'var': 'var',
      video: 'video',
      wbr: 'wbr',
      circle: 'circle',
      clipPath: 'clipPath',
      defs: 'defs',
      ellipse: 'ellipse',
      g: 'g',
      image: 'image',
      line: 'line',
      linearGradient: 'linearGradient',
      mask: 'mask',
      path: 'path',
      pattern: 'pattern',
      polygon: 'polygon',
      polyline: 'polyline',
      radialGradient: 'radialGradient',
      rect: 'rect',
      stop: 'stop',
      svg: 'svg',
      text: 'text',
      tspan: 'tspan'
    }, createDOMFactory);
    module.exports = ReactDOMFactories;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactElementValidator", ["npm:react@0.14.6/lib/ReactElement", "npm:react@0.14.6/lib/ReactPropTypeLocations", "npm:react@0.14.6/lib/ReactPropTypeLocationNames", "npm:react@0.14.6/lib/ReactCurrentOwner", "npm:react@0.14.6/lib/canDefineProperty", "npm:react@0.14.6/lib/getIteratorFn", "npm:fbjs@0.6.1/lib/invariant", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactElement = $__require('npm:react@0.14.6/lib/ReactElement');
    var ReactPropTypeLocations = $__require('npm:react@0.14.6/lib/ReactPropTypeLocations');
    var ReactPropTypeLocationNames = $__require('npm:react@0.14.6/lib/ReactPropTypeLocationNames');
    var ReactCurrentOwner = $__require('npm:react@0.14.6/lib/ReactCurrentOwner');
    var canDefineProperty = $__require('npm:react@0.14.6/lib/canDefineProperty');
    var getIteratorFn = $__require('npm:react@0.14.6/lib/getIteratorFn');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    function getDeclarationErrorAddendum() {
      if (ReactCurrentOwner.current) {
        var name = ReactCurrentOwner.current.getName();
        if (name) {
          return ' Check the render method of `' + name + '`.';
        }
      }
      return '';
    }
    var ownerHasKeyUseWarning = {};
    var loggedTypeFailures = {};
    function validateExplicitKey(element, parentType) {
      if (!element._store || element._store.validated || element.key != null) {
        return;
      }
      element._store.validated = true;
      var addenda = getAddendaForKeyUse('uniqueKey', element, parentType);
      if (addenda === null) {
        return;
      }
      process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s%s', addenda.parentOrOwner || '', addenda.childOwner || '', addenda.url || '') : undefined;
    }
    function getAddendaForKeyUse(messageType, element, parentType) {
      var addendum = getDeclarationErrorAddendum();
      if (!addendum) {
        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
        if (parentName) {
          addendum = ' Check the top-level render call using <' + parentName + '>.';
        }
      }
      var memoizer = ownerHasKeyUseWarning[messageType] || (ownerHasKeyUseWarning[messageType] = {});
      if (memoizer[addendum]) {
        return null;
      }
      memoizer[addendum] = true;
      var addenda = {
        parentOrOwner: addendum,
        url: ' See https://fb.me/react-warning-keys for more information.',
        childOwner: null
      };
      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
        addenda.childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
      }
      return addenda;
    }
    function validateChildKeys(node, parentType) {
      if (typeof node !== 'object') {
        return;
      }
      if (Array.isArray(node)) {
        for (var i = 0; i < node.length; i++) {
          var child = node[i];
          if (ReactElement.isValidElement(child)) {
            validateExplicitKey(child, parentType);
          }
        }
      } else if (ReactElement.isValidElement(node)) {
        if (node._store) {
          node._store.validated = true;
        }
      } else if (node) {
        var iteratorFn = getIteratorFn(node);
        if (iteratorFn) {
          if (iteratorFn !== node.entries) {
            var iterator = iteratorFn.call(node);
            var step;
            while (!(step = iterator.next()).done) {
              if (ReactElement.isValidElement(step.value)) {
                validateExplicitKey(step.value, parentType);
              }
            }
          }
        }
      }
    }
    function checkPropTypes(componentName, propTypes, props, location) {
      for (var propName in propTypes) {
        if (propTypes.hasOwnProperty(propName)) {
          var error;
          try {
            !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
            error = propTypes[propName](props, propName, componentName, location);
          } catch (ex) {
            error = ex;
          }
          process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], propName, typeof error) : undefined;
          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            loggedTypeFailures[error.message] = true;
            var addendum = getDeclarationErrorAddendum();
            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed propType: %s%s', error.message, addendum) : undefined;
          }
        }
      }
    }
    function validatePropTypes(element) {
      var componentClass = element.type;
      if (typeof componentClass !== 'function') {
        return;
      }
      var name = componentClass.displayName || componentClass.name;
      if (componentClass.propTypes) {
        checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);
      }
      if (typeof componentClass.getDefaultProps === 'function') {
        process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : undefined;
      }
    }
    var ReactElementValidator = {
      createElement: function(type, props, children) {
        var validType = typeof type === 'string' || typeof type === 'function';
        process.env.NODE_ENV !== 'production' ? warning(validType, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : undefined;
        var element = ReactElement.createElement.apply(this, arguments);
        if (element == null) {
          return element;
        }
        if (validType) {
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], type);
          }
        }
        validatePropTypes(element);
        return element;
      },
      createFactory: function(type) {
        var validatedFactory = ReactElementValidator.createElement.bind(null, type);
        validatedFactory.type = type;
        if (process.env.NODE_ENV !== 'production') {
          if (canDefineProperty) {
            Object.defineProperty(validatedFactory, 'type', {
              enumerable: false,
              get: function() {
                process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : undefined;
                Object.defineProperty(this, 'type', {value: type});
                return type;
              }
            });
          }
        }
        return validatedFactory;
      },
      cloneElement: function(element, props, children) {
        var newElement = ReactElement.cloneElement.apply(this, arguments);
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], newElement.type);
        }
        validatePropTypes(newElement);
        return newElement;
      }
    };
    module.exports = ReactElementValidator;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/onlyChild", ["npm:react@0.14.6/lib/ReactElement", "npm:fbjs@0.6.1/lib/invariant", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactElement = $__require('npm:react@0.14.6/lib/ReactElement');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    function onlyChild(children) {
      !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'onlyChild must be passed a children with exactly one child.') : invariant(false) : undefined;
      return children;
    }
    module.exports = onlyChild;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactIsomorphic", ["npm:react@0.14.6/lib/ReactChildren", "npm:react@0.14.6/lib/ReactComponent", "npm:react@0.14.6/lib/ReactClass", "npm:react@0.14.6/lib/ReactDOMFactories", "npm:react@0.14.6/lib/ReactElement", "npm:react@0.14.6/lib/ReactElementValidator", "npm:react@0.14.6/lib/ReactPropTypes", "npm:react@0.14.6/lib/ReactVersion", "npm:react@0.14.6/lib/Object.assign", "npm:react@0.14.6/lib/onlyChild", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactChildren = $__require('npm:react@0.14.6/lib/ReactChildren');
    var ReactComponent = $__require('npm:react@0.14.6/lib/ReactComponent');
    var ReactClass = $__require('npm:react@0.14.6/lib/ReactClass');
    var ReactDOMFactories = $__require('npm:react@0.14.6/lib/ReactDOMFactories');
    var ReactElement = $__require('npm:react@0.14.6/lib/ReactElement');
    var ReactElementValidator = $__require('npm:react@0.14.6/lib/ReactElementValidator');
    var ReactPropTypes = $__require('npm:react@0.14.6/lib/ReactPropTypes');
    var ReactVersion = $__require('npm:react@0.14.6/lib/ReactVersion');
    var assign = $__require('npm:react@0.14.6/lib/Object.assign');
    var onlyChild = $__require('npm:react@0.14.6/lib/onlyChild');
    var createElement = ReactElement.createElement;
    var createFactory = ReactElement.createFactory;
    var cloneElement = ReactElement.cloneElement;
    if (process.env.NODE_ENV !== 'production') {
      createElement = ReactElementValidator.createElement;
      createFactory = ReactElementValidator.createFactory;
      cloneElement = ReactElementValidator.cloneElement;
    }
    var React = {
      Children: {
        map: ReactChildren.map,
        forEach: ReactChildren.forEach,
        count: ReactChildren.count,
        toArray: ReactChildren.toArray,
        only: onlyChild
      },
      Component: ReactComponent,
      createElement: createElement,
      cloneElement: cloneElement,
      isValidElement: ReactElement.isValidElement,
      PropTypes: ReactPropTypes,
      createClass: ReactClass.createClass,
      createFactory: createFactory,
      createMixin: function(mixin) {
        return mixin;
      },
      DOM: ReactDOMFactories,
      version: ReactVersion,
      __spread: assign
    };
    module.exports = React;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/deprecated", ["npm:react@0.14.6/lib/Object.assign", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var assign = $__require('npm:react@0.14.6/lib/Object.assign');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    function deprecated(fnName, newModule, newPackage, ctx, fn) {
      var warned = false;
      if (process.env.NODE_ENV !== 'production') {
        var newFn = function() {
          process.env.NODE_ENV !== 'production' ? warning(warned, 'React.%s is deprecated. Please use %s.%s from require' + '(\'%s\') ' + 'instead.', fnName, newModule, fnName, newPackage) : undefined;
          warned = true;
          return fn.apply(ctx, arguments);
        };
        return assign(newFn, fn);
      }
      return fn;
    }
    module.exports = deprecated;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/React", ["npm:react@0.14.6/lib/ReactDOM", "npm:react@0.14.6/lib/ReactDOMServer", "npm:react@0.14.6/lib/ReactIsomorphic", "npm:react@0.14.6/lib/Object.assign", "npm:react@0.14.6/lib/deprecated"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ReactDOM = $__require('npm:react@0.14.6/lib/ReactDOM');
  var ReactDOMServer = $__require('npm:react@0.14.6/lib/ReactDOMServer');
  var ReactIsomorphic = $__require('npm:react@0.14.6/lib/ReactIsomorphic');
  var assign = $__require('npm:react@0.14.6/lib/Object.assign');
  var deprecated = $__require('npm:react@0.14.6/lib/deprecated');
  var React = {};
  assign(React, ReactIsomorphic);
  assign(React, {
    findDOMNode: deprecated('findDOMNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.findDOMNode),
    render: deprecated('render', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.render),
    unmountComponentAtNode: deprecated('unmountComponentAtNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.unmountComponentAtNode),
    renderToString: deprecated('renderToString', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToString),
    renderToStaticMarkup: deprecated('renderToStaticMarkup', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToStaticMarkup)
  });
  React.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOM;
  React.__SECRET_DOM_SERVER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOMServer;
  module.exports = React;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/react", ["npm:react@0.14.6/lib/React"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:react@0.14.6/lib/React');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6", ["npm:react@0.14.6/react"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:react@0.14.6/react');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/FallbackCompositionState", ["npm:react@0.14.6/lib/PooledClass", "npm:react@0.14.6/lib/Object.assign", "npm:react@0.14.6/lib/getTextContentAccessor"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var PooledClass = $__require('npm:react@0.14.6/lib/PooledClass');
  var assign = $__require('npm:react@0.14.6/lib/Object.assign');
  var getTextContentAccessor = $__require('npm:react@0.14.6/lib/getTextContentAccessor');
  function FallbackCompositionState(root) {
    this._root = root;
    this._startText = this.getText();
    this._fallbackText = null;
  }
  assign(FallbackCompositionState.prototype, {
    destructor: function() {
      this._root = null;
      this._startText = null;
      this._fallbackText = null;
    },
    getText: function() {
      if ('value' in this._root) {
        return this._root.value;
      }
      return this._root[getTextContentAccessor()];
    },
    getData: function() {
      if (this._fallbackText) {
        return this._fallbackText;
      }
      var start;
      var startValue = this._startText;
      var startLength = startValue.length;
      var end;
      var endValue = this.getText();
      var endLength = endValue.length;
      for (start = 0; start < startLength; start++) {
        if (startValue[start] !== endValue[start]) {
          break;
        }
      }
      var minEnd = startLength - start;
      for (end = 1; end <= minEnd; end++) {
        if (startValue[startLength - end] !== endValue[endLength - end]) {
          break;
        }
      }
      var sliceTail = end > 1 ? 1 - end : undefined;
      this._fallbackText = endValue.slice(start, sliceTail);
      return this._fallbackText;
    }
  });
  PooledClass.addPoolingTo(FallbackCompositionState);
  module.exports = FallbackCompositionState;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/SyntheticCompositionEvent", ["npm:react@0.14.6/lib/SyntheticEvent"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var SyntheticEvent = $__require('npm:react@0.14.6/lib/SyntheticEvent');
  var CompositionEventInterface = {data: null};
  function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
  module.exports = SyntheticCompositionEvent;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/SyntheticInputEvent", ["npm:react@0.14.6/lib/SyntheticEvent"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var SyntheticEvent = $__require('npm:react@0.14.6/lib/SyntheticEvent');
  var InputEventInterface = {data: null};
  function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
  module.exports = SyntheticInputEvent;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/BeforeInputEventPlugin", ["npm:react@0.14.6/lib/EventConstants", "npm:react@0.14.6/lib/EventPropagators", "npm:fbjs@0.6.1/lib/ExecutionEnvironment", "npm:react@0.14.6/lib/FallbackCompositionState", "npm:react@0.14.6/lib/SyntheticCompositionEvent", "npm:react@0.14.6/lib/SyntheticInputEvent", "npm:fbjs@0.6.1/lib/keyOf"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var EventConstants = $__require('npm:react@0.14.6/lib/EventConstants');
  var EventPropagators = $__require('npm:react@0.14.6/lib/EventPropagators');
  var ExecutionEnvironment = $__require('npm:fbjs@0.6.1/lib/ExecutionEnvironment');
  var FallbackCompositionState = $__require('npm:react@0.14.6/lib/FallbackCompositionState');
  var SyntheticCompositionEvent = $__require('npm:react@0.14.6/lib/SyntheticCompositionEvent');
  var SyntheticInputEvent = $__require('npm:react@0.14.6/lib/SyntheticInputEvent');
  var keyOf = $__require('npm:fbjs@0.6.1/lib/keyOf');
  var END_KEYCODES = [9, 13, 27, 32];
  var START_KEYCODE = 229;
  var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
  var documentMode = null;
  if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
    documentMode = document.documentMode;
  }
  var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
  var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
  function isPresto() {
    var opera = window.opera;
    return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
  }
  var SPACEBAR_CODE = 32;
  var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
  var topLevelTypes = EventConstants.topLevelTypes;
  var eventTypes = {
    beforeInput: {
      phasedRegistrationNames: {
        bubbled: keyOf({onBeforeInput: null}),
        captured: keyOf({onBeforeInputCapture: null})
      },
      dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
    },
    compositionEnd: {
      phasedRegistrationNames: {
        bubbled: keyOf({onCompositionEnd: null}),
        captured: keyOf({onCompositionEndCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
    },
    compositionStart: {
      phasedRegistrationNames: {
        bubbled: keyOf({onCompositionStart: null}),
        captured: keyOf({onCompositionStartCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
    },
    compositionUpdate: {
      phasedRegistrationNames: {
        bubbled: keyOf({onCompositionUpdate: null}),
        captured: keyOf({onCompositionUpdateCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
    }
  };
  var hasSpaceKeypress = false;
  function isKeypressCommand(nativeEvent) {
    return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);
  }
  function getCompositionEventType(topLevelType) {
    switch (topLevelType) {
      case topLevelTypes.topCompositionStart:
        return eventTypes.compositionStart;
      case topLevelTypes.topCompositionEnd:
        return eventTypes.compositionEnd;
      case topLevelTypes.topCompositionUpdate:
        return eventTypes.compositionUpdate;
    }
  }
  function isFallbackCompositionStart(topLevelType, nativeEvent) {
    return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
  }
  function isFallbackCompositionEnd(topLevelType, nativeEvent) {
    switch (topLevelType) {
      case topLevelTypes.topKeyUp:
        return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
      case topLevelTypes.topKeyDown:
        return nativeEvent.keyCode !== START_KEYCODE;
      case topLevelTypes.topKeyPress:
      case topLevelTypes.topMouseDown:
      case topLevelTypes.topBlur:
        return true;
      default:
        return false;
    }
  }
  function getDataFromCustomEvent(nativeEvent) {
    var detail = nativeEvent.detail;
    if (typeof detail === 'object' && 'data' in detail) {
      return detail.data;
    }
    return null;
  }
  var currentComposition = null;
  function extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    var eventType;
    var fallbackData;
    if (canUseCompositionEvent) {
      eventType = getCompositionEventType(topLevelType);
    } else if (!currentComposition) {
      if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
        eventType = eventTypes.compositionStart;
      }
    } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionEnd;
    }
    if (!eventType) {
      return null;
    }
    if (useFallbackCompositionData) {
      if (!currentComposition && eventType === eventTypes.compositionStart) {
        currentComposition = FallbackCompositionState.getPooled(topLevelTarget);
      } else if (eventType === eventTypes.compositionEnd) {
        if (currentComposition) {
          fallbackData = currentComposition.getData();
        }
      }
    }
    var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent, nativeEventTarget);
    if (fallbackData) {
      event.data = fallbackData;
    } else {
      var customData = getDataFromCustomEvent(nativeEvent);
      if (customData !== null) {
        event.data = customData;
      }
    }
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  }
  function getNativeBeforeInputChars(topLevelType, nativeEvent) {
    switch (topLevelType) {
      case topLevelTypes.topCompositionEnd:
        return getDataFromCustomEvent(nativeEvent);
      case topLevelTypes.topKeyPress:
        var which = nativeEvent.which;
        if (which !== SPACEBAR_CODE) {
          return null;
        }
        hasSpaceKeypress = true;
        return SPACEBAR_CHAR;
      case topLevelTypes.topTextInput:
        var chars = nativeEvent.data;
        if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
          return null;
        }
        return chars;
      default:
        return null;
    }
  }
  function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
    if (currentComposition) {
      if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
        var chars = currentComposition.getData();
        FallbackCompositionState.release(currentComposition);
        currentComposition = null;
        return chars;
      }
      return null;
    }
    switch (topLevelType) {
      case topLevelTypes.topPaste:
        return null;
      case topLevelTypes.topKeyPress:
        if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
          return String.fromCharCode(nativeEvent.which);
        }
        return null;
      case topLevelTypes.topCompositionEnd:
        return useFallbackCompositionData ? null : nativeEvent.data;
      default:
        return null;
    }
  }
  function extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    var chars;
    if (canUseTextInputEvent) {
      chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
    } else {
      chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
    }
    if (!chars) {
      return null;
    }
    var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent, nativeEventTarget);
    event.data = chars;
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  }
  var BeforeInputEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
      return [extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget)];
    }
  };
  module.exports = BeforeInputEventPlugin;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ChangeEventPlugin", ["npm:react@0.14.6/lib/EventConstants", "npm:react@0.14.6/lib/EventPluginHub", "npm:react@0.14.6/lib/EventPropagators", "npm:fbjs@0.6.1/lib/ExecutionEnvironment", "npm:react@0.14.6/lib/ReactUpdates", "npm:react@0.14.6/lib/SyntheticEvent", "npm:react@0.14.6/lib/getEventTarget", "npm:react@0.14.6/lib/isEventSupported", "npm:react@0.14.6/lib/isTextInputElement", "npm:fbjs@0.6.1/lib/keyOf", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var EventConstants = $__require('npm:react@0.14.6/lib/EventConstants');
    var EventPluginHub = $__require('npm:react@0.14.6/lib/EventPluginHub');
    var EventPropagators = $__require('npm:react@0.14.6/lib/EventPropagators');
    var ExecutionEnvironment = $__require('npm:fbjs@0.6.1/lib/ExecutionEnvironment');
    var ReactUpdates = $__require('npm:react@0.14.6/lib/ReactUpdates');
    var SyntheticEvent = $__require('npm:react@0.14.6/lib/SyntheticEvent');
    var getEventTarget = $__require('npm:react@0.14.6/lib/getEventTarget');
    var isEventSupported = $__require('npm:react@0.14.6/lib/isEventSupported');
    var isTextInputElement = $__require('npm:react@0.14.6/lib/isTextInputElement');
    var keyOf = $__require('npm:fbjs@0.6.1/lib/keyOf');
    var topLevelTypes = EventConstants.topLevelTypes;
    var eventTypes = {change: {
        phasedRegistrationNames: {
          bubbled: keyOf({onChange: null}),
          captured: keyOf({onChangeCapture: null})
        },
        dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
      }};
    var activeElement = null;
    var activeElementID = null;
    var activeElementValue = null;
    var activeElementValueProp = null;
    function shouldUseChangeEvent(elem) {
      var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
    }
    var doesChangeEventBubble = false;
    if (ExecutionEnvironment.canUseDOM) {
      doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
    }
    function manualDispatchChangeEvent(nativeEvent) {
      var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent, getEventTarget(nativeEvent));
      EventPropagators.accumulateTwoPhaseDispatches(event);
      ReactUpdates.batchedUpdates(runEventInBatch, event);
    }
    function runEventInBatch(event) {
      EventPluginHub.enqueueEvents(event);
      EventPluginHub.processEventQueue(false);
    }
    function startWatchingForChangeEventIE8(target, targetID) {
      activeElement = target;
      activeElementID = targetID;
      activeElement.attachEvent('onchange', manualDispatchChangeEvent);
    }
    function stopWatchingForChangeEventIE8() {
      if (!activeElement) {
        return;
      }
      activeElement.detachEvent('onchange', manualDispatchChangeEvent);
      activeElement = null;
      activeElementID = null;
    }
    function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topChange) {
        return topLevelTargetID;
      }
    }
    function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topFocus) {
        stopWatchingForChangeEventIE8();
        startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
      } else if (topLevelType === topLevelTypes.topBlur) {
        stopWatchingForChangeEventIE8();
      }
    }
    var isInputEventSupported = false;
    if (ExecutionEnvironment.canUseDOM) {
      isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
    }
    var newValueProp = {
      get: function() {
        return activeElementValueProp.get.call(this);
      },
      set: function(val) {
        activeElementValue = '' + val;
        activeElementValueProp.set.call(this, val);
      }
    };
    function startWatchingForValueChange(target, targetID) {
      activeElement = target;
      activeElementID = targetID;
      activeElementValue = target.value;
      activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
      Object.defineProperty(activeElement, 'value', newValueProp);
      activeElement.attachEvent('onpropertychange', handlePropertyChange);
    }
    function stopWatchingForValueChange() {
      if (!activeElement) {
        return;
      }
      delete activeElement.value;
      activeElement.detachEvent('onpropertychange', handlePropertyChange);
      activeElement = null;
      activeElementID = null;
      activeElementValue = null;
      activeElementValueProp = null;
    }
    function handlePropertyChange(nativeEvent) {
      if (nativeEvent.propertyName !== 'value') {
        return;
      }
      var value = nativeEvent.srcElement.value;
      if (value === activeElementValue) {
        return;
      }
      activeElementValue = value;
      manualDispatchChangeEvent(nativeEvent);
    }
    function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topInput) {
        return topLevelTargetID;
      }
    }
    function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topFocus) {
        stopWatchingForValueChange();
        startWatchingForValueChange(topLevelTarget, topLevelTargetID);
      } else if (topLevelType === topLevelTypes.topBlur) {
        stopWatchingForValueChange();
      }
    }
    function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
        if (activeElement && activeElement.value !== activeElementValue) {
          activeElementValue = activeElement.value;
          return activeElementID;
        }
      }
    }
    function shouldUseClickEvent(elem) {
      return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
    }
    function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topClick) {
        return topLevelTargetID;
      }
    }
    var ChangeEventPlugin = {
      eventTypes: eventTypes,
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
        var getTargetIDFunc,
            handleEventFunc;
        if (shouldUseChangeEvent(topLevelTarget)) {
          if (doesChangeEventBubble) {
            getTargetIDFunc = getTargetIDForChangeEvent;
          } else {
            handleEventFunc = handleEventsForChangeEventIE8;
          }
        } else if (isTextInputElement(topLevelTarget)) {
          if (isInputEventSupported) {
            getTargetIDFunc = getTargetIDForInputEvent;
          } else {
            getTargetIDFunc = getTargetIDForInputEventIE;
            handleEventFunc = handleEventsForInputEventIE;
          }
        } else if (shouldUseClickEvent(topLevelTarget)) {
          getTargetIDFunc = getTargetIDForClickEvent;
        }
        if (getTargetIDFunc) {
          var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
          if (targetID) {
            var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent, nativeEventTarget);
            event.type = 'change';
            EventPropagators.accumulateTwoPhaseDispatches(event);
            return event;
          }
        }
        if (handleEventFunc) {
          handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
        }
      }
    };
    module.exports = ChangeEventPlugin;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ClientReactRootIndex", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var nextReactRootIndex = 0;
  var ClientReactRootIndex = {createReactRootIndex: function() {
      return nextReactRootIndex++;
    }};
  module.exports = ClientReactRootIndex;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/DefaultEventPluginOrder", ["npm:fbjs@0.6.1/lib/keyOf"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var keyOf = $__require('npm:fbjs@0.6.1/lib/keyOf');
  var DefaultEventPluginOrder = [keyOf({ResponderEventPlugin: null}), keyOf({SimpleEventPlugin: null}), keyOf({TapEventPlugin: null}), keyOf({EnterLeaveEventPlugin: null}), keyOf({ChangeEventPlugin: null}), keyOf({SelectEventPlugin: null}), keyOf({BeforeInputEventPlugin: null})];
  module.exports = DefaultEventPluginOrder;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/EnterLeaveEventPlugin", ["npm:react@0.14.6/lib/EventConstants", "npm:react@0.14.6/lib/EventPropagators", "npm:react@0.14.6/lib/SyntheticMouseEvent", "npm:react@0.14.6/lib/ReactMount", "npm:fbjs@0.6.1/lib/keyOf"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var EventConstants = $__require('npm:react@0.14.6/lib/EventConstants');
  var EventPropagators = $__require('npm:react@0.14.6/lib/EventPropagators');
  var SyntheticMouseEvent = $__require('npm:react@0.14.6/lib/SyntheticMouseEvent');
  var ReactMount = $__require('npm:react@0.14.6/lib/ReactMount');
  var keyOf = $__require('npm:fbjs@0.6.1/lib/keyOf');
  var topLevelTypes = EventConstants.topLevelTypes;
  var getFirstReactDOM = ReactMount.getFirstReactDOM;
  var eventTypes = {
    mouseEnter: {
      registrationName: keyOf({onMouseEnter: null}),
      dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
    },
    mouseLeave: {
      registrationName: keyOf({onMouseLeave: null}),
      dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
    }
  };
  var extractedEvents = [null, null];
  var EnterLeaveEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
      if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
        return null;
      }
      if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
        return null;
      }
      var win;
      if (topLevelTarget.window === topLevelTarget) {
        win = topLevelTarget;
      } else {
        var doc = topLevelTarget.ownerDocument;
        if (doc) {
          win = doc.defaultView || doc.parentWindow;
        } else {
          win = window;
        }
      }
      var from;
      var to;
      var fromID = '';
      var toID = '';
      if (topLevelType === topLevelTypes.topMouseOut) {
        from = topLevelTarget;
        fromID = topLevelTargetID;
        to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement);
        if (to) {
          toID = ReactMount.getID(to);
        } else {
          to = win;
        }
        to = to || win;
      } else {
        from = win;
        to = topLevelTarget;
        toID = topLevelTargetID;
      }
      if (from === to) {
        return null;
      }
      var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent, nativeEventTarget);
      leave.type = 'mouseleave';
      leave.target = from;
      leave.relatedTarget = to;
      var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent, nativeEventTarget);
      enter.type = 'mouseenter';
      enter.target = to;
      enter.relatedTarget = from;
      EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);
      extractedEvents[0] = leave;
      extractedEvents[1] = enter;
      return extractedEvents;
    }
  };
  module.exports = EnterLeaveEventPlugin;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/HTMLDOMPropertyConfig", ["npm:react@0.14.6/lib/DOMProperty", "npm:fbjs@0.6.1/lib/ExecutionEnvironment"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var DOMProperty = $__require('npm:react@0.14.6/lib/DOMProperty');
  var ExecutionEnvironment = $__require('npm:fbjs@0.6.1/lib/ExecutionEnvironment');
  var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
  var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
  var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
  var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
  var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
  var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
  var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
  var hasSVG;
  if (ExecutionEnvironment.canUseDOM) {
    var implementation = document.implementation;
    hasSVG = implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1');
  }
  var HTMLDOMPropertyConfig = {
    isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
    Properties: {
      accept: null,
      acceptCharset: null,
      accessKey: null,
      action: null,
      allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      allowTransparency: MUST_USE_ATTRIBUTE,
      alt: null,
      async: HAS_BOOLEAN_VALUE,
      autoComplete: null,
      autoPlay: HAS_BOOLEAN_VALUE,
      capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      cellPadding: null,
      cellSpacing: null,
      charSet: MUST_USE_ATTRIBUTE,
      challenge: MUST_USE_ATTRIBUTE,
      checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      classID: MUST_USE_ATTRIBUTE,
      className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
      cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      colSpan: null,
      content: null,
      contentEditable: null,
      contextMenu: MUST_USE_ATTRIBUTE,
      controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      coords: null,
      crossOrigin: null,
      data: null,
      dateTime: MUST_USE_ATTRIBUTE,
      'default': HAS_BOOLEAN_VALUE,
      defer: HAS_BOOLEAN_VALUE,
      dir: null,
      disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      download: HAS_OVERLOADED_BOOLEAN_VALUE,
      draggable: null,
      encType: null,
      form: MUST_USE_ATTRIBUTE,
      formAction: MUST_USE_ATTRIBUTE,
      formEncType: MUST_USE_ATTRIBUTE,
      formMethod: MUST_USE_ATTRIBUTE,
      formNoValidate: HAS_BOOLEAN_VALUE,
      formTarget: MUST_USE_ATTRIBUTE,
      frameBorder: MUST_USE_ATTRIBUTE,
      headers: null,
      height: MUST_USE_ATTRIBUTE,
      hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      high: null,
      href: null,
      hrefLang: null,
      htmlFor: null,
      httpEquiv: null,
      icon: null,
      id: MUST_USE_PROPERTY,
      inputMode: MUST_USE_ATTRIBUTE,
      integrity: null,
      is: MUST_USE_ATTRIBUTE,
      keyParams: MUST_USE_ATTRIBUTE,
      keyType: MUST_USE_ATTRIBUTE,
      kind: null,
      label: null,
      lang: null,
      list: MUST_USE_ATTRIBUTE,
      loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      low: null,
      manifest: MUST_USE_ATTRIBUTE,
      marginHeight: null,
      marginWidth: null,
      max: null,
      maxLength: MUST_USE_ATTRIBUTE,
      media: MUST_USE_ATTRIBUTE,
      mediaGroup: null,
      method: null,
      min: null,
      minLength: MUST_USE_ATTRIBUTE,
      multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      name: null,
      nonce: MUST_USE_ATTRIBUTE,
      noValidate: HAS_BOOLEAN_VALUE,
      open: HAS_BOOLEAN_VALUE,
      optimum: null,
      pattern: null,
      placeholder: null,
      poster: null,
      preload: null,
      radioGroup: null,
      readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      rel: null,
      required: HAS_BOOLEAN_VALUE,
      reversed: HAS_BOOLEAN_VALUE,
      role: MUST_USE_ATTRIBUTE,
      rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      rowSpan: null,
      sandbox: null,
      scope: null,
      scoped: HAS_BOOLEAN_VALUE,
      scrolling: null,
      seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      shape: null,
      size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      sizes: MUST_USE_ATTRIBUTE,
      span: HAS_POSITIVE_NUMERIC_VALUE,
      spellCheck: null,
      src: null,
      srcDoc: MUST_USE_PROPERTY,
      srcLang: null,
      srcSet: MUST_USE_ATTRIBUTE,
      start: HAS_NUMERIC_VALUE,
      step: null,
      style: null,
      summary: null,
      tabIndex: null,
      target: null,
      title: null,
      type: null,
      useMap: null,
      value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
      width: MUST_USE_ATTRIBUTE,
      wmode: MUST_USE_ATTRIBUTE,
      wrap: null,
      about: MUST_USE_ATTRIBUTE,
      datatype: MUST_USE_ATTRIBUTE,
      inlist: MUST_USE_ATTRIBUTE,
      prefix: MUST_USE_ATTRIBUTE,
      property: MUST_USE_ATTRIBUTE,
      resource: MUST_USE_ATTRIBUTE,
      'typeof': MUST_USE_ATTRIBUTE,
      vocab: MUST_USE_ATTRIBUTE,
      autoCapitalize: MUST_USE_ATTRIBUTE,
      autoCorrect: MUST_USE_ATTRIBUTE,
      autoSave: null,
      color: null,
      itemProp: MUST_USE_ATTRIBUTE,
      itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      itemType: MUST_USE_ATTRIBUTE,
      itemID: MUST_USE_ATTRIBUTE,
      itemRef: MUST_USE_ATTRIBUTE,
      results: null,
      security: MUST_USE_ATTRIBUTE,
      unselectable: MUST_USE_ATTRIBUTE
    },
    DOMAttributeNames: {
      acceptCharset: 'accept-charset',
      className: 'class',
      htmlFor: 'for',
      httpEquiv: 'http-equiv'
    },
    DOMPropertyNames: {
      autoComplete: 'autocomplete',
      autoFocus: 'autofocus',
      autoPlay: 'autoplay',
      autoSave: 'autosave',
      encType: 'encoding',
      hrefLang: 'hreflang',
      radioGroup: 'radiogroup',
      spellCheck: 'spellcheck',
      srcDoc: 'srcdoc',
      srcSet: 'srcset'
    }
  };
  module.exports = HTMLDOMPropertyConfig;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactBrowserComponentMixin", ["npm:react@0.14.6/lib/ReactInstanceMap", "npm:react@0.14.6/lib/findDOMNode", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactInstanceMap = $__require('npm:react@0.14.6/lib/ReactInstanceMap');
    var findDOMNode = $__require('npm:react@0.14.6/lib/findDOMNode');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    var didWarnKey = '_getDOMNodeDidWarn';
    var ReactBrowserComponentMixin = {getDOMNode: function() {
        process.env.NODE_ENV !== 'production' ? warning(this.constructor[didWarnKey], '%s.getDOMNode(...) is deprecated. Please use ' + 'ReactDOM.findDOMNode(instance) instead.', ReactInstanceMap.get(this).getName() || this.tagName || 'Unknown') : undefined;
        this.constructor[didWarnKey] = true;
        return findDOMNode(this);
      }};
    module.exports = ReactBrowserComponentMixin;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactDefaultBatchingStrategy", ["npm:react@0.14.6/lib/ReactUpdates", "npm:react@0.14.6/lib/Transaction", "npm:react@0.14.6/lib/Object.assign", "npm:fbjs@0.6.1/lib/emptyFunction"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ReactUpdates = $__require('npm:react@0.14.6/lib/ReactUpdates');
  var Transaction = $__require('npm:react@0.14.6/lib/Transaction');
  var assign = $__require('npm:react@0.14.6/lib/Object.assign');
  var emptyFunction = $__require('npm:fbjs@0.6.1/lib/emptyFunction');
  var RESET_BATCHED_UPDATES = {
    initialize: emptyFunction,
    close: function() {
      ReactDefaultBatchingStrategy.isBatchingUpdates = false;
    }
  };
  var FLUSH_BATCHED_UPDATES = {
    initialize: emptyFunction,
    close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
  };
  var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
  function ReactDefaultBatchingStrategyTransaction() {
    this.reinitializeTransaction();
  }
  assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    }});
  var transaction = new ReactDefaultBatchingStrategyTransaction();
  var ReactDefaultBatchingStrategy = {
    isBatchingUpdates: false,
    batchedUpdates: function(callback, a, b, c, d, e) {
      var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
      ReactDefaultBatchingStrategy.isBatchingUpdates = true;
      if (alreadyBatchingUpdates) {
        callback(a, b, c, d, e);
      } else {
        transaction.perform(callback, null, a, b, c, d, e);
      }
    }
  };
  module.exports = ReactDefaultBatchingStrategy;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/AutoFocusUtils", ["npm:react@0.14.6/lib/ReactMount", "npm:react@0.14.6/lib/findDOMNode", "npm:fbjs@0.6.1/lib/focusNode"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ReactMount = $__require('npm:react@0.14.6/lib/ReactMount');
  var findDOMNode = $__require('npm:react@0.14.6/lib/findDOMNode');
  var focusNode = $__require('npm:fbjs@0.6.1/lib/focusNode');
  var Mixin = {componentDidMount: function() {
      if (this.props.autoFocus) {
        focusNode(findDOMNode(this));
      }
    }};
  var AutoFocusUtils = {
    Mixin: Mixin,
    focusDOMComponent: function() {
      focusNode(ReactMount.getNode(this._rootNodeID));
    }
  };
  module.exports = AutoFocusUtils;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/camelize", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _hyphenPattern = /-(.)/g;
  function camelize(string) {
    return string.replace(_hyphenPattern, function(_, character) {
      return character.toUpperCase();
    });
  }
  module.exports = camelize;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/camelizeStyleName", ["npm:fbjs@0.6.1/lib/camelize"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var camelize = $__require('npm:fbjs@0.6.1/lib/camelize');
  var msPattern = /^-ms-/;
  function camelizeStyleName(string) {
    return camelize(string.replace(msPattern, 'ms-'));
  }
  module.exports = camelizeStyleName;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/CSSProperty", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isUnitlessNumber = {
    animationIterationCount: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    stopOpacity: true,
    strokeDashoffset: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  function prefixKey(prefix, key) {
    return prefix + key.charAt(0).toUpperCase() + key.substring(1);
  }
  var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
  Object.keys(isUnitlessNumber).forEach(function(prop) {
    prefixes.forEach(function(prefix) {
      isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
    });
  });
  var shorthandPropertyExpansions = {
    background: {
      backgroundAttachment: true,
      backgroundColor: true,
      backgroundImage: true,
      backgroundPositionX: true,
      backgroundPositionY: true,
      backgroundRepeat: true
    },
    backgroundPosition: {
      backgroundPositionX: true,
      backgroundPositionY: true
    },
    border: {
      borderWidth: true,
      borderStyle: true,
      borderColor: true
    },
    borderBottom: {
      borderBottomWidth: true,
      borderBottomStyle: true,
      borderBottomColor: true
    },
    borderLeft: {
      borderLeftWidth: true,
      borderLeftStyle: true,
      borderLeftColor: true
    },
    borderRight: {
      borderRightWidth: true,
      borderRightStyle: true,
      borderRightColor: true
    },
    borderTop: {
      borderTopWidth: true,
      borderTopStyle: true,
      borderTopColor: true
    },
    font: {
      fontStyle: true,
      fontVariant: true,
      fontWeight: true,
      fontSize: true,
      lineHeight: true,
      fontFamily: true
    },
    outline: {
      outlineWidth: true,
      outlineStyle: true,
      outlineColor: true
    }
  };
  var CSSProperty = {
    isUnitlessNumber: isUnitlessNumber,
    shorthandPropertyExpansions: shorthandPropertyExpansions
  };
  module.exports = CSSProperty;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/dangerousStyleValue", ["npm:react@0.14.6/lib/CSSProperty"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var CSSProperty = $__require('npm:react@0.14.6/lib/CSSProperty');
  var isUnitlessNumber = CSSProperty.isUnitlessNumber;
  function dangerousStyleValue(name, value) {
    var isEmpty = value == null || typeof value === 'boolean' || value === '';
    if (isEmpty) {
      return '';
    }
    var isNonNumeric = isNaN(value);
    if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
      return '' + value;
    }
    if (typeof value === 'string') {
      value = value.trim();
    }
    return value + 'px';
  }
  module.exports = dangerousStyleValue;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/hyphenate", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _uppercasePattern = /([A-Z])/g;
  function hyphenate(string) {
    return string.replace(_uppercasePattern, '-$1').toLowerCase();
  }
  module.exports = hyphenate;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/hyphenateStyleName", ["npm:fbjs@0.6.1/lib/hyphenate"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hyphenate = $__require('npm:fbjs@0.6.1/lib/hyphenate');
  var msPattern = /^ms-/;
  function hyphenateStyleName(string) {
    return hyphenate(string).replace(msPattern, '-ms-');
  }
  module.exports = hyphenateStyleName;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/memoizeStringOnly", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function memoizeStringOnly(callback) {
    var cache = {};
    return function(string) {
      if (!cache.hasOwnProperty(string)) {
        cache[string] = callback.call(this, string);
      }
      return cache[string];
    };
  }
  module.exports = memoizeStringOnly;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/CSSPropertyOperations", ["npm:react@0.14.6/lib/CSSProperty", "npm:fbjs@0.6.1/lib/ExecutionEnvironment", "npm:react@0.14.6/lib/ReactPerf", "npm:fbjs@0.6.1/lib/camelizeStyleName", "npm:react@0.14.6/lib/dangerousStyleValue", "npm:fbjs@0.6.1/lib/hyphenateStyleName", "npm:fbjs@0.6.1/lib/memoizeStringOnly", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var CSSProperty = $__require('npm:react@0.14.6/lib/CSSProperty');
    var ExecutionEnvironment = $__require('npm:fbjs@0.6.1/lib/ExecutionEnvironment');
    var ReactPerf = $__require('npm:react@0.14.6/lib/ReactPerf');
    var camelizeStyleName = $__require('npm:fbjs@0.6.1/lib/camelizeStyleName');
    var dangerousStyleValue = $__require('npm:react@0.14.6/lib/dangerousStyleValue');
    var hyphenateStyleName = $__require('npm:fbjs@0.6.1/lib/hyphenateStyleName');
    var memoizeStringOnly = $__require('npm:fbjs@0.6.1/lib/memoizeStringOnly');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    var processStyleName = memoizeStringOnly(function(styleName) {
      return hyphenateStyleName(styleName);
    });
    var hasShorthandPropertyBug = false;
    var styleFloatAccessor = 'cssFloat';
    if (ExecutionEnvironment.canUseDOM) {
      var tempStyle = document.createElement('div').style;
      try {
        tempStyle.font = '';
      } catch (e) {
        hasShorthandPropertyBug = true;
      }
      if (document.documentElement.style.cssFloat === undefined) {
        styleFloatAccessor = 'styleFloat';
      }
    }
    if (process.env.NODE_ENV !== 'production') {
      var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
      var badStyleValueWithSemicolonPattern = /;\s*$/;
      var warnedStyleNames = {};
      var warnedStyleValues = {};
      var warnHyphenatedStyleName = function(name) {
        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
          return;
        }
        warnedStyleNames[name] = true;
        process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?', name, camelizeStyleName(name)) : undefined;
      };
      var warnBadVendoredStyleName = function(name) {
        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
          return;
        }
        warnedStyleNames[name] = true;
        process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1)) : undefined;
      };
      var warnStyleValueWithSemicolon = function(name, value) {
        if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
          return;
        }
        warnedStyleValues[value] = true;
        process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon. ' + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, '')) : undefined;
      };
      var warnValidStyle = function(name, value) {
        if (name.indexOf('-') > -1) {
          warnHyphenatedStyleName(name);
        } else if (badVendoredStyleNamePattern.test(name)) {
          warnBadVendoredStyleName(name);
        } else if (badStyleValueWithSemicolonPattern.test(value)) {
          warnStyleValueWithSemicolon(name, value);
        }
      };
    }
    var CSSPropertyOperations = {
      createMarkupForStyles: function(styles) {
        var serialized = '';
        for (var styleName in styles) {
          if (!styles.hasOwnProperty(styleName)) {
            continue;
          }
          var styleValue = styles[styleName];
          if (process.env.NODE_ENV !== 'production') {
            warnValidStyle(styleName, styleValue);
          }
          if (styleValue != null) {
            serialized += processStyleName(styleName) + ':';
            serialized += dangerousStyleValue(styleName, styleValue) + ';';
          }
        }
        return serialized || null;
      },
      setValueForStyles: function(node, styles) {
        var style = node.style;
        for (var styleName in styles) {
          if (!styles.hasOwnProperty(styleName)) {
            continue;
          }
          if (process.env.NODE_ENV !== 'production') {
            warnValidStyle(styleName, styles[styleName]);
          }
          var styleValue = dangerousStyleValue(styleName, styles[styleName]);
          if (styleName === 'float') {
            styleName = styleFloatAccessor;
          }
          if (styleValue) {
            style[styleName] = styleValue;
          } else {
            var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
            if (expansion) {
              for (var individualStyleName in expansion) {
                style[individualStyleName] = '';
              }
            } else {
              style[styleName] = '';
            }
          }
        }
      }
    };
    ReactPerf.measureMethods(CSSPropertyOperations, 'CSSPropertyOperations', {setValueForStyles: 'setValueForStyles'});
    module.exports = CSSPropertyOperations;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactDOMButton", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var mouseListenerNames = {
    onClick: true,
    onDoubleClick: true,
    onMouseDown: true,
    onMouseMove: true,
    onMouseUp: true,
    onClickCapture: true,
    onDoubleClickCapture: true,
    onMouseDownCapture: true,
    onMouseMoveCapture: true,
    onMouseUpCapture: true
  };
  var ReactDOMButton = {getNativeProps: function(inst, props, context) {
      if (!props.disabled) {
        return props;
      }
      var nativeProps = {};
      for (var key in props) {
        if (props.hasOwnProperty(key) && !mouseListenerNames[key]) {
          nativeProps[key] = props[key];
        }
      }
      return nativeProps;
    }};
  module.exports = ReactDOMButton;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactDOMInput", ["npm:react@0.14.6/lib/ReactDOMIDOperations", "npm:react@0.14.6/lib/LinkedValueUtils", "npm:react@0.14.6/lib/ReactMount", "npm:react@0.14.6/lib/ReactUpdates", "npm:react@0.14.6/lib/Object.assign", "npm:fbjs@0.6.1/lib/invariant", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactDOMIDOperations = $__require('npm:react@0.14.6/lib/ReactDOMIDOperations');
    var LinkedValueUtils = $__require('npm:react@0.14.6/lib/LinkedValueUtils');
    var ReactMount = $__require('npm:react@0.14.6/lib/ReactMount');
    var ReactUpdates = $__require('npm:react@0.14.6/lib/ReactUpdates');
    var assign = $__require('npm:react@0.14.6/lib/Object.assign');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var instancesByReactID = {};
    function forceUpdateIfMounted() {
      if (this._rootNodeID) {
        ReactDOMInput.updateWrapper(this);
      }
    }
    var ReactDOMInput = {
      getNativeProps: function(inst, props, context) {
        var value = LinkedValueUtils.getValue(props);
        var checked = LinkedValueUtils.getChecked(props);
        var nativeProps = assign({}, props, {
          defaultChecked: undefined,
          defaultValue: undefined,
          value: value != null ? value : inst._wrapperState.initialValue,
          checked: checked != null ? checked : inst._wrapperState.initialChecked,
          onChange: inst._wrapperState.onChange
        });
        return nativeProps;
      },
      mountWrapper: function(inst, props) {
        if (process.env.NODE_ENV !== 'production') {
          LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
        }
        var defaultValue = props.defaultValue;
        inst._wrapperState = {
          initialChecked: props.defaultChecked || false,
          initialValue: defaultValue != null ? defaultValue : null,
          onChange: _handleChange.bind(inst)
        };
      },
      mountReadyWrapper: function(inst) {
        instancesByReactID[inst._rootNodeID] = inst;
      },
      unmountWrapper: function(inst) {
        delete instancesByReactID[inst._rootNodeID];
      },
      updateWrapper: function(inst) {
        var props = inst._currentElement.props;
        var checked = props.checked;
        if (checked != null) {
          ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'checked', checked || false);
        }
        var value = LinkedValueUtils.getValue(props);
        if (value != null) {
          ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
        }
      }
    };
    function _handleChange(event) {
      var props = this._currentElement.props;
      var returnValue = LinkedValueUtils.executeOnChange(props, event);
      ReactUpdates.asap(forceUpdateIfMounted, this);
      var name = props.name;
      if (props.type === 'radio' && name != null) {
        var rootNode = ReactMount.getNode(this._rootNodeID);
        var queryRoot = rootNode;
        while (queryRoot.parentNode) {
          queryRoot = queryRoot.parentNode;
        }
        var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
        for (var i = 0; i < group.length; i++) {
          var otherNode = group[i];
          if (otherNode === rootNode || otherNode.form !== rootNode.form) {
            continue;
          }
          var otherID = ReactMount.getID(otherNode);
          !otherID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(false) : undefined;
          var otherInstance = instancesByReactID[otherID];
          !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(false) : undefined;
          ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
        }
      }
      return returnValue;
    }
    module.exports = ReactDOMInput;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactChildren", ["npm:react@0.14.6/lib/PooledClass", "npm:react@0.14.6/lib/ReactElement", "npm:fbjs@0.6.1/lib/emptyFunction", "npm:react@0.14.6/lib/traverseAllChildren"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var PooledClass = $__require('npm:react@0.14.6/lib/PooledClass');
  var ReactElement = $__require('npm:react@0.14.6/lib/ReactElement');
  var emptyFunction = $__require('npm:fbjs@0.6.1/lib/emptyFunction');
  var traverseAllChildren = $__require('npm:react@0.14.6/lib/traverseAllChildren');
  var twoArgumentPooler = PooledClass.twoArgumentPooler;
  var fourArgumentPooler = PooledClass.fourArgumentPooler;
  var userProvidedKeyEscapeRegex = /\/(?!\/)/g;
  function escapeUserProvidedKey(text) {
    return ('' + text).replace(userProvidedKeyEscapeRegex, '//');
  }
  function ForEachBookKeeping(forEachFunction, forEachContext) {
    this.func = forEachFunction;
    this.context = forEachContext;
    this.count = 0;
  }
  ForEachBookKeeping.prototype.destructor = function() {
    this.func = null;
    this.context = null;
    this.count = 0;
  };
  PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
  function forEachSingleChild(bookKeeping, child, name) {
    var func = bookKeeping.func;
    var context = bookKeeping.context;
    func.call(context, child, bookKeeping.count++);
  }
  function forEachChildren(children, forEachFunc, forEachContext) {
    if (children == null) {
      return children;
    }
    var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
    traverseAllChildren(children, forEachSingleChild, traverseContext);
    ForEachBookKeeping.release(traverseContext);
  }
  function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
    this.result = mapResult;
    this.keyPrefix = keyPrefix;
    this.func = mapFunction;
    this.context = mapContext;
    this.count = 0;
  }
  MapBookKeeping.prototype.destructor = function() {
    this.result = null;
    this.keyPrefix = null;
    this.func = null;
    this.context = null;
    this.count = 0;
  };
  PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
  function mapSingleChildIntoContext(bookKeeping, child, childKey) {
    var result = bookKeeping.result;
    var keyPrefix = bookKeeping.keyPrefix;
    var func = bookKeeping.func;
    var context = bookKeeping.context;
    var mappedChild = func.call(context, child, bookKeeping.count++);
    if (Array.isArray(mappedChild)) {
      mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
    } else if (mappedChild != null) {
      if (ReactElement.isValidElement(mappedChild)) {
        mappedChild = ReactElement.cloneAndReplaceKey(mappedChild, keyPrefix + (mappedChild !== child ? escapeUserProvidedKey(mappedChild.key || '') + '/' : '') + childKey);
      }
      result.push(mappedChild);
    }
  }
  function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
    var escapedPrefix = '';
    if (prefix != null) {
      escapedPrefix = escapeUserProvidedKey(prefix) + '/';
    }
    var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
    traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
    MapBookKeeping.release(traverseContext);
  }
  function mapChildren(children, func, context) {
    if (children == null) {
      return children;
    }
    var result = [];
    mapIntoWithKeyPrefixInternal(children, result, null, func, context);
    return result;
  }
  function forEachSingleChildDummy(traverseContext, child, name) {
    return null;
  }
  function countChildren(children, context) {
    return traverseAllChildren(children, forEachSingleChildDummy, null);
  }
  function toArray(children) {
    var result = [];
    mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
    return result;
  }
  var ReactChildren = {
    forEach: forEachChildren,
    map: mapChildren,
    mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
    count: countChildren,
    toArray: toArray
  };
  module.exports = ReactChildren;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactDOMOption", ["npm:react@0.14.6/lib/ReactChildren", "npm:react@0.14.6/lib/ReactDOMSelect", "npm:react@0.14.6/lib/Object.assign", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactChildren = $__require('npm:react@0.14.6/lib/ReactChildren');
    var ReactDOMSelect = $__require('npm:react@0.14.6/lib/ReactDOMSelect');
    var assign = $__require('npm:react@0.14.6/lib/Object.assign');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    var valueContextKey = ReactDOMSelect.valueContextKey;
    var ReactDOMOption = {
      mountWrapper: function(inst, props, context) {
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : undefined;
        }
        var selectValue = context[valueContextKey];
        var selected = null;
        if (selectValue != null) {
          selected = false;
          if (Array.isArray(selectValue)) {
            for (var i = 0; i < selectValue.length; i++) {
              if ('' + selectValue[i] === '' + props.value) {
                selected = true;
                break;
              }
            }
          } else {
            selected = '' + selectValue === '' + props.value;
          }
        }
        inst._wrapperState = {selected: selected};
      },
      getNativeProps: function(inst, props, context) {
        var nativeProps = assign({
          selected: undefined,
          children: undefined
        }, props);
        if (inst._wrapperState.selected != null) {
          nativeProps.selected = inst._wrapperState.selected;
        }
        var content = '';
        ReactChildren.forEach(props.children, function(child) {
          if (child == null) {
            return;
          }
          if (typeof child === 'string' || typeof child === 'number') {
            content += child;
          } else {
            process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : undefined;
          }
        });
        nativeProps.children = content;
        return nativeProps;
      }
    };
    module.exports = ReactDOMOption;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactDOMSelect", ["npm:react@0.14.6/lib/LinkedValueUtils", "npm:react@0.14.6/lib/ReactMount", "npm:react@0.14.6/lib/ReactUpdates", "npm:react@0.14.6/lib/Object.assign", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var LinkedValueUtils = $__require('npm:react@0.14.6/lib/LinkedValueUtils');
    var ReactMount = $__require('npm:react@0.14.6/lib/ReactMount');
    var ReactUpdates = $__require('npm:react@0.14.6/lib/ReactUpdates');
    var assign = $__require('npm:react@0.14.6/lib/Object.assign');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    var valueContextKey = '__ReactDOMSelect_value$' + Math.random().toString(36).slice(2);
    function updateOptionsIfPendingUpdateAndMounted() {
      if (this._rootNodeID && this._wrapperState.pendingUpdate) {
        this._wrapperState.pendingUpdate = false;
        var props = this._currentElement.props;
        var value = LinkedValueUtils.getValue(props);
        if (value != null) {
          updateOptions(this, Boolean(props.multiple), value);
        }
      }
    }
    function getDeclarationErrorAddendum(owner) {
      if (owner) {
        var name = owner.getName();
        if (name) {
          return ' Check the render method of `' + name + '`.';
        }
      }
      return '';
    }
    var valuePropNames = ['value', 'defaultValue'];
    function checkSelectPropTypes(inst, props) {
      var owner = inst._currentElement._owner;
      LinkedValueUtils.checkPropTypes('select', props, owner);
      for (var i = 0; i < valuePropNames.length; i++) {
        var propName = valuePropNames[i];
        if (props[propName] == null) {
          continue;
        }
        if (props.multiple) {
          process.env.NODE_ENV !== 'production' ? warning(Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
        } else {
          process.env.NODE_ENV !== 'production' ? warning(!Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
        }
      }
    }
    function updateOptions(inst, multiple, propValue) {
      var selectedValue,
          i;
      var options = ReactMount.getNode(inst._rootNodeID).options;
      if (multiple) {
        selectedValue = {};
        for (i = 0; i < propValue.length; i++) {
          selectedValue['' + propValue[i]] = true;
        }
        for (i = 0; i < options.length; i++) {
          var selected = selectedValue.hasOwnProperty(options[i].value);
          if (options[i].selected !== selected) {
            options[i].selected = selected;
          }
        }
      } else {
        selectedValue = '' + propValue;
        for (i = 0; i < options.length; i++) {
          if (options[i].value === selectedValue) {
            options[i].selected = true;
            return;
          }
        }
        if (options.length) {
          options[0].selected = true;
        }
      }
    }
    var ReactDOMSelect = {
      valueContextKey: valueContextKey,
      getNativeProps: function(inst, props, context) {
        return assign({}, props, {
          onChange: inst._wrapperState.onChange,
          value: undefined
        });
      },
      mountWrapper: function(inst, props) {
        if (process.env.NODE_ENV !== 'production') {
          checkSelectPropTypes(inst, props);
        }
        var value = LinkedValueUtils.getValue(props);
        inst._wrapperState = {
          pendingUpdate: false,
          initialValue: value != null ? value : props.defaultValue,
          onChange: _handleChange.bind(inst),
          wasMultiple: Boolean(props.multiple)
        };
      },
      processChildContext: function(inst, props, context) {
        var childContext = assign({}, context);
        childContext[valueContextKey] = inst._wrapperState.initialValue;
        return childContext;
      },
      postUpdateWrapper: function(inst) {
        var props = inst._currentElement.props;
        inst._wrapperState.initialValue = undefined;
        var wasMultiple = inst._wrapperState.wasMultiple;
        inst._wrapperState.wasMultiple = Boolean(props.multiple);
        var value = LinkedValueUtils.getValue(props);
        if (value != null) {
          inst._wrapperState.pendingUpdate = false;
          updateOptions(inst, Boolean(props.multiple), value);
        } else if (wasMultiple !== Boolean(props.multiple)) {
          if (props.defaultValue != null) {
            updateOptions(inst, Boolean(props.multiple), props.defaultValue);
          } else {
            updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
          }
        }
      }
    };
    function _handleChange(event) {
      var props = this._currentElement.props;
      var returnValue = LinkedValueUtils.executeOnChange(props, event);
      this._wrapperState.pendingUpdate = true;
      ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
      return returnValue;
    }
    module.exports = ReactDOMSelect;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactPropTypes", ["npm:react@0.14.6/lib/ReactElement", "npm:react@0.14.6/lib/ReactPropTypeLocationNames", "npm:fbjs@0.6.1/lib/emptyFunction", "npm:react@0.14.6/lib/getIteratorFn"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ReactElement = $__require('npm:react@0.14.6/lib/ReactElement');
  var ReactPropTypeLocationNames = $__require('npm:react@0.14.6/lib/ReactPropTypeLocationNames');
  var emptyFunction = $__require('npm:fbjs@0.6.1/lib/emptyFunction');
  var getIteratorFn = $__require('npm:react@0.14.6/lib/getIteratorFn');
  var ANONYMOUS = '<<anonymous>>';
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker
  };
  function createChainableTypeChecker(validate) {
    function checkType(isRequired, props, propName, componentName, location, propFullName) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;
      if (props[propName] == null) {
        var locationName = ReactPropTypeLocationNames[location];
        if (isRequired) {
          return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }
    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);
    return chainedCheckType;
  }
  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        var locationName = ReactPropTypeLocationNames[location];
        var preciseType = getPreciseType(propValue);
        return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturns(null));
  }
  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var locationName = ReactPropTypeLocationNames[location];
        var propType = getPropType(propValue);
        return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']');
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!ReactElement.isValidElement(props[propName])) {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var locationName = ReactPropTypeLocationNames[location];
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      return createChainableTypeChecker(function() {
        return new Error('Invalid argument supplied to oneOf, expected an instance of array.');
      });
    }
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (propValue === expectedValues[i]) {
          return null;
        }
      }
      var locationName = ReactPropTypeLocationNames[location];
      var valuesString = JSON.stringify(expectedValues);
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }
  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      return createChainableTypeChecker(function() {
        return new Error('Invalid argument supplied to oneOfType, expected an instance of array.');
      });
    }
    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName) == null) {
          return null;
        }
      }
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }
  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || ReactElement.isValidElement(propValue)) {
          return true;
        }
        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }
        return true;
      default:
        return false;
    }
  }
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      return 'object';
    }
    return propType;
  }
  function getPreciseType(propValue) {
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return '<<anonymous>>';
    }
    return propValue.constructor.name;
  }
  module.exports = ReactPropTypes;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/LinkedValueUtils", ["npm:react@0.14.6/lib/ReactPropTypes", "npm:react@0.14.6/lib/ReactPropTypeLocations", "npm:fbjs@0.6.1/lib/invariant", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactPropTypes = $__require('npm:react@0.14.6/lib/ReactPropTypes');
    var ReactPropTypeLocations = $__require('npm:react@0.14.6/lib/ReactPropTypeLocations');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    var hasReadOnlyValue = {
      'button': true,
      'checkbox': true,
      'image': true,
      'hidden': true,
      'radio': true,
      'reset': true,
      'submit': true
    };
    function _assertSingleLink(inputProps) {
      !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(false) : undefined;
    }
    function _assertValueLink(inputProps) {
      _assertSingleLink(inputProps);
      !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(false) : undefined;
    }
    function _assertCheckedLink(inputProps) {
      _assertSingleLink(inputProps);
      !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(false) : undefined;
    }
    var propTypes = {
      value: function(props, propName, componentName) {
        if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
          return null;
        }
        return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
      },
      checked: function(props, propName, componentName) {
        if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
          return null;
        }
        return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
      },
      onChange: ReactPropTypes.func
    };
    var loggedTypeFailures = {};
    function getDeclarationErrorAddendum(owner) {
      if (owner) {
        var name = owner.getName();
        if (name) {
          return ' Check the render method of `' + name + '`.';
        }
      }
      return '';
    }
    var LinkedValueUtils = {
      checkPropTypes: function(tagName, props, owner) {
        for (var propName in propTypes) {
          if (propTypes.hasOwnProperty(propName)) {
            var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop);
          }
          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            loggedTypeFailures[error.message] = true;
            var addendum = getDeclarationErrorAddendum(owner);
            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : undefined;
          }
        }
      },
      getValue: function(inputProps) {
        if (inputProps.valueLink) {
          _assertValueLink(inputProps);
          return inputProps.valueLink.value;
        }
        return inputProps.value;
      },
      getChecked: function(inputProps) {
        if (inputProps.checkedLink) {
          _assertCheckedLink(inputProps);
          return inputProps.checkedLink.value;
        }
        return inputProps.checked;
      },
      executeOnChange: function(inputProps, event) {
        if (inputProps.valueLink) {
          _assertValueLink(inputProps);
          return inputProps.valueLink.requestChange(event.target.value);
        } else if (inputProps.checkedLink) {
          _assertCheckedLink(inputProps);
          return inputProps.checkedLink.requestChange(event.target.checked);
        } else if (inputProps.onChange) {
          return inputProps.onChange.call(undefined, event);
        }
      }
    };
    module.exports = LinkedValueUtils;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactDOMTextarea", ["npm:react@0.14.6/lib/LinkedValueUtils", "npm:react@0.14.6/lib/ReactDOMIDOperations", "npm:react@0.14.6/lib/ReactUpdates", "npm:react@0.14.6/lib/Object.assign", "npm:fbjs@0.6.1/lib/invariant", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var LinkedValueUtils = $__require('npm:react@0.14.6/lib/LinkedValueUtils');
    var ReactDOMIDOperations = $__require('npm:react@0.14.6/lib/ReactDOMIDOperations');
    var ReactUpdates = $__require('npm:react@0.14.6/lib/ReactUpdates');
    var assign = $__require('npm:react@0.14.6/lib/Object.assign');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    function forceUpdateIfMounted() {
      if (this._rootNodeID) {
        ReactDOMTextarea.updateWrapper(this);
      }
    }
    var ReactDOMTextarea = {
      getNativeProps: function(inst, props, context) {
        !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(false) : undefined;
        var nativeProps = assign({}, props, {
          defaultValue: undefined,
          value: undefined,
          children: inst._wrapperState.initialValue,
          onChange: inst._wrapperState.onChange
        });
        return nativeProps;
      },
      mountWrapper: function(inst, props) {
        if (process.env.NODE_ENV !== 'production') {
          LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
        }
        var defaultValue = props.defaultValue;
        var children = props.children;
        if (children != null) {
          if (process.env.NODE_ENV !== 'production') {
            process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : undefined;
          }
          !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(false) : undefined;
          if (Array.isArray(children)) {
            !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : invariant(false) : undefined;
            children = children[0];
          }
          defaultValue = '' + children;
        }
        if (defaultValue == null) {
          defaultValue = '';
        }
        var value = LinkedValueUtils.getValue(props);
        inst._wrapperState = {
          initialValue: '' + (value != null ? value : defaultValue),
          onChange: _handleChange.bind(inst)
        };
      },
      updateWrapper: function(inst) {
        var props = inst._currentElement.props;
        var value = LinkedValueUtils.getValue(props);
        if (value != null) {
          ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
        }
      }
    };
    function _handleChange(event) {
      var props = this._currentElement.props;
      var returnValue = LinkedValueUtils.executeOnChange(props, event);
      ReactUpdates.asap(forceUpdateIfMounted, this);
      return returnValue;
    }
    module.exports = ReactDOMTextarea;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactChildReconciler", ["npm:react@0.14.6/lib/ReactReconciler", "npm:react@0.14.6/lib/instantiateReactComponent", "npm:react@0.14.6/lib/shouldUpdateReactComponent", "npm:react@0.14.6/lib/traverseAllChildren", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactReconciler = $__require('npm:react@0.14.6/lib/ReactReconciler');
    var instantiateReactComponent = $__require('npm:react@0.14.6/lib/instantiateReactComponent');
    var shouldUpdateReactComponent = $__require('npm:react@0.14.6/lib/shouldUpdateReactComponent');
    var traverseAllChildren = $__require('npm:react@0.14.6/lib/traverseAllChildren');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    function instantiateChild(childInstances, child, name) {
      var keyUnique = childInstances[name] === undefined;
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
      }
      if (child != null && keyUnique) {
        childInstances[name] = instantiateReactComponent(child, null);
      }
    }
    var ReactChildReconciler = {
      instantiateChildren: function(nestedChildNodes, transaction, context) {
        if (nestedChildNodes == null) {
          return null;
        }
        var childInstances = {};
        traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
        return childInstances;
      },
      updateChildren: function(prevChildren, nextChildren, transaction, context) {
        if (!nextChildren && !prevChildren) {
          return null;
        }
        var name;
        for (name in nextChildren) {
          if (!nextChildren.hasOwnProperty(name)) {
            continue;
          }
          var prevChild = prevChildren && prevChildren[name];
          var prevElement = prevChild && prevChild._currentElement;
          var nextElement = nextChildren[name];
          if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
            ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
            nextChildren[name] = prevChild;
          } else {
            if (prevChild) {
              ReactReconciler.unmountComponent(prevChild, name);
            }
            var nextChildInstance = instantiateReactComponent(nextElement, null);
            nextChildren[name] = nextChildInstance;
          }
        }
        for (name in prevChildren) {
          if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
            ReactReconciler.unmountComponent(prevChildren[name]);
          }
        }
        return nextChildren;
      },
      unmountChildren: function(renderedChildren) {
        for (var name in renderedChildren) {
          if (renderedChildren.hasOwnProperty(name)) {
            var renderedChild = renderedChildren[name];
            ReactReconciler.unmountComponent(renderedChild);
          }
        }
      }
    };
    module.exports = ReactChildReconciler;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/getIteratorFn", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator';
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }
  module.exports = getIteratorFn;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/traverseAllChildren", ["npm:react@0.14.6/lib/ReactCurrentOwner", "npm:react@0.14.6/lib/ReactElement", "npm:react@0.14.6/lib/ReactInstanceHandles", "npm:react@0.14.6/lib/getIteratorFn", "npm:fbjs@0.6.1/lib/invariant", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactCurrentOwner = $__require('npm:react@0.14.6/lib/ReactCurrentOwner');
    var ReactElement = $__require('npm:react@0.14.6/lib/ReactElement');
    var ReactInstanceHandles = $__require('npm:react@0.14.6/lib/ReactInstanceHandles');
    var getIteratorFn = $__require('npm:react@0.14.6/lib/getIteratorFn');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    var SEPARATOR = ReactInstanceHandles.SEPARATOR;
    var SUBSEPARATOR = ':';
    var userProvidedKeyEscaperLookup = {
      '=': '=0',
      '.': '=1',
      ':': '=2'
    };
    var userProvidedKeyEscapeRegex = /[=.:]/g;
    var didWarnAboutMaps = false;
    function userProvidedKeyEscaper(match) {
      return userProvidedKeyEscaperLookup[match];
    }
    function getComponentKey(component, index) {
      if (component && component.key != null) {
        return wrapUserProvidedKey(component.key);
      }
      return index.toString(36);
    }
    function escapeUserProvidedKey(text) {
      return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
    }
    function wrapUserProvidedKey(key) {
      return '$' + escapeUserProvidedKey(key);
    }
    function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
      var type = typeof children;
      if (type === 'undefined' || type === 'boolean') {
        children = null;
      }
      if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
        callback(traverseContext, children, nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
        return 1;
      }
      var child;
      var nextName;
      var subtreeCount = 0;
      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          child = children[i];
          nextName = nextNamePrefix + getComponentKey(child, i);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        var iteratorFn = getIteratorFn(children);
        if (iteratorFn) {
          var iterator = iteratorFn.call(children);
          var step;
          if (iteratorFn !== children.entries) {
            var ii = 0;
            while (!(step = iterator.next()).done) {
              child = step.value;
              nextName = nextNamePrefix + getComponentKey(child, ii++);
              subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
            }
          } else {
            if (process.env.NODE_ENV !== 'production') {
              process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : undefined;
              didWarnAboutMaps = true;
            }
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                child = entry[1];
                nextName = nextNamePrefix + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
                subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
              }
            }
          }
        } else if (type === 'object') {
          var addendum = '';
          if (process.env.NODE_ENV !== 'production') {
            addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
            if (children._isReactElement) {
              addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
            }
            if (ReactCurrentOwner.current) {
              var name = ReactCurrentOwner.current.getName();
              if (name) {
                addendum += ' Check the render method of `' + name + '`.';
              }
            }
          }
          var childrenString = String(children);
          !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : invariant(false) : undefined;
        }
      }
      return subtreeCount;
    }
    function traverseAllChildren(children, callback, traverseContext) {
      if (children == null) {
        return 0;
      }
      return traverseAllChildrenImpl(children, '', callback, traverseContext);
    }
    module.exports = traverseAllChildren;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/flattenChildren", ["npm:react@0.14.6/lib/traverseAllChildren", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var traverseAllChildren = $__require('npm:react@0.14.6/lib/traverseAllChildren');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    function flattenSingleChildIntoContext(traverseContext, child, name) {
      var result = traverseContext;
      var keyUnique = result[name] === undefined;
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
      }
      if (keyUnique && child != null) {
        result[name] = child;
      }
    }
    function flattenChildren(children) {
      if (children == null) {
        return children;
      }
      var result = {};
      traverseAllChildren(children, flattenSingleChildIntoContext, result);
      return result;
    }
    module.exports = flattenChildren;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactMultiChild", ["npm:react@0.14.6/lib/ReactComponentEnvironment", "npm:react@0.14.6/lib/ReactMultiChildUpdateTypes", "npm:react@0.14.6/lib/ReactCurrentOwner", "npm:react@0.14.6/lib/ReactReconciler", "npm:react@0.14.6/lib/ReactChildReconciler", "npm:react@0.14.6/lib/flattenChildren", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactComponentEnvironment = $__require('npm:react@0.14.6/lib/ReactComponentEnvironment');
    var ReactMultiChildUpdateTypes = $__require('npm:react@0.14.6/lib/ReactMultiChildUpdateTypes');
    var ReactCurrentOwner = $__require('npm:react@0.14.6/lib/ReactCurrentOwner');
    var ReactReconciler = $__require('npm:react@0.14.6/lib/ReactReconciler');
    var ReactChildReconciler = $__require('npm:react@0.14.6/lib/ReactChildReconciler');
    var flattenChildren = $__require('npm:react@0.14.6/lib/flattenChildren');
    var updateDepth = 0;
    var updateQueue = [];
    var markupQueue = [];
    function enqueueInsertMarkup(parentID, markup, toIndex) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
        markupIndex: markupQueue.push(markup) - 1,
        content: null,
        fromIndex: null,
        toIndex: toIndex
      });
    }
    function enqueueMove(parentID, fromIndex, toIndex) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
        markupIndex: null,
        content: null,
        fromIndex: fromIndex,
        toIndex: toIndex
      });
    }
    function enqueueRemove(parentID, fromIndex) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.REMOVE_NODE,
        markupIndex: null,
        content: null,
        fromIndex: fromIndex,
        toIndex: null
      });
    }
    function enqueueSetMarkup(parentID, markup) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.SET_MARKUP,
        markupIndex: null,
        content: markup,
        fromIndex: null,
        toIndex: null
      });
    }
    function enqueueTextContent(parentID, textContent) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
        markupIndex: null,
        content: textContent,
        fromIndex: null,
        toIndex: null
      });
    }
    function processQueue() {
      if (updateQueue.length) {
        ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue);
        clearQueue();
      }
    }
    function clearQueue() {
      updateQueue.length = 0;
      markupQueue.length = 0;
    }
    var ReactMultiChild = {Mixin: {
        _reconcilerInstantiateChildren: function(nestedChildren, transaction, context) {
          if (process.env.NODE_ENV !== 'production') {
            if (this._currentElement) {
              try {
                ReactCurrentOwner.current = this._currentElement._owner;
                return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
              } finally {
                ReactCurrentOwner.current = null;
              }
            }
          }
          return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
        },
        _reconcilerUpdateChildren: function(prevChildren, nextNestedChildrenElements, transaction, context) {
          var nextChildren;
          if (process.env.NODE_ENV !== 'production') {
            if (this._currentElement) {
              try {
                ReactCurrentOwner.current = this._currentElement._owner;
                nextChildren = flattenChildren(nextNestedChildrenElements);
              } finally {
                ReactCurrentOwner.current = null;
              }
              return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
            }
          }
          nextChildren = flattenChildren(nextNestedChildrenElements);
          return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
        },
        mountChildren: function(nestedChildren, transaction, context) {
          var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
          this._renderedChildren = children;
          var mountImages = [];
          var index = 0;
          for (var name in children) {
            if (children.hasOwnProperty(name)) {
              var child = children[name];
              var rootID = this._rootNodeID + name;
              var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
              child._mountIndex = index++;
              mountImages.push(mountImage);
            }
          }
          return mountImages;
        },
        updateTextContent: function(nextContent) {
          updateDepth++;
          var errorThrown = true;
          try {
            var prevChildren = this._renderedChildren;
            ReactChildReconciler.unmountChildren(prevChildren);
            for (var name in prevChildren) {
              if (prevChildren.hasOwnProperty(name)) {
                this._unmountChild(prevChildren[name]);
              }
            }
            this.setTextContent(nextContent);
            errorThrown = false;
          } finally {
            updateDepth--;
            if (!updateDepth) {
              if (errorThrown) {
                clearQueue();
              } else {
                processQueue();
              }
            }
          }
        },
        updateMarkup: function(nextMarkup) {
          updateDepth++;
          var errorThrown = true;
          try {
            var prevChildren = this._renderedChildren;
            ReactChildReconciler.unmountChildren(prevChildren);
            for (var name in prevChildren) {
              if (prevChildren.hasOwnProperty(name)) {
                this._unmountChildByName(prevChildren[name], name);
              }
            }
            this.setMarkup(nextMarkup);
            errorThrown = false;
          } finally {
            updateDepth--;
            if (!updateDepth) {
              if (errorThrown) {
                clearQueue();
              } else {
                processQueue();
              }
            }
          }
        },
        updateChildren: function(nextNestedChildrenElements, transaction, context) {
          updateDepth++;
          var errorThrown = true;
          try {
            this._updateChildren(nextNestedChildrenElements, transaction, context);
            errorThrown = false;
          } finally {
            updateDepth--;
            if (!updateDepth) {
              if (errorThrown) {
                clearQueue();
              } else {
                processQueue();
              }
            }
          }
        },
        _updateChildren: function(nextNestedChildrenElements, transaction, context) {
          var prevChildren = this._renderedChildren;
          var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context);
          this._renderedChildren = nextChildren;
          if (!nextChildren && !prevChildren) {
            return;
          }
          var name;
          var lastIndex = 0;
          var nextIndex = 0;
          for (name in nextChildren) {
            if (!nextChildren.hasOwnProperty(name)) {
              continue;
            }
            var prevChild = prevChildren && prevChildren[name];
            var nextChild = nextChildren[name];
            if (prevChild === nextChild) {
              this.moveChild(prevChild, nextIndex, lastIndex);
              lastIndex = Math.max(prevChild._mountIndex, lastIndex);
              prevChild._mountIndex = nextIndex;
            } else {
              if (prevChild) {
                lastIndex = Math.max(prevChild._mountIndex, lastIndex);
                this._unmountChild(prevChild);
              }
              this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context);
            }
            nextIndex++;
          }
          for (name in prevChildren) {
            if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
              this._unmountChild(prevChildren[name]);
            }
          }
        },
        unmountChildren: function() {
          var renderedChildren = this._renderedChildren;
          ReactChildReconciler.unmountChildren(renderedChildren);
          this._renderedChildren = null;
        },
        moveChild: function(child, toIndex, lastIndex) {
          if (child._mountIndex < lastIndex) {
            enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
          }
        },
        createChild: function(child, mountImage) {
          enqueueInsertMarkup(this._rootNodeID, mountImage, child._mountIndex);
        },
        removeChild: function(child) {
          enqueueRemove(this._rootNodeID, child._mountIndex);
        },
        setTextContent: function(textContent) {
          enqueueTextContent(this._rootNodeID, textContent);
        },
        setMarkup: function(markup) {
          enqueueSetMarkup(this._rootNodeID, markup);
        },
        _mountChildByNameAtIndex: function(child, name, index, transaction, context) {
          var rootID = this._rootNodeID + name;
          var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
          child._mountIndex = index;
          this.createChild(child, mountImage);
        },
        _unmountChild: function(child) {
          this.removeChild(child);
          child._mountIndex = null;
        }
      }};
    module.exports = ReactMultiChild;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactDOMComponent", ["npm:react@0.14.6/lib/AutoFocusUtils", "npm:react@0.14.6/lib/CSSPropertyOperations", "npm:react@0.14.6/lib/DOMProperty", "npm:react@0.14.6/lib/DOMPropertyOperations", "npm:react@0.14.6/lib/EventConstants", "npm:react@0.14.6/lib/ReactBrowserEventEmitter", "npm:react@0.14.6/lib/ReactComponentBrowserEnvironment", "npm:react@0.14.6/lib/ReactDOMButton", "npm:react@0.14.6/lib/ReactDOMInput", "npm:react@0.14.6/lib/ReactDOMOption", "npm:react@0.14.6/lib/ReactDOMSelect", "npm:react@0.14.6/lib/ReactDOMTextarea", "npm:react@0.14.6/lib/ReactMount", "npm:react@0.14.6/lib/ReactMultiChild", "npm:react@0.14.6/lib/ReactPerf", "npm:react@0.14.6/lib/ReactUpdateQueue", "npm:react@0.14.6/lib/Object.assign", "npm:react@0.14.6/lib/canDefineProperty", "npm:react@0.14.6/lib/escapeTextContentForBrowser", "npm:fbjs@0.6.1/lib/invariant", "npm:react@0.14.6/lib/isEventSupported", "npm:fbjs@0.6.1/lib/keyOf", "npm:react@0.14.6/lib/setInnerHTML", "npm:react@0.14.6/lib/setTextContent", "npm:fbjs@0.6.1/lib/shallowEqual", "npm:react@0.14.6/lib/validateDOMNesting", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var AutoFocusUtils = $__require('npm:react@0.14.6/lib/AutoFocusUtils');
    var CSSPropertyOperations = $__require('npm:react@0.14.6/lib/CSSPropertyOperations');
    var DOMProperty = $__require('npm:react@0.14.6/lib/DOMProperty');
    var DOMPropertyOperations = $__require('npm:react@0.14.6/lib/DOMPropertyOperations');
    var EventConstants = $__require('npm:react@0.14.6/lib/EventConstants');
    var ReactBrowserEventEmitter = $__require('npm:react@0.14.6/lib/ReactBrowserEventEmitter');
    var ReactComponentBrowserEnvironment = $__require('npm:react@0.14.6/lib/ReactComponentBrowserEnvironment');
    var ReactDOMButton = $__require('npm:react@0.14.6/lib/ReactDOMButton');
    var ReactDOMInput = $__require('npm:react@0.14.6/lib/ReactDOMInput');
    var ReactDOMOption = $__require('npm:react@0.14.6/lib/ReactDOMOption');
    var ReactDOMSelect = $__require('npm:react@0.14.6/lib/ReactDOMSelect');
    var ReactDOMTextarea = $__require('npm:react@0.14.6/lib/ReactDOMTextarea');
    var ReactMount = $__require('npm:react@0.14.6/lib/ReactMount');
    var ReactMultiChild = $__require('npm:react@0.14.6/lib/ReactMultiChild');
    var ReactPerf = $__require('npm:react@0.14.6/lib/ReactPerf');
    var ReactUpdateQueue = $__require('npm:react@0.14.6/lib/ReactUpdateQueue');
    var assign = $__require('npm:react@0.14.6/lib/Object.assign');
    var canDefineProperty = $__require('npm:react@0.14.6/lib/canDefineProperty');
    var escapeTextContentForBrowser = $__require('npm:react@0.14.6/lib/escapeTextContentForBrowser');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var isEventSupported = $__require('npm:react@0.14.6/lib/isEventSupported');
    var keyOf = $__require('npm:fbjs@0.6.1/lib/keyOf');
    var setInnerHTML = $__require('npm:react@0.14.6/lib/setInnerHTML');
    var setTextContent = $__require('npm:react@0.14.6/lib/setTextContent');
    var shallowEqual = $__require('npm:fbjs@0.6.1/lib/shallowEqual');
    var validateDOMNesting = $__require('npm:react@0.14.6/lib/validateDOMNesting');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    var deleteListener = ReactBrowserEventEmitter.deleteListener;
    var listenTo = ReactBrowserEventEmitter.listenTo;
    var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;
    var CONTENT_TYPES = {
      'string': true,
      'number': true
    };
    var CHILDREN = keyOf({children: null});
    var STYLE = keyOf({style: null});
    var HTML = keyOf({__html: null});
    var ELEMENT_NODE_TYPE = 1;
    function getDeclarationErrorAddendum(internalInstance) {
      if (internalInstance) {
        var owner = internalInstance._currentElement._owner || null;
        if (owner) {
          var name = owner.getName();
          if (name) {
            return ' This DOM node was rendered by `' + name + '`.';
          }
        }
      }
      return '';
    }
    var legacyPropsDescriptor;
    if (process.env.NODE_ENV !== 'production') {
      legacyPropsDescriptor = {props: {
          enumerable: false,
          get: function() {
            var component = this._reactInternalComponent;
            process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .props of a DOM node; instead, ' + 'recreate the props as `render` did originally or read the DOM ' + 'properties/attributes directly from this node (e.g., ' + 'this.refs.box.className).%s', getDeclarationErrorAddendum(component)) : undefined;
            return component._currentElement.props;
          }
        }};
    }
    function legacyGetDOMNode() {
      if (process.env.NODE_ENV !== 'production') {
        var component = this._reactInternalComponent;
        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .getDOMNode() of a DOM node; ' + 'instead, use the node directly.%s', getDeclarationErrorAddendum(component)) : undefined;
      }
      return this;
    }
    function legacyIsMounted() {
      var component = this._reactInternalComponent;
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .isMounted() of a DOM node.%s', getDeclarationErrorAddendum(component)) : undefined;
      }
      return !!component;
    }
    function legacySetStateEtc() {
      if (process.env.NODE_ENV !== 'production') {
        var component = this._reactInternalComponent;
        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setState(), .replaceState(), or ' + '.forceUpdate() of a DOM node. This is a no-op.%s', getDeclarationErrorAddendum(component)) : undefined;
      }
    }
    function legacySetProps(partialProps, callback) {
      var component = this._reactInternalComponent;
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
      }
      if (!component) {
        return;
      }
      ReactUpdateQueue.enqueueSetPropsInternal(component, partialProps);
      if (callback) {
        ReactUpdateQueue.enqueueCallbackInternal(component, callback);
      }
    }
    function legacyReplaceProps(partialProps, callback) {
      var component = this._reactInternalComponent;
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .replaceProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
      }
      if (!component) {
        return;
      }
      ReactUpdateQueue.enqueueReplacePropsInternal(component, partialProps);
      if (callback) {
        ReactUpdateQueue.enqueueCallbackInternal(component, callback);
      }
    }
    function friendlyStringify(obj) {
      if (typeof obj === 'object') {
        if (Array.isArray(obj)) {
          return '[' + obj.map(friendlyStringify).join(', ') + ']';
        } else {
          var pairs = [];
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
              pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
            }
          }
          return '{' + pairs.join(', ') + '}';
        }
      } else if (typeof obj === 'string') {
        return JSON.stringify(obj);
      } else if (typeof obj === 'function') {
        return '[function object]';
      }
      return String(obj);
    }
    var styleMutationWarning = {};
    function checkAndWarnForMutatedStyle(style1, style2, component) {
      if (style1 == null || style2 == null) {
        return;
      }
      if (shallowEqual(style1, style2)) {
        return;
      }
      var componentName = component._tag;
      var owner = component._currentElement._owner;
      var ownerName;
      if (owner) {
        ownerName = owner.getName();
      }
      var hash = ownerName + '|' + componentName;
      if (styleMutationWarning.hasOwnProperty(hash)) {
        return;
      }
      styleMutationWarning[hash] = true;
      process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : undefined;
    }
    function assertValidProps(component, props) {
      if (!props) {
        return;
      }
      if (process.env.NODE_ENV !== 'production') {
        if (voidElementTags[component._tag]) {
          process.env.NODE_ENV !== 'production' ? warning(props.children == null && props.dangerouslySetInnerHTML == null, '%s is a void element tag and must not have `children` or ' + 'use `props.dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : undefined;
        }
      }
      if (props.dangerouslySetInnerHTML != null) {
        !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(false) : undefined;
        !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.') : invariant(false) : undefined;
      }
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : undefined;
        process.env.NODE_ENV !== 'production' ? warning(!props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : undefined;
      }
      !(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, ' + 'not a string. For example, style={{marginRight: spacing + \'em\'}} when ' + 'using JSX.%s', getDeclarationErrorAddendum(component)) : invariant(false) : undefined;
    }
    function enqueuePutListener(id, registrationName, listener, transaction) {
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : undefined;
      }
      var container = ReactMount.findReactContainerForID(id);
      if (container) {
        var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
        listenTo(registrationName, doc);
      }
      transaction.getReactMountReady().enqueue(putListener, {
        id: id,
        registrationName: registrationName,
        listener: listener
      });
    }
    function putListener() {
      var listenerToPut = this;
      ReactBrowserEventEmitter.putListener(listenerToPut.id, listenerToPut.registrationName, listenerToPut.listener);
    }
    var mediaEvents = {
      topAbort: 'abort',
      topCanPlay: 'canplay',
      topCanPlayThrough: 'canplaythrough',
      topDurationChange: 'durationchange',
      topEmptied: 'emptied',
      topEncrypted: 'encrypted',
      topEnded: 'ended',
      topError: 'error',
      topLoadedData: 'loadeddata',
      topLoadedMetadata: 'loadedmetadata',
      topLoadStart: 'loadstart',
      topPause: 'pause',
      topPlay: 'play',
      topPlaying: 'playing',
      topProgress: 'progress',
      topRateChange: 'ratechange',
      topSeeked: 'seeked',
      topSeeking: 'seeking',
      topStalled: 'stalled',
      topSuspend: 'suspend',
      topTimeUpdate: 'timeupdate',
      topVolumeChange: 'volumechange',
      topWaiting: 'waiting'
    };
    function trapBubbledEventsLocal() {
      var inst = this;
      !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : invariant(false) : undefined;
      var node = ReactMount.getNode(inst._rootNodeID);
      !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : invariant(false) : undefined;
      switch (inst._tag) {
        case 'iframe':
          inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
          break;
        case 'video':
        case 'audio':
          inst._wrapperState.listeners = [];
          for (var event in mediaEvents) {
            if (mediaEvents.hasOwnProperty(event)) {
              inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
            }
          }
          break;
        case 'img':
          inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
          break;
        case 'form':
          inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
          break;
      }
    }
    function mountReadyInputWrapper() {
      ReactDOMInput.mountReadyWrapper(this);
    }
    function postUpdateSelectWrapper() {
      ReactDOMSelect.postUpdateWrapper(this);
    }
    var omittedCloseTags = {
      'area': true,
      'base': true,
      'br': true,
      'col': true,
      'embed': true,
      'hr': true,
      'img': true,
      'input': true,
      'keygen': true,
      'link': true,
      'meta': true,
      'param': true,
      'source': true,
      'track': true,
      'wbr': true
    };
    var newlineEatingTags = {
      'listing': true,
      'pre': true,
      'textarea': true
    };
    var voidElementTags = assign({'menuitem': true}, omittedCloseTags);
    var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
    var validatedTagCache = {};
    var hasOwnProperty = ({}).hasOwnProperty;
    function validateDangerousTag(tag) {
      if (!hasOwnProperty.call(validatedTagCache, tag)) {
        !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : invariant(false) : undefined;
        validatedTagCache[tag] = true;
      }
    }
    function processChildContextDev(context, inst) {
      context = assign({}, context);
      var info = context[validateDOMNesting.ancestorInfoContextKey];
      context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(info, inst._tag, inst);
      return context;
    }
    function isCustomComponent(tagName, props) {
      return tagName.indexOf('-') >= 0 || props.is != null;
    }
    function ReactDOMComponent(tag) {
      validateDangerousTag(tag);
      this._tag = tag.toLowerCase();
      this._renderedChildren = null;
      this._previousStyle = null;
      this._previousStyleCopy = null;
      this._rootNodeID = null;
      this._wrapperState = null;
      this._topLevelWrapper = null;
      this._nodeWithLegacyProperties = null;
      if (process.env.NODE_ENV !== 'production') {
        this._unprocessedContextDev = null;
        this._processedContextDev = null;
      }
    }
    ReactDOMComponent.displayName = 'ReactDOMComponent';
    ReactDOMComponent.Mixin = {
      construct: function(element) {
        this._currentElement = element;
      },
      mountComponent: function(rootID, transaction, context) {
        this._rootNodeID = rootID;
        var props = this._currentElement.props;
        switch (this._tag) {
          case 'iframe':
          case 'img':
          case 'form':
          case 'video':
          case 'audio':
            this._wrapperState = {listeners: null};
            transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
            break;
          case 'button':
            props = ReactDOMButton.getNativeProps(this, props, context);
            break;
          case 'input':
            ReactDOMInput.mountWrapper(this, props, context);
            props = ReactDOMInput.getNativeProps(this, props, context);
            break;
          case 'option':
            ReactDOMOption.mountWrapper(this, props, context);
            props = ReactDOMOption.getNativeProps(this, props, context);
            break;
          case 'select':
            ReactDOMSelect.mountWrapper(this, props, context);
            props = ReactDOMSelect.getNativeProps(this, props, context);
            context = ReactDOMSelect.processChildContext(this, props, context);
            break;
          case 'textarea':
            ReactDOMTextarea.mountWrapper(this, props, context);
            props = ReactDOMTextarea.getNativeProps(this, props, context);
            break;
        }
        assertValidProps(this, props);
        if (process.env.NODE_ENV !== 'production') {
          if (context[validateDOMNesting.ancestorInfoContextKey]) {
            validateDOMNesting(this._tag, this, context[validateDOMNesting.ancestorInfoContextKey]);
          }
        }
        if (process.env.NODE_ENV !== 'production') {
          this._unprocessedContextDev = context;
          this._processedContextDev = processChildContextDev(context, this);
          context = this._processedContextDev;
        }
        var mountImage;
        if (transaction.useCreateElement) {
          var ownerDocument = context[ReactMount.ownerDocumentContextKey];
          var el = ownerDocument.createElement(this._currentElement.type);
          DOMPropertyOperations.setAttributeForID(el, this._rootNodeID);
          ReactMount.getID(el);
          this._updateDOMProperties({}, props, transaction, el);
          this._createInitialChildren(transaction, props, context, el);
          mountImage = el;
        } else {
          var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
          var tagContent = this._createContentMarkup(transaction, props, context);
          if (!tagContent && omittedCloseTags[this._tag]) {
            mountImage = tagOpen + '/>';
          } else {
            mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
          }
        }
        switch (this._tag) {
          case 'input':
            transaction.getReactMountReady().enqueue(mountReadyInputWrapper, this);
          case 'button':
          case 'select':
          case 'textarea':
            if (props.autoFocus) {
              transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
            }
            break;
        }
        return mountImage;
      },
      _createOpenTagMarkupAndPutListeners: function(transaction, props) {
        var ret = '<' + this._currentElement.type;
        for (var propKey in props) {
          if (!props.hasOwnProperty(propKey)) {
            continue;
          }
          var propValue = props[propKey];
          if (propValue == null) {
            continue;
          }
          if (registrationNameModules.hasOwnProperty(propKey)) {
            if (propValue) {
              enqueuePutListener(this._rootNodeID, propKey, propValue, transaction);
            }
          } else {
            if (propKey === STYLE) {
              if (propValue) {
                if (process.env.NODE_ENV !== 'production') {
                  this._previousStyle = propValue;
                }
                propValue = this._previousStyleCopy = assign({}, props.style);
              }
              propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
            }
            var markup = null;
            if (this._tag != null && isCustomComponent(this._tag, props)) {
              if (propKey !== CHILDREN) {
                markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
              }
            } else {
              markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
            }
            if (markup) {
              ret += ' ' + markup;
            }
          }
        }
        if (transaction.renderToStaticMarkup) {
          return ret;
        }
        var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
        return ret + ' ' + markupForID;
      },
      _createContentMarkup: function(transaction, props, context) {
        var ret = '';
        var innerHTML = props.dangerouslySetInnerHTML;
        if (innerHTML != null) {
          if (innerHTML.__html != null) {
            ret = innerHTML.__html;
          }
        } else {
          var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
          var childrenToUse = contentToUse != null ? null : props.children;
          if (contentToUse != null) {
            ret = escapeTextContentForBrowser(contentToUse);
          } else if (childrenToUse != null) {
            var mountImages = this.mountChildren(childrenToUse, transaction, context);
            ret = mountImages.join('');
          }
        }
        if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
          return '\n' + ret;
        } else {
          return ret;
        }
      },
      _createInitialChildren: function(transaction, props, context, el) {
        var innerHTML = props.dangerouslySetInnerHTML;
        if (innerHTML != null) {
          if (innerHTML.__html != null) {
            setInnerHTML(el, innerHTML.__html);
          }
        } else {
          var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
          var childrenToUse = contentToUse != null ? null : props.children;
          if (contentToUse != null) {
            setTextContent(el, contentToUse);
          } else if (childrenToUse != null) {
            var mountImages = this.mountChildren(childrenToUse, transaction, context);
            for (var i = 0; i < mountImages.length; i++) {
              el.appendChild(mountImages[i]);
            }
          }
        }
      },
      receiveComponent: function(nextElement, transaction, context) {
        var prevElement = this._currentElement;
        this._currentElement = nextElement;
        this.updateComponent(transaction, prevElement, nextElement, context);
      },
      updateComponent: function(transaction, prevElement, nextElement, context) {
        var lastProps = prevElement.props;
        var nextProps = this._currentElement.props;
        switch (this._tag) {
          case 'button':
            lastProps = ReactDOMButton.getNativeProps(this, lastProps);
            nextProps = ReactDOMButton.getNativeProps(this, nextProps);
            break;
          case 'input':
            ReactDOMInput.updateWrapper(this);
            lastProps = ReactDOMInput.getNativeProps(this, lastProps);
            nextProps = ReactDOMInput.getNativeProps(this, nextProps);
            break;
          case 'option':
            lastProps = ReactDOMOption.getNativeProps(this, lastProps);
            nextProps = ReactDOMOption.getNativeProps(this, nextProps);
            break;
          case 'select':
            lastProps = ReactDOMSelect.getNativeProps(this, lastProps);
            nextProps = ReactDOMSelect.getNativeProps(this, nextProps);
            break;
          case 'textarea':
            ReactDOMTextarea.updateWrapper(this);
            lastProps = ReactDOMTextarea.getNativeProps(this, lastProps);
            nextProps = ReactDOMTextarea.getNativeProps(this, nextProps);
            break;
        }
        if (process.env.NODE_ENV !== 'production') {
          if (this._unprocessedContextDev !== context) {
            this._unprocessedContextDev = context;
            this._processedContextDev = processChildContextDev(context, this);
          }
          context = this._processedContextDev;
        }
        assertValidProps(this, nextProps);
        this._updateDOMProperties(lastProps, nextProps, transaction, null);
        this._updateDOMChildren(lastProps, nextProps, transaction, context);
        if (!canDefineProperty && this._nodeWithLegacyProperties) {
          this._nodeWithLegacyProperties.props = nextProps;
        }
        if (this._tag === 'select') {
          transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
        }
      },
      _updateDOMProperties: function(lastProps, nextProps, transaction, node) {
        var propKey;
        var styleName;
        var styleUpdates;
        for (propKey in lastProps) {
          if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
            continue;
          }
          if (propKey === STYLE) {
            var lastStyle = this._previousStyleCopy;
            for (styleName in lastStyle) {
              if (lastStyle.hasOwnProperty(styleName)) {
                styleUpdates = styleUpdates || {};
                styleUpdates[styleName] = '';
              }
            }
            this._previousStyleCopy = null;
          } else if (registrationNameModules.hasOwnProperty(propKey)) {
            if (lastProps[propKey]) {
              deleteListener(this._rootNodeID, propKey);
            }
          } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
            if (!node) {
              node = ReactMount.getNode(this._rootNodeID);
            }
            DOMPropertyOperations.deleteValueForProperty(node, propKey);
          }
        }
        for (propKey in nextProps) {
          var nextProp = nextProps[propKey];
          var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
          if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
            continue;
          }
          if (propKey === STYLE) {
            if (nextProp) {
              if (process.env.NODE_ENV !== 'production') {
                checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
                this._previousStyle = nextProp;
              }
              nextProp = this._previousStyleCopy = assign({}, nextProp);
            } else {
              this._previousStyleCopy = null;
            }
            if (lastProp) {
              for (styleName in lastProp) {
                if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                  styleUpdates = styleUpdates || {};
                  styleUpdates[styleName] = '';
                }
              }
              for (styleName in nextProp) {
                if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                  styleUpdates = styleUpdates || {};
                  styleUpdates[styleName] = nextProp[styleName];
                }
              }
            } else {
              styleUpdates = nextProp;
            }
          } else if (registrationNameModules.hasOwnProperty(propKey)) {
            if (nextProp) {
              enqueuePutListener(this._rootNodeID, propKey, nextProp, transaction);
            } else if (lastProp) {
              deleteListener(this._rootNodeID, propKey);
            }
          } else if (isCustomComponent(this._tag, nextProps)) {
            if (!node) {
              node = ReactMount.getNode(this._rootNodeID);
            }
            if (propKey === CHILDREN) {
              nextProp = null;
            }
            DOMPropertyOperations.setValueForAttribute(node, propKey, nextProp);
          } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
            if (!node) {
              node = ReactMount.getNode(this._rootNodeID);
            }
            if (nextProp != null) {
              DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
            } else {
              DOMPropertyOperations.deleteValueForProperty(node, propKey);
            }
          }
        }
        if (styleUpdates) {
          if (!node) {
            node = ReactMount.getNode(this._rootNodeID);
          }
          CSSPropertyOperations.setValueForStyles(node, styleUpdates);
        }
      },
      _updateDOMChildren: function(lastProps, nextProps, transaction, context) {
        var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
        var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
        var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
        var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
        var lastChildren = lastContent != null ? null : lastProps.children;
        var nextChildren = nextContent != null ? null : nextProps.children;
        var lastHasContentOrHtml = lastContent != null || lastHtml != null;
        var nextHasContentOrHtml = nextContent != null || nextHtml != null;
        if (lastChildren != null && nextChildren == null) {
          this.updateChildren(null, transaction, context);
        } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
          this.updateTextContent('');
        }
        if (nextContent != null) {
          if (lastContent !== nextContent) {
            this.updateTextContent('' + nextContent);
          }
        } else if (nextHtml != null) {
          if (lastHtml !== nextHtml) {
            this.updateMarkup('' + nextHtml);
          }
        } else if (nextChildren != null) {
          this.updateChildren(nextChildren, transaction, context);
        }
      },
      unmountComponent: function() {
        switch (this._tag) {
          case 'iframe':
          case 'img':
          case 'form':
          case 'video':
          case 'audio':
            var listeners = this._wrapperState.listeners;
            if (listeners) {
              for (var i = 0; i < listeners.length; i++) {
                listeners[i].remove();
              }
            }
            break;
          case 'input':
            ReactDOMInput.unmountWrapper(this);
            break;
          case 'html':
          case 'head':
          case 'body':
            !false ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, ' + '<head>, and <body>) reliably and efficiently. To fix this, have a ' + 'single top-level component that never unmounts render these ' + 'elements.', this._tag) : invariant(false) : undefined;
            break;
        }
        this.unmountChildren();
        ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
        ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
        this._rootNodeID = null;
        this._wrapperState = null;
        if (this._nodeWithLegacyProperties) {
          var node = this._nodeWithLegacyProperties;
          node._reactInternalComponent = null;
          this._nodeWithLegacyProperties = null;
        }
      },
      getPublicInstance: function() {
        if (!this._nodeWithLegacyProperties) {
          var node = ReactMount.getNode(this._rootNodeID);
          node._reactInternalComponent = this;
          node.getDOMNode = legacyGetDOMNode;
          node.isMounted = legacyIsMounted;
          node.setState = legacySetStateEtc;
          node.replaceState = legacySetStateEtc;
          node.forceUpdate = legacySetStateEtc;
          node.setProps = legacySetProps;
          node.replaceProps = legacyReplaceProps;
          if (process.env.NODE_ENV !== 'production') {
            if (canDefineProperty) {
              Object.defineProperties(node, legacyPropsDescriptor);
            } else {
              node.props = this._currentElement.props;
            }
          } else {
            node.props = this._currentElement.props;
          }
          this._nodeWithLegacyProperties = node;
        }
        return this._nodeWithLegacyProperties;
      }
    };
    ReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {
      mountComponent: 'mountComponent',
      updateComponent: 'updateComponent'
    });
    assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
    module.exports = ReactDOMComponent;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/toArray", ["npm:fbjs@0.6.1/lib/invariant", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    function toArray(obj) {
      var length = obj.length;
      !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : undefined;
      !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : undefined;
      !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : undefined;
      if (obj.hasOwnProperty) {
        try {
          return Array.prototype.slice.call(obj);
        } catch (e) {}
      }
      var ret = Array(length);
      for (var ii = 0; ii < length; ii++) {
        ret[ii] = obj[ii];
      }
      return ret;
    }
    module.exports = toArray;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/createArrayFromMixed", ["npm:fbjs@0.6.1/lib/toArray"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toArray = $__require('npm:fbjs@0.6.1/lib/toArray');
  function hasArrayNature(obj) {
    return (!!obj && (typeof obj == 'object' || typeof obj == 'function') && 'length' in obj && !('setInterval' in obj) && typeof obj.nodeType != 'number' && (Array.isArray(obj) || 'callee' in obj || 'item' in obj));
  }
  function createArrayFromMixed(obj) {
    if (!hasArrayNature(obj)) {
      return [obj];
    } else if (Array.isArray(obj)) {
      return obj.slice();
    } else {
      return toArray(obj);
    }
  }
  module.exports = createArrayFromMixed;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/createNodesFromMarkup", ["npm:fbjs@0.6.1/lib/ExecutionEnvironment", "npm:fbjs@0.6.1/lib/createArrayFromMixed", "npm:fbjs@0.6.1/lib/getMarkupWrap", "npm:fbjs@0.6.1/lib/invariant", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ExecutionEnvironment = $__require('npm:fbjs@0.6.1/lib/ExecutionEnvironment');
    var createArrayFromMixed = $__require('npm:fbjs@0.6.1/lib/createArrayFromMixed');
    var getMarkupWrap = $__require('npm:fbjs@0.6.1/lib/getMarkupWrap');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
    var nodeNamePattern = /^\s*<(\w+)/;
    function getNodeName(markup) {
      var nodeNameMatch = markup.match(nodeNamePattern);
      return nodeNameMatch && nodeNameMatch[1].toLowerCase();
    }
    function createNodesFromMarkup(markup, handleScript) {
      var node = dummyNode;
      !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : undefined;
      var nodeName = getNodeName(markup);
      var wrap = nodeName && getMarkupWrap(nodeName);
      if (wrap) {
        node.innerHTML = wrap[1] + markup + wrap[2];
        var wrapDepth = wrap[0];
        while (wrapDepth--) {
          node = node.lastChild;
        }
      } else {
        node.innerHTML = markup;
      }
      var scripts = node.getElementsByTagName('script');
      if (scripts.length) {
        !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : undefined;
        createArrayFromMixed(scripts).forEach(handleScript);
      }
      var nodes = createArrayFromMixed(node.childNodes);
      while (node.lastChild) {
        node.removeChild(node.lastChild);
      }
      return nodes;
    }
    module.exports = createNodesFromMarkup;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/getMarkupWrap", ["npm:fbjs@0.6.1/lib/ExecutionEnvironment", "npm:fbjs@0.6.1/lib/invariant", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ExecutionEnvironment = $__require('npm:fbjs@0.6.1/lib/ExecutionEnvironment');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
    var shouldWrap = {};
    var selectWrap = [1, '<select multiple="true">', '</select>'];
    var tableWrap = [1, '<table>', '</table>'];
    var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
    var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
    var markupWrap = {
      '*': [1, '?<div>', '</div>'],
      'area': [1, '<map>', '</map>'],
      'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
      'legend': [1, '<fieldset>', '</fieldset>'],
      'param': [1, '<object>', '</object>'],
      'tr': [2, '<table><tbody>', '</tbody></table>'],
      'optgroup': selectWrap,
      'option': selectWrap,
      'caption': tableWrap,
      'colgroup': tableWrap,
      'tbody': tableWrap,
      'tfoot': tableWrap,
      'thead': tableWrap,
      'td': trWrap,
      'th': trWrap
    };
    var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
    svgElements.forEach(function(nodeName) {
      markupWrap[nodeName] = svgWrap;
      shouldWrap[nodeName] = true;
    });
    function getMarkupWrap(nodeName) {
      !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : undefined;
      if (!markupWrap.hasOwnProperty(nodeName)) {
        nodeName = '*';
      }
      if (!shouldWrap.hasOwnProperty(nodeName)) {
        if (nodeName === '*') {
          dummyNode.innerHTML = '<link />';
        } else {
          dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
        }
        shouldWrap[nodeName] = !dummyNode.firstChild;
      }
      return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
    }
    module.exports = getMarkupWrap;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/Danger", ["npm:fbjs@0.6.1/lib/ExecutionEnvironment", "npm:fbjs@0.6.1/lib/createNodesFromMarkup", "npm:fbjs@0.6.1/lib/emptyFunction", "npm:fbjs@0.6.1/lib/getMarkupWrap", "npm:fbjs@0.6.1/lib/invariant", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ExecutionEnvironment = $__require('npm:fbjs@0.6.1/lib/ExecutionEnvironment');
    var createNodesFromMarkup = $__require('npm:fbjs@0.6.1/lib/createNodesFromMarkup');
    var emptyFunction = $__require('npm:fbjs@0.6.1/lib/emptyFunction');
    var getMarkupWrap = $__require('npm:fbjs@0.6.1/lib/getMarkupWrap');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
    var RESULT_INDEX_ATTR = 'data-danger-index';
    function getNodeName(markup) {
      return markup.substring(1, markup.indexOf(' '));
    }
    var Danger = {
      dangerouslyRenderMarkup: function(markupList) {
        !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString for server rendering.') : invariant(false) : undefined;
        var nodeName;
        var markupByNodeName = {};
        for (var i = 0; i < markupList.length; i++) {
          !markupList[i] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(false) : undefined;
          nodeName = getNodeName(markupList[i]);
          nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
          markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
          markupByNodeName[nodeName][i] = markupList[i];
        }
        var resultList = [];
        var resultListAssignmentCount = 0;
        for (nodeName in markupByNodeName) {
          if (!markupByNodeName.hasOwnProperty(nodeName)) {
            continue;
          }
          var markupListByNodeName = markupByNodeName[nodeName];
          var resultIndex;
          for (resultIndex in markupListByNodeName) {
            if (markupListByNodeName.hasOwnProperty(resultIndex)) {
              var markup = markupListByNodeName[resultIndex];
              markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP, '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
            }
          }
          var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction);
          for (var j = 0; j < renderNodes.length; ++j) {
            var renderNode = renderNodes[j];
            if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {
              resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
              renderNode.removeAttribute(RESULT_INDEX_ATTR);
              !!resultList.hasOwnProperty(resultIndex) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Assigning to an already-occupied result index.') : invariant(false) : undefined;
              resultList[resultIndex] = renderNode;
              resultListAssignmentCount += 1;
            } else if (process.env.NODE_ENV !== 'production') {
              console.error('Danger: Discarding unexpected node:', renderNode);
            }
          }
        }
        !(resultListAssignmentCount === resultList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Did not assign to every index of resultList.') : invariant(false) : undefined;
        !(resultList.length === markupList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(false) : undefined;
        return resultList;
      },
      dangerouslyReplaceNodeWithMarkup: function(oldChild, markup) {
        !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
        !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(false) : undefined;
        !(oldChild.tagName.toLowerCase() !== 'html') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See ReactDOMServer.renderToString().') : invariant(false) : undefined;
        var newChild;
        if (typeof markup === 'string') {
          newChild = createNodesFromMarkup(markup, emptyFunction)[0];
        } else {
          newChild = markup;
        }
        oldChild.parentNode.replaceChild(newChild, oldChild);
      }
    };
    module.exports = Danger;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactMultiChildUpdateTypes", ["npm:fbjs@0.6.1/lib/keyMirror"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var keyMirror = $__require('npm:fbjs@0.6.1/lib/keyMirror');
  var ReactMultiChildUpdateTypes = keyMirror({
    INSERT_MARKUP: null,
    MOVE_EXISTING: null,
    REMOVE_NODE: null,
    SET_MARKUP: null,
    TEXT_CONTENT: null
  });
  module.exports = ReactMultiChildUpdateTypes;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/DOMChildrenOperations", ["npm:react@0.14.6/lib/Danger", "npm:react@0.14.6/lib/ReactMultiChildUpdateTypes", "npm:react@0.14.6/lib/ReactPerf", "npm:react@0.14.6/lib/setInnerHTML", "npm:react@0.14.6/lib/setTextContent", "npm:fbjs@0.6.1/lib/invariant", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var Danger = $__require('npm:react@0.14.6/lib/Danger');
    var ReactMultiChildUpdateTypes = $__require('npm:react@0.14.6/lib/ReactMultiChildUpdateTypes');
    var ReactPerf = $__require('npm:react@0.14.6/lib/ReactPerf');
    var setInnerHTML = $__require('npm:react@0.14.6/lib/setInnerHTML');
    var setTextContent = $__require('npm:react@0.14.6/lib/setTextContent');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    function insertChildAt(parentNode, childNode, index) {
      var beforeChild = index >= parentNode.childNodes.length ? null : parentNode.childNodes.item(index);
      parentNode.insertBefore(childNode, beforeChild);
    }
    var DOMChildrenOperations = {
      dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,
      updateTextContent: setTextContent,
      processUpdates: function(updates, markupList) {
        var update;
        var initialChildren = null;
        var updatedChildren = null;
        for (var i = 0; i < updates.length; i++) {
          update = updates[i];
          if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
            var updatedIndex = update.fromIndex;
            var updatedChild = update.parentNode.childNodes[updatedIndex];
            var parentID = update.parentID;
            !updatedChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(false) : undefined;
            initialChildren = initialChildren || {};
            initialChildren[parentID] = initialChildren[parentID] || [];
            initialChildren[parentID][updatedIndex] = updatedChild;
            updatedChildren = updatedChildren || [];
            updatedChildren.push(updatedChild);
          }
        }
        var renderedMarkup;
        if (markupList.length && typeof markupList[0] === 'string') {
          renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
        } else {
          renderedMarkup = markupList;
        }
        if (updatedChildren) {
          for (var j = 0; j < updatedChildren.length; j++) {
            updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
          }
        }
        for (var k = 0; k < updates.length; k++) {
          update = updates[k];
          switch (update.type) {
            case ReactMultiChildUpdateTypes.INSERT_MARKUP:
              insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
              break;
            case ReactMultiChildUpdateTypes.MOVE_EXISTING:
              insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
              break;
            case ReactMultiChildUpdateTypes.SET_MARKUP:
              setInnerHTML(update.parentNode, update.content);
              break;
            case ReactMultiChildUpdateTypes.TEXT_CONTENT:
              setTextContent(update.parentNode, update.content);
              break;
            case ReactMultiChildUpdateTypes.REMOVE_NODE:
              break;
          }
        }
      }
    };
    ReactPerf.measureMethods(DOMChildrenOperations, 'DOMChildrenOperations', {updateTextContent: 'updateTextContent'});
    module.exports = DOMChildrenOperations;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/quoteAttributeValueForBrowser", ["npm:react@0.14.6/lib/escapeTextContentForBrowser"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var escapeTextContentForBrowser = $__require('npm:react@0.14.6/lib/escapeTextContentForBrowser');
  function quoteAttributeValueForBrowser(value) {
    return '"' + escapeTextContentForBrowser(value) + '"';
  }
  module.exports = quoteAttributeValueForBrowser;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/DOMPropertyOperations", ["npm:react@0.14.6/lib/DOMProperty", "npm:react@0.14.6/lib/ReactPerf", "npm:react@0.14.6/lib/quoteAttributeValueForBrowser", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var DOMProperty = $__require('npm:react@0.14.6/lib/DOMProperty');
    var ReactPerf = $__require('npm:react@0.14.6/lib/ReactPerf');
    var quoteAttributeValueForBrowser = $__require('npm:react@0.14.6/lib/quoteAttributeValueForBrowser');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    var VALID_ATTRIBUTE_NAME_REGEX = /^[a-zA-Z_][\w\.\-]*$/;
    var illegalAttributeNameCache = {};
    var validatedAttributeNameCache = {};
    function isAttributeNameSafe(attributeName) {
      if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
        return true;
      }
      if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
        return false;
      }
      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
        validatedAttributeNameCache[attributeName] = true;
        return true;
      }
      illegalAttributeNameCache[attributeName] = true;
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : undefined;
      return false;
    }
    function shouldIgnoreValue(propertyInfo, value) {
      return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
    }
    if (process.env.NODE_ENV !== 'production') {
      var reactProps = {
        children: true,
        dangerouslySetInnerHTML: true,
        key: true,
        ref: true
      };
      var warnedProperties = {};
      var warnUnknownProperty = function(name) {
        if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
          return;
        }
        warnedProperties[name] = true;
        var lowerCasedName = name.toLowerCase();
        var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
        process.env.NODE_ENV !== 'production' ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?', name, standardName) : undefined;
      };
    }
    var DOMPropertyOperations = {
      createMarkupForID: function(id) {
        return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
      },
      setAttributeForID: function(node, id) {
        node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
      },
      createMarkupForProperty: function(name, value) {
        var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
        if (propertyInfo) {
          if (shouldIgnoreValue(propertyInfo, value)) {
            return '';
          }
          var attributeName = propertyInfo.attributeName;
          if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
            return attributeName + '=""';
          }
          return attributeName + '=' + quoteAttributeValueForBrowser(value);
        } else if (DOMProperty.isCustomAttribute(name)) {
          if (value == null) {
            return '';
          }
          return name + '=' + quoteAttributeValueForBrowser(value);
        } else if (process.env.NODE_ENV !== 'production') {
          warnUnknownProperty(name);
        }
        return null;
      },
      createMarkupForCustomAttribute: function(name, value) {
        if (!isAttributeNameSafe(name) || value == null) {
          return '';
        }
        return name + '=' + quoteAttributeValueForBrowser(value);
      },
      setValueForProperty: function(node, name, value) {
        var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
        if (propertyInfo) {
          var mutationMethod = propertyInfo.mutationMethod;
          if (mutationMethod) {
            mutationMethod(node, value);
          } else if (shouldIgnoreValue(propertyInfo, value)) {
            this.deleteValueForProperty(node, name);
          } else if (propertyInfo.mustUseAttribute) {
            var attributeName = propertyInfo.attributeName;
            var namespace = propertyInfo.attributeNamespace;
            if (namespace) {
              node.setAttributeNS(namespace, attributeName, '' + value);
            } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
              node.setAttribute(attributeName, '');
            } else {
              node.setAttribute(attributeName, '' + value);
            }
          } else {
            var propName = propertyInfo.propertyName;
            if (!propertyInfo.hasSideEffects || '' + node[propName] !== '' + value) {
              node[propName] = value;
            }
          }
        } else if (DOMProperty.isCustomAttribute(name)) {
          DOMPropertyOperations.setValueForAttribute(node, name, value);
        } else if (process.env.NODE_ENV !== 'production') {
          warnUnknownProperty(name);
        }
      },
      setValueForAttribute: function(node, name, value) {
        if (!isAttributeNameSafe(name)) {
          return;
        }
        if (value == null) {
          node.removeAttribute(name);
        } else {
          node.setAttribute(name, '' + value);
        }
      },
      deleteValueForProperty: function(node, name) {
        var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
        if (propertyInfo) {
          var mutationMethod = propertyInfo.mutationMethod;
          if (mutationMethod) {
            mutationMethod(node, undefined);
          } else if (propertyInfo.mustUseAttribute) {
            node.removeAttribute(propertyInfo.attributeName);
          } else {
            var propName = propertyInfo.propertyName;
            var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
            if (!propertyInfo.hasSideEffects || '' + node[propName] !== defaultValue) {
              node[propName] = defaultValue;
            }
          }
        } else if (DOMProperty.isCustomAttribute(name)) {
          node.removeAttribute(name);
        } else if (process.env.NODE_ENV !== 'production') {
          warnUnknownProperty(name);
        }
      }
    };
    ReactPerf.measureMethods(DOMPropertyOperations, 'DOMPropertyOperations', {
      setValueForProperty: 'setValueForProperty',
      setValueForAttribute: 'setValueForAttribute',
      deleteValueForProperty: 'deleteValueForProperty'
    });
    module.exports = DOMPropertyOperations;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactDOMIDOperations", ["npm:react@0.14.6/lib/DOMChildrenOperations", "npm:react@0.14.6/lib/DOMPropertyOperations", "npm:react@0.14.6/lib/ReactMount", "npm:react@0.14.6/lib/ReactPerf", "npm:fbjs@0.6.1/lib/invariant", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var DOMChildrenOperations = $__require('npm:react@0.14.6/lib/DOMChildrenOperations');
    var DOMPropertyOperations = $__require('npm:react@0.14.6/lib/DOMPropertyOperations');
    var ReactMount = $__require('npm:react@0.14.6/lib/ReactMount');
    var ReactPerf = $__require('npm:react@0.14.6/lib/ReactPerf');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var INVALID_PROPERTY_ERRORS = {
      dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
      style: '`style` must be set using `updateStylesByID()`.'
    };
    var ReactDOMIDOperations = {
      updatePropertyByID: function(id, name, value) {
        var node = ReactMount.getNode(id);
        !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;
        if (value != null) {
          DOMPropertyOperations.setValueForProperty(node, name, value);
        } else {
          DOMPropertyOperations.deleteValueForProperty(node, name);
        }
      },
      dangerouslyReplaceNodeWithMarkupByID: function(id, markup) {
        var node = ReactMount.getNode(id);
        DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
      },
      dangerouslyProcessChildrenUpdates: function(updates, markup) {
        for (var i = 0; i < updates.length; i++) {
          updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
        }
        DOMChildrenOperations.processUpdates(updates, markup);
      }
    };
    ReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {
      dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',
      dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'
    });
    module.exports = ReactDOMIDOperations;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactComponentBrowserEnvironment", ["npm:react@0.14.6/lib/ReactDOMIDOperations", "npm:react@0.14.6/lib/ReactMount", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactDOMIDOperations = $__require('npm:react@0.14.6/lib/ReactDOMIDOperations');
    var ReactMount = $__require('npm:react@0.14.6/lib/ReactMount');
    var ReactComponentBrowserEnvironment = {
      processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
      replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,
      unmountIDFromEnvironment: function(rootNodeID) {
        ReactMount.purgeID(rootNodeID);
      }
    };
    module.exports = ReactComponentBrowserEnvironment;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/escapeTextContentForBrowser", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ESCAPE_LOOKUP = {
    '&': '&amp;',
    '>': '&gt;',
    '<': '&lt;',
    '"': '&quot;',
    '\'': '&#x27;'
  };
  var ESCAPE_REGEX = /[&><"']/g;
  function escaper(match) {
    return ESCAPE_LOOKUP[match];
  }
  function escapeTextContentForBrowser(text) {
    return ('' + text).replace(ESCAPE_REGEX, escaper);
  }
  module.exports = escapeTextContentForBrowser;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/setTextContent", ["npm:fbjs@0.6.1/lib/ExecutionEnvironment", "npm:react@0.14.6/lib/escapeTextContentForBrowser", "npm:react@0.14.6/lib/setInnerHTML"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ExecutionEnvironment = $__require('npm:fbjs@0.6.1/lib/ExecutionEnvironment');
  var escapeTextContentForBrowser = $__require('npm:react@0.14.6/lib/escapeTextContentForBrowser');
  var setInnerHTML = $__require('npm:react@0.14.6/lib/setInnerHTML');
  var setTextContent = function(node, text) {
    node.textContent = text;
  };
  if (ExecutionEnvironment.canUseDOM) {
    if (!('textContent' in document.documentElement)) {
      setTextContent = function(node, text) {
        setInnerHTML(node, escapeTextContentForBrowser(text));
      };
    }
  }
  module.exports = setTextContent;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactDOMTextComponent", ["npm:react@0.14.6/lib/DOMChildrenOperations", "npm:react@0.14.6/lib/DOMPropertyOperations", "npm:react@0.14.6/lib/ReactComponentBrowserEnvironment", "npm:react@0.14.6/lib/ReactMount", "npm:react@0.14.6/lib/Object.assign", "npm:react@0.14.6/lib/escapeTextContentForBrowser", "npm:react@0.14.6/lib/setTextContent", "npm:react@0.14.6/lib/validateDOMNesting", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var DOMChildrenOperations = $__require('npm:react@0.14.6/lib/DOMChildrenOperations');
    var DOMPropertyOperations = $__require('npm:react@0.14.6/lib/DOMPropertyOperations');
    var ReactComponentBrowserEnvironment = $__require('npm:react@0.14.6/lib/ReactComponentBrowserEnvironment');
    var ReactMount = $__require('npm:react@0.14.6/lib/ReactMount');
    var assign = $__require('npm:react@0.14.6/lib/Object.assign');
    var escapeTextContentForBrowser = $__require('npm:react@0.14.6/lib/escapeTextContentForBrowser');
    var setTextContent = $__require('npm:react@0.14.6/lib/setTextContent');
    var validateDOMNesting = $__require('npm:react@0.14.6/lib/validateDOMNesting');
    var ReactDOMTextComponent = function(props) {};
    assign(ReactDOMTextComponent.prototype, {
      construct: function(text) {
        this._currentElement = text;
        this._stringText = '' + text;
        this._rootNodeID = null;
        this._mountIndex = 0;
      },
      mountComponent: function(rootID, transaction, context) {
        if (process.env.NODE_ENV !== 'production') {
          if (context[validateDOMNesting.ancestorInfoContextKey]) {
            validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);
          }
        }
        this._rootNodeID = rootID;
        if (transaction.useCreateElement) {
          var ownerDocument = context[ReactMount.ownerDocumentContextKey];
          var el = ownerDocument.createElement('span');
          DOMPropertyOperations.setAttributeForID(el, rootID);
          ReactMount.getID(el);
          setTextContent(el, this._stringText);
          return el;
        } else {
          var escapedText = escapeTextContentForBrowser(this._stringText);
          if (transaction.renderToStaticMarkup) {
            return escapedText;
          }
          return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';
        }
      },
      receiveComponent: function(nextText, transaction) {
        if (nextText !== this._currentElement) {
          this._currentElement = nextText;
          var nextStringText = '' + nextText;
          if (nextStringText !== this._stringText) {
            this._stringText = nextStringText;
            var node = ReactMount.getNode(this._rootNodeID);
            DOMChildrenOperations.updateTextContent(node, nextStringText);
          }
        }
      },
      unmountComponent: function() {
        ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
      }
    });
    module.exports = ReactDOMTextComponent;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/getUnboundedScrollPosition", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function getUnboundedScrollPosition(scrollable) {
    if (scrollable === window) {
      return {
        x: window.pageXOffset || document.documentElement.scrollLeft,
        y: window.pageYOffset || document.documentElement.scrollTop
      };
    }
    return {
      x: scrollable.scrollLeft,
      y: scrollable.scrollTop
    };
  }
  module.exports = getUnboundedScrollPosition;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactEventListener", ["npm:fbjs@0.6.1/lib/EventListener", "npm:fbjs@0.6.1/lib/ExecutionEnvironment", "npm:react@0.14.6/lib/PooledClass", "npm:react@0.14.6/lib/ReactInstanceHandles", "npm:react@0.14.6/lib/ReactMount", "npm:react@0.14.6/lib/ReactUpdates", "npm:react@0.14.6/lib/Object.assign", "npm:react@0.14.6/lib/getEventTarget", "npm:fbjs@0.6.1/lib/getUnboundedScrollPosition", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var EventListener = $__require('npm:fbjs@0.6.1/lib/EventListener');
    var ExecutionEnvironment = $__require('npm:fbjs@0.6.1/lib/ExecutionEnvironment');
    var PooledClass = $__require('npm:react@0.14.6/lib/PooledClass');
    var ReactInstanceHandles = $__require('npm:react@0.14.6/lib/ReactInstanceHandles');
    var ReactMount = $__require('npm:react@0.14.6/lib/ReactMount');
    var ReactUpdates = $__require('npm:react@0.14.6/lib/ReactUpdates');
    var assign = $__require('npm:react@0.14.6/lib/Object.assign');
    var getEventTarget = $__require('npm:react@0.14.6/lib/getEventTarget');
    var getUnboundedScrollPosition = $__require('npm:fbjs@0.6.1/lib/getUnboundedScrollPosition');
    var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
    function findParent(node) {
      var nodeID = ReactMount.getID(node);
      var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
      var container = ReactMount.findReactContainerForID(rootID);
      var parent = ReactMount.getFirstReactDOM(container);
      return parent;
    }
    function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
      this.topLevelType = topLevelType;
      this.nativeEvent = nativeEvent;
      this.ancestors = [];
    }
    assign(TopLevelCallbackBookKeeping.prototype, {destructor: function() {
        this.topLevelType = null;
        this.nativeEvent = null;
        this.ancestors.length = 0;
      }});
    PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
    function handleTopLevelImpl(bookKeeping) {
      void handleTopLevelWithPath;
      handleTopLevelWithoutPath(bookKeeping);
    }
    function handleTopLevelWithoutPath(bookKeeping) {
      var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;
      var ancestor = topLevelTarget;
      while (ancestor) {
        bookKeeping.ancestors.push(ancestor);
        ancestor = findParent(ancestor);
      }
      for (var i = 0; i < bookKeeping.ancestors.length; i++) {
        topLevelTarget = bookKeeping.ancestors[i];
        var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
        ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
      }
    }
    function handleTopLevelWithPath(bookKeeping) {
      var path = bookKeeping.nativeEvent.path;
      var currentNativeTarget = path[0];
      var eventsFired = 0;
      for (var i = 0; i < path.length; i++) {
        var currentPathElement = path[i];
        if (currentPathElement.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE) {
          currentNativeTarget = path[i + 1];
        }
        var reactParent = ReactMount.getFirstReactDOM(currentPathElement);
        if (reactParent === currentPathElement) {
          var currentPathElementID = ReactMount.getID(currentPathElement);
          var newRootID = ReactInstanceHandles.getReactRootIDFromNodeID(currentPathElementID);
          bookKeeping.ancestors.push(currentPathElement);
          var topLevelTargetID = ReactMount.getID(currentPathElement) || '';
          eventsFired++;
          ReactEventListener._handleTopLevel(bookKeeping.topLevelType, currentPathElement, topLevelTargetID, bookKeeping.nativeEvent, currentNativeTarget);
          while (currentPathElementID !== newRootID) {
            i++;
            currentPathElement = path[i];
            currentPathElementID = ReactMount.getID(currentPathElement);
          }
        }
      }
      if (eventsFired === 0) {
        ReactEventListener._handleTopLevel(bookKeeping.topLevelType, window, '', bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
      }
    }
    function scrollValueMonitor(cb) {
      var scrollPosition = getUnboundedScrollPosition(window);
      cb(scrollPosition);
    }
    var ReactEventListener = {
      _enabled: true,
      _handleTopLevel: null,
      WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
      setHandleTopLevel: function(handleTopLevel) {
        ReactEventListener._handleTopLevel = handleTopLevel;
      },
      setEnabled: function(enabled) {
        ReactEventListener._enabled = !!enabled;
      },
      isEnabled: function() {
        return ReactEventListener._enabled;
      },
      trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
        var element = handle;
        if (!element) {
          return null;
        }
        return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
      },
      trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
        var element = handle;
        if (!element) {
          return null;
        }
        return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
      },
      monitorScrollValue: function(refresh) {
        var callback = scrollValueMonitor.bind(null, refresh);
        EventListener.listen(window, 'scroll', callback);
      },
      dispatchEvent: function(topLevelType, nativeEvent) {
        if (!ReactEventListener._enabled) {
          return;
        }
        var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
        try {
          ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
        } finally {
          TopLevelCallbackBookKeeping.release(bookKeeping);
        }
      }
    };
    module.exports = ReactEventListener;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactComponent", ["npm:react@0.14.6/lib/ReactNoopUpdateQueue", "npm:react@0.14.6/lib/canDefineProperty", "npm:fbjs@0.6.1/lib/emptyObject", "npm:fbjs@0.6.1/lib/invariant", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactNoopUpdateQueue = $__require('npm:react@0.14.6/lib/ReactNoopUpdateQueue');
    var canDefineProperty = $__require('npm:react@0.14.6/lib/canDefineProperty');
    var emptyObject = $__require('npm:fbjs@0.6.1/lib/emptyObject');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    function ReactComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    ReactComponent.prototype.isReactComponent = {};
    ReactComponent.prototype.setState = function(partialState, callback) {
      !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.') : invariant(false) : undefined;
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : undefined;
      }
      this.updater.enqueueSetState(this, partialState);
      if (callback) {
        this.updater.enqueueCallback(this, callback);
      }
    };
    ReactComponent.prototype.forceUpdate = function(callback) {
      this.updater.enqueueForceUpdate(this);
      if (callback) {
        this.updater.enqueueCallback(this, callback);
      }
    };
    if (process.env.NODE_ENV !== 'production') {
      var deprecatedAPIs = {
        getDOMNode: ['getDOMNode', 'Use ReactDOM.findDOMNode(component) instead.'],
        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
        replaceProps: ['replaceProps', 'Instead, call render again at the top level.'],
        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'],
        setProps: ['setProps', 'Instead, call render again at the top level.']
      };
      var defineDeprecationWarning = function(methodName, info) {
        if (canDefineProperty) {
          Object.defineProperty(ReactComponent.prototype, methodName, {get: function() {
              process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : undefined;
              return undefined;
            }});
        }
      };
      for (var fnName in deprecatedAPIs) {
        if (deprecatedAPIs.hasOwnProperty(fnName)) {
          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        }
      }
    }
    module.exports = ReactComponent;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactNoopUpdateQueue", ["npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    function warnTDZ(publicInstance, callerName) {
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor && publicInstance.constructor.displayName || '') : undefined;
      }
    }
    var ReactNoopUpdateQueue = {
      isMounted: function(publicInstance) {
        return false;
      },
      enqueueCallback: function(publicInstance, callback) {},
      enqueueForceUpdate: function(publicInstance) {
        warnTDZ(publicInstance, 'forceUpdate');
      },
      enqueueReplaceState: function(publicInstance, completeState) {
        warnTDZ(publicInstance, 'replaceState');
      },
      enqueueSetState: function(publicInstance, partialState) {
        warnTDZ(publicInstance, 'setState');
      },
      enqueueSetProps: function(publicInstance, partialProps) {
        warnTDZ(publicInstance, 'setProps');
      },
      enqueueReplaceProps: function(publicInstance, props) {
        warnTDZ(publicInstance, 'replaceProps');
      }
    };
    module.exports = ReactNoopUpdateQueue;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactClass", ["npm:react@0.14.6/lib/ReactComponent", "npm:react@0.14.6/lib/ReactElement", "npm:react@0.14.6/lib/ReactPropTypeLocations", "npm:react@0.14.6/lib/ReactPropTypeLocationNames", "npm:react@0.14.6/lib/ReactNoopUpdateQueue", "npm:react@0.14.6/lib/Object.assign", "npm:fbjs@0.6.1/lib/emptyObject", "npm:fbjs@0.6.1/lib/invariant", "npm:fbjs@0.6.1/lib/keyMirror", "npm:fbjs@0.6.1/lib/keyOf", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactComponent = $__require('npm:react@0.14.6/lib/ReactComponent');
    var ReactElement = $__require('npm:react@0.14.6/lib/ReactElement');
    var ReactPropTypeLocations = $__require('npm:react@0.14.6/lib/ReactPropTypeLocations');
    var ReactPropTypeLocationNames = $__require('npm:react@0.14.6/lib/ReactPropTypeLocationNames');
    var ReactNoopUpdateQueue = $__require('npm:react@0.14.6/lib/ReactNoopUpdateQueue');
    var assign = $__require('npm:react@0.14.6/lib/Object.assign');
    var emptyObject = $__require('npm:fbjs@0.6.1/lib/emptyObject');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var keyMirror = $__require('npm:fbjs@0.6.1/lib/keyMirror');
    var keyOf = $__require('npm:fbjs@0.6.1/lib/keyOf');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    var MIXINS_KEY = keyOf({mixins: null});
    var SpecPolicy = keyMirror({
      DEFINE_ONCE: null,
      DEFINE_MANY: null,
      OVERRIDE_BASE: null,
      DEFINE_MANY_MERGED: null
    });
    var injectedMixins = [];
    var warnedSetProps = false;
    function warnSetProps() {
      if (!warnedSetProps) {
        warnedSetProps = true;
        process.env.NODE_ENV !== 'production' ? warning(false, 'setProps(...) and replaceProps(...) are deprecated. ' + 'Instead, call render again at the top level.') : undefined;
      }
    }
    var ReactClassInterface = {
      mixins: SpecPolicy.DEFINE_MANY,
      statics: SpecPolicy.DEFINE_MANY,
      propTypes: SpecPolicy.DEFINE_MANY,
      contextTypes: SpecPolicy.DEFINE_MANY,
      childContextTypes: SpecPolicy.DEFINE_MANY,
      getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
      getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
      getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
      render: SpecPolicy.DEFINE_ONCE,
      componentWillMount: SpecPolicy.DEFINE_MANY,
      componentDidMount: SpecPolicy.DEFINE_MANY,
      componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
      shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
      componentWillUpdate: SpecPolicy.DEFINE_MANY,
      componentDidUpdate: SpecPolicy.DEFINE_MANY,
      componentWillUnmount: SpecPolicy.DEFINE_MANY,
      updateComponent: SpecPolicy.OVERRIDE_BASE
    };
    var RESERVED_SPEC_KEYS = {
      displayName: function(Constructor, displayName) {
        Constructor.displayName = displayName;
      },
      mixins: function(Constructor, mixins) {
        if (mixins) {
          for (var i = 0; i < mixins.length; i++) {
            mixSpecIntoComponent(Constructor, mixins[i]);
          }
        }
      },
      childContextTypes: function(Constructor, childContextTypes) {
        if (process.env.NODE_ENV !== 'production') {
          validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
        }
        Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes);
      },
      contextTypes: function(Constructor, contextTypes) {
        if (process.env.NODE_ENV !== 'production') {
          validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
        }
        Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes);
      },
      getDefaultProps: function(Constructor, getDefaultProps) {
        if (Constructor.getDefaultProps) {
          Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
        } else {
          Constructor.getDefaultProps = getDefaultProps;
        }
      },
      propTypes: function(Constructor, propTypes) {
        if (process.env.NODE_ENV !== 'production') {
          validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
        }
        Constructor.propTypes = assign({}, Constructor.propTypes, propTypes);
      },
      statics: function(Constructor, statics) {
        mixStaticSpecIntoComponent(Constructor, statics);
      },
      autobind: function() {}
    };
    function validateTypeDef(Constructor, typeDef, location) {
      for (var propName in typeDef) {
        if (typeDef.hasOwnProperty(propName)) {
          process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : undefined;
        }
      }
    }
    function validateMethodOverride(proto, name) {
      var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
      if (ReactClassMixin.hasOwnProperty(name)) {
        !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(false) : undefined;
      }
      if (proto.hasOwnProperty(name)) {
        !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(false) : undefined;
      }
    }
    function mixSpecIntoComponent(Constructor, spec) {
      if (!spec) {
        return;
      }
      !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
      !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
      var proto = Constructor.prototype;
      if (spec.hasOwnProperty(MIXINS_KEY)) {
        RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
      }
      for (var name in spec) {
        if (!spec.hasOwnProperty(name)) {
          continue;
        }
        if (name === MIXINS_KEY) {
          continue;
        }
        var property = spec[name];
        validateMethodOverride(proto, name);
        if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
          RESERVED_SPEC_KEYS[name](Constructor, property);
        } else {
          var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
          var isAlreadyDefined = proto.hasOwnProperty(name);
          var isFunction = typeof property === 'function';
          var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
          if (shouldAutoBind) {
            if (!proto.__reactAutoBindMap) {
              proto.__reactAutoBindMap = {};
            }
            proto.__reactAutoBindMap[name] = property;
            proto[name] = property;
          } else {
            if (isAlreadyDefined) {
              var specPolicy = ReactClassInterface[name];
              !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(false) : undefined;
              if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
                proto[name] = createMergedResultFunction(proto[name], property);
              } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
                proto[name] = createChainedFunction(proto[name], property);
              }
            } else {
              proto[name] = property;
              if (process.env.NODE_ENV !== 'production') {
                if (typeof property === 'function' && spec.displayName) {
                  proto[name].displayName = spec.displayName + '_' + name;
                }
              }
            }
          }
        }
      }
    }
    function mixStaticSpecIntoComponent(Constructor, statics) {
      if (!statics) {
        return;
      }
      for (var name in statics) {
        var property = statics[name];
        if (!statics.hasOwnProperty(name)) {
          continue;
        }
        var isReserved = (name in RESERVED_SPEC_KEYS);
        !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(false) : undefined;
        var isInherited = (name in Constructor);
        !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(false) : undefined;
        Constructor[name] = property;
      }
    }
    function mergeIntoWithNoDuplicateKeys(one, two) {
      !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : invariant(false) : undefined;
      for (var key in two) {
        if (two.hasOwnProperty(key)) {
          !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(false) : undefined;
          one[key] = two[key];
        }
      }
      return one;
    }
    function createMergedResultFunction(one, two) {
      return function mergedResult() {
        var a = one.apply(this, arguments);
        var b = two.apply(this, arguments);
        if (a == null) {
          return b;
        } else if (b == null) {
          return a;
        }
        var c = {};
        mergeIntoWithNoDuplicateKeys(c, a);
        mergeIntoWithNoDuplicateKeys(c, b);
        return c;
      };
    }
    function createChainedFunction(one, two) {
      return function chainedFunction() {
        one.apply(this, arguments);
        two.apply(this, arguments);
      };
    }
    function bindAutoBindMethod(component, method) {
      var boundMethod = method.bind(component);
      if (process.env.NODE_ENV !== 'production') {
        boundMethod.__reactBoundContext = component;
        boundMethod.__reactBoundMethod = method;
        boundMethod.__reactBoundArguments = null;
        var componentName = component.constructor.displayName;
        var _bind = boundMethod.bind;
        boundMethod.bind = function(newThis) {
          for (var _len = arguments.length,
              args = Array(_len > 1 ? _len - 1 : 0),
              _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          if (newThis !== component && newThis !== null) {
            process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : undefined;
          } else if (!args.length) {
            process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : undefined;
            return boundMethod;
          }
          var reboundMethod = _bind.apply(boundMethod, arguments);
          reboundMethod.__reactBoundContext = component;
          reboundMethod.__reactBoundMethod = method;
          reboundMethod.__reactBoundArguments = args;
          return reboundMethod;
        };
      }
      return boundMethod;
    }
    function bindAutoBindMethods(component) {
      for (var autoBindKey in component.__reactAutoBindMap) {
        if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
          var method = component.__reactAutoBindMap[autoBindKey];
          component[autoBindKey] = bindAutoBindMethod(component, method);
        }
      }
    }
    var ReactClassMixin = {
      replaceState: function(newState, callback) {
        this.updater.enqueueReplaceState(this, newState);
        if (callback) {
          this.updater.enqueueCallback(this, callback);
        }
      },
      isMounted: function() {
        return this.updater.isMounted(this);
      },
      setProps: function(partialProps, callback) {
        if (process.env.NODE_ENV !== 'production') {
          warnSetProps();
        }
        this.updater.enqueueSetProps(this, partialProps);
        if (callback) {
          this.updater.enqueueCallback(this, callback);
        }
      },
      replaceProps: function(newProps, callback) {
        if (process.env.NODE_ENV !== 'production') {
          warnSetProps();
        }
        this.updater.enqueueReplaceProps(this, newProps);
        if (callback) {
          this.updater.enqueueCallback(this, callback);
        }
      }
    };
    var ReactClassComponent = function() {};
    assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
    var ReactClass = {
      createClass: function(spec) {
        var Constructor = function(props, context, updater) {
          if (process.env.NODE_ENV !== 'production') {
            process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : undefined;
          }
          if (this.__reactAutoBindMap) {
            bindAutoBindMethods(this);
          }
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
          this.state = null;
          var initialState = this.getInitialState ? this.getInitialState() : null;
          if (process.env.NODE_ENV !== 'production') {
            if (typeof initialState === 'undefined' && this.getInitialState._isMockFunction) {
              initialState = null;
            }
          }
          !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : invariant(false) : undefined;
          this.state = initialState;
        };
        Constructor.prototype = new ReactClassComponent();
        Constructor.prototype.constructor = Constructor;
        injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
        mixSpecIntoComponent(Constructor, spec);
        if (Constructor.getDefaultProps) {
          Constructor.defaultProps = Constructor.getDefaultProps();
        }
        if (process.env.NODE_ENV !== 'production') {
          if (Constructor.getDefaultProps) {
            Constructor.getDefaultProps.isReactClassApproved = {};
          }
          if (Constructor.prototype.getInitialState) {
            Constructor.prototype.getInitialState.isReactClassApproved = {};
          }
        }
        !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : invariant(false) : undefined;
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : undefined;
          process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : undefined;
        }
        for (var methodName in ReactClassInterface) {
          if (!Constructor.prototype[methodName]) {
            Constructor.prototype[methodName] = null;
          }
        }
        return Constructor;
      },
      injection: {injectMixin: function(mixin) {
          injectedMixins.push(mixin);
        }}
    };
    module.exports = ReactClass;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactInjection", ["npm:react@0.14.6/lib/DOMProperty", "npm:react@0.14.6/lib/EventPluginHub", "npm:react@0.14.6/lib/ReactComponentEnvironment", "npm:react@0.14.6/lib/ReactClass", "npm:react@0.14.6/lib/ReactEmptyComponent", "npm:react@0.14.6/lib/ReactBrowserEventEmitter", "npm:react@0.14.6/lib/ReactNativeComponent", "npm:react@0.14.6/lib/ReactPerf", "npm:react@0.14.6/lib/ReactRootIndex", "npm:react@0.14.6/lib/ReactUpdates"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var DOMProperty = $__require('npm:react@0.14.6/lib/DOMProperty');
  var EventPluginHub = $__require('npm:react@0.14.6/lib/EventPluginHub');
  var ReactComponentEnvironment = $__require('npm:react@0.14.6/lib/ReactComponentEnvironment');
  var ReactClass = $__require('npm:react@0.14.6/lib/ReactClass');
  var ReactEmptyComponent = $__require('npm:react@0.14.6/lib/ReactEmptyComponent');
  var ReactBrowserEventEmitter = $__require('npm:react@0.14.6/lib/ReactBrowserEventEmitter');
  var ReactNativeComponent = $__require('npm:react@0.14.6/lib/ReactNativeComponent');
  var ReactPerf = $__require('npm:react@0.14.6/lib/ReactPerf');
  var ReactRootIndex = $__require('npm:react@0.14.6/lib/ReactRootIndex');
  var ReactUpdates = $__require('npm:react@0.14.6/lib/ReactUpdates');
  var ReactInjection = {
    Component: ReactComponentEnvironment.injection,
    Class: ReactClass.injection,
    DOMProperty: DOMProperty.injection,
    EmptyComponent: ReactEmptyComponent.injection,
    EventPluginHub: EventPluginHub.injection,
    EventEmitter: ReactBrowserEventEmitter.injection,
    NativeComponent: ReactNativeComponent.injection,
    Perf: ReactPerf.injection,
    RootIndex: ReactRootIndex.injection,
    Updates: ReactUpdates.injection
  };
  module.exports = ReactInjection;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactReconcileTransaction", ["npm:react@0.14.6/lib/CallbackQueue", "npm:react@0.14.6/lib/PooledClass", "npm:react@0.14.6/lib/ReactBrowserEventEmitter", "npm:react@0.14.6/lib/ReactDOMFeatureFlags", "npm:react@0.14.6/lib/ReactInputSelection", "npm:react@0.14.6/lib/Transaction", "npm:react@0.14.6/lib/Object.assign"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var CallbackQueue = $__require('npm:react@0.14.6/lib/CallbackQueue');
  var PooledClass = $__require('npm:react@0.14.6/lib/PooledClass');
  var ReactBrowserEventEmitter = $__require('npm:react@0.14.6/lib/ReactBrowserEventEmitter');
  var ReactDOMFeatureFlags = $__require('npm:react@0.14.6/lib/ReactDOMFeatureFlags');
  var ReactInputSelection = $__require('npm:react@0.14.6/lib/ReactInputSelection');
  var Transaction = $__require('npm:react@0.14.6/lib/Transaction');
  var assign = $__require('npm:react@0.14.6/lib/Object.assign');
  var SELECTION_RESTORATION = {
    initialize: ReactInputSelection.getSelectionInformation,
    close: ReactInputSelection.restoreSelection
  };
  var EVENT_SUPPRESSION = {
    initialize: function() {
      var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
      ReactBrowserEventEmitter.setEnabled(false);
      return currentlyEnabled;
    },
    close: function(previouslyEnabled) {
      ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
    }
  };
  var ON_DOM_READY_QUEUEING = {
    initialize: function() {
      this.reactMountReady.reset();
    },
    close: function() {
      this.reactMountReady.notifyAll();
    }
  };
  var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
  function ReactReconcileTransaction(forceHTML) {
    this.reinitializeTransaction();
    this.renderToStaticMarkup = false;
    this.reactMountReady = CallbackQueue.getPooled(null);
    this.useCreateElement = !forceHTML && ReactDOMFeatureFlags.useCreateElement;
  }
  var Mixin = {
    getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    },
    getReactMountReady: function() {
      return this.reactMountReady;
    },
    destructor: function() {
      CallbackQueue.release(this.reactMountReady);
      this.reactMountReady = null;
    }
  };
  assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
  PooledClass.addPoolingTo(ReactReconcileTransaction);
  module.exports = ReactReconcileTransaction;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/getNodeForCharacterOffset", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function getLeafNode(node) {
    while (node && node.firstChild) {
      node = node.firstChild;
    }
    return node;
  }
  function getSiblingNode(node) {
    while (node) {
      if (node.nextSibling) {
        return node.nextSibling;
      }
      node = node.parentNode;
    }
  }
  function getNodeForCharacterOffset(root, offset) {
    var node = getLeafNode(root);
    var nodeStart = 0;
    var nodeEnd = 0;
    while (node) {
      if (node.nodeType === 3) {
        nodeEnd = nodeStart + node.textContent.length;
        if (nodeStart <= offset && nodeEnd >= offset) {
          return {
            node: node,
            offset: offset - nodeStart
          };
        }
        nodeStart = nodeEnd;
      }
      node = getLeafNode(getSiblingNode(node));
    }
  }
  module.exports = getNodeForCharacterOffset;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/getTextContentAccessor", ["npm:fbjs@0.6.1/lib/ExecutionEnvironment"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ExecutionEnvironment = $__require('npm:fbjs@0.6.1/lib/ExecutionEnvironment');
  var contentKey = null;
  function getTextContentAccessor() {
    if (!contentKey && ExecutionEnvironment.canUseDOM) {
      contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
    }
    return contentKey;
  }
  module.exports = getTextContentAccessor;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactDOMSelection", ["npm:fbjs@0.6.1/lib/ExecutionEnvironment", "npm:react@0.14.6/lib/getNodeForCharacterOffset", "npm:react@0.14.6/lib/getTextContentAccessor"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ExecutionEnvironment = $__require('npm:fbjs@0.6.1/lib/ExecutionEnvironment');
  var getNodeForCharacterOffset = $__require('npm:react@0.14.6/lib/getNodeForCharacterOffset');
  var getTextContentAccessor = $__require('npm:react@0.14.6/lib/getTextContentAccessor');
  function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
    return anchorNode === focusNode && anchorOffset === focusOffset;
  }
  function getIEOffsets(node) {
    var selection = document.selection;
    var selectedRange = selection.createRange();
    var selectedLength = selectedRange.text.length;
    var fromStart = selectedRange.duplicate();
    fromStart.moveToElementText(node);
    fromStart.setEndPoint('EndToStart', selectedRange);
    var startOffset = fromStart.text.length;
    var endOffset = startOffset + selectedLength;
    return {
      start: startOffset,
      end: endOffset
    };
  }
  function getModernOffsets(node) {
    var selection = window.getSelection && window.getSelection();
    if (!selection || selection.rangeCount === 0) {
      return null;
    }
    var anchorNode = selection.anchorNode;
    var anchorOffset = selection.anchorOffset;
    var focusNode = selection.focusNode;
    var focusOffset = selection.focusOffset;
    var currentRange = selection.getRangeAt(0);
    try {
      currentRange.startContainer.nodeType;
      currentRange.endContainer.nodeType;
    } catch (e) {
      return null;
    }
    var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
    var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
    var tempRange = currentRange.cloneRange();
    tempRange.selectNodeContents(node);
    tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
    var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
    var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
    var end = start + rangeLength;
    var detectionRange = document.createRange();
    detectionRange.setStart(anchorNode, anchorOffset);
    detectionRange.setEnd(focusNode, focusOffset);
    var isBackward = detectionRange.collapsed;
    return {
      start: isBackward ? end : start,
      end: isBackward ? start : end
    };
  }
  function setIEOffsets(node, offsets) {
    var range = document.selection.createRange().duplicate();
    var start,
        end;
    if (typeof offsets.end === 'undefined') {
      start = offsets.start;
      end = start;
    } else if (offsets.start > offsets.end) {
      start = offsets.end;
      end = offsets.start;
    } else {
      start = offsets.start;
      end = offsets.end;
    }
    range.moveToElementText(node);
    range.moveStart('character', start);
    range.setEndPoint('EndToStart', range);
    range.moveEnd('character', end - start);
    range.select();
  }
  function setModernOffsets(node, offsets) {
    if (!window.getSelection) {
      return;
    }
    var selection = window.getSelection();
    var length = node[getTextContentAccessor()].length;
    var start = Math.min(offsets.start, length);
    var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);
    if (!selection.extend && start > end) {
      var temp = end;
      end = start;
      start = temp;
    }
    var startMarker = getNodeForCharacterOffset(node, start);
    var endMarker = getNodeForCharacterOffset(node, end);
    if (startMarker && endMarker) {
      var range = document.createRange();
      range.setStart(startMarker.node, startMarker.offset);
      selection.removeAllRanges();
      if (start > end) {
        selection.addRange(range);
        selection.extend(endMarker.node, endMarker.offset);
      } else {
        range.setEnd(endMarker.node, endMarker.offset);
        selection.addRange(range);
      }
    }
  }
  var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
  var ReactDOMSelection = {
    getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
    setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
  };
  module.exports = ReactDOMSelection;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/focusNode", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function focusNode(node) {
    try {
      node.focus();
    } catch (e) {}
  }
  module.exports = focusNode;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactInputSelection", ["npm:react@0.14.6/lib/ReactDOMSelection", "npm:fbjs@0.6.1/lib/containsNode", "npm:fbjs@0.6.1/lib/focusNode", "npm:fbjs@0.6.1/lib/getActiveElement"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ReactDOMSelection = $__require('npm:react@0.14.6/lib/ReactDOMSelection');
  var containsNode = $__require('npm:fbjs@0.6.1/lib/containsNode');
  var focusNode = $__require('npm:fbjs@0.6.1/lib/focusNode');
  var getActiveElement = $__require('npm:fbjs@0.6.1/lib/getActiveElement');
  function isInDocument(node) {
    return containsNode(document.documentElement, node);
  }
  var ReactInputSelection = {
    hasSelectionCapabilities: function(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
    },
    getSelectionInformation: function() {
      var focusedElem = getActiveElement();
      return {
        focusedElem: focusedElem,
        selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
      };
    },
    restoreSelection: function(priorSelectionInformation) {
      var curFocusedElem = getActiveElement();
      var priorFocusedElem = priorSelectionInformation.focusedElem;
      var priorSelectionRange = priorSelectionInformation.selectionRange;
      if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
        if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
          ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
        }
        focusNode(priorFocusedElem);
      }
    },
    getSelection: function(input) {
      var selection;
      if ('selectionStart' in input) {
        selection = {
          start: input.selectionStart,
          end: input.selectionEnd
        };
      } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
        var range = document.selection.createRange();
        if (range.parentElement() === input) {
          selection = {
            start: -range.moveStart('character', -input.value.length),
            end: -range.moveEnd('character', -input.value.length)
          };
        }
      } else {
        selection = ReactDOMSelection.getOffsets(input);
      }
      return selection || {
        start: 0,
        end: 0
      };
    },
    setSelection: function(input, offsets) {
      var start = offsets.start;
      var end = offsets.end;
      if (typeof end === 'undefined') {
        end = start;
      }
      if ('selectionStart' in input) {
        input.selectionStart = start;
        input.selectionEnd = Math.min(end, input.value.length);
      } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
        var range = input.createTextRange();
        range.collapse(true);
        range.moveStart('character', start);
        range.moveEnd('character', end - start);
        range.select();
      } else {
        ReactDOMSelection.setOffsets(input, offsets);
      }
    }
  };
  module.exports = ReactInputSelection;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/getActiveElement", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function getActiveElement() {
    if (typeof document === 'undefined') {
      return null;
    }
    try {
      return document.activeElement || document.body;
    } catch (e) {
      return document.body;
    }
  }
  module.exports = getActiveElement;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/isTextInputElement", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var supportedInputTypes = {
    'color': true,
    'date': true,
    'datetime': true,
    'datetime-local': true,
    'email': true,
    'month': true,
    'number': true,
    'password': true,
    'range': true,
    'search': true,
    'tel': true,
    'text': true,
    'time': true,
    'url': true,
    'week': true
  };
  function isTextInputElement(elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName && (nodeName === 'input' && supportedInputTypes[elem.type] || nodeName === 'textarea');
  }
  module.exports = isTextInputElement;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/shallowEqual", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function shallowEqual(objA, objB) {
    if (objA === objB) {
      return true;
    }
    if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
      return false;
    }
    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) {
      return false;
    }
    var bHasOwnProperty = hasOwnProperty.bind(objB);
    for (var i = 0; i < keysA.length; i++) {
      if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
        return false;
      }
    }
    return true;
  }
  module.exports = shallowEqual;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/SelectEventPlugin", ["npm:react@0.14.6/lib/EventConstants", "npm:react@0.14.6/lib/EventPropagators", "npm:fbjs@0.6.1/lib/ExecutionEnvironment", "npm:react@0.14.6/lib/ReactInputSelection", "npm:react@0.14.6/lib/SyntheticEvent", "npm:fbjs@0.6.1/lib/getActiveElement", "npm:react@0.14.6/lib/isTextInputElement", "npm:fbjs@0.6.1/lib/keyOf", "npm:fbjs@0.6.1/lib/shallowEqual"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var EventConstants = $__require('npm:react@0.14.6/lib/EventConstants');
  var EventPropagators = $__require('npm:react@0.14.6/lib/EventPropagators');
  var ExecutionEnvironment = $__require('npm:fbjs@0.6.1/lib/ExecutionEnvironment');
  var ReactInputSelection = $__require('npm:react@0.14.6/lib/ReactInputSelection');
  var SyntheticEvent = $__require('npm:react@0.14.6/lib/SyntheticEvent');
  var getActiveElement = $__require('npm:fbjs@0.6.1/lib/getActiveElement');
  var isTextInputElement = $__require('npm:react@0.14.6/lib/isTextInputElement');
  var keyOf = $__require('npm:fbjs@0.6.1/lib/keyOf');
  var shallowEqual = $__require('npm:fbjs@0.6.1/lib/shallowEqual');
  var topLevelTypes = EventConstants.topLevelTypes;
  var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
  var eventTypes = {select: {
      phasedRegistrationNames: {
        bubbled: keyOf({onSelect: null}),
        captured: keyOf({onSelectCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
    }};
  var activeElement = null;
  var activeElementID = null;
  var lastSelection = null;
  var mouseDown = false;
  var hasListener = false;
  var ON_SELECT_KEY = keyOf({onSelect: null});
  function getSelection(node) {
    if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
      return {
        start: node.selectionStart,
        end: node.selectionEnd
      };
    } else if (window.getSelection) {
      var selection = window.getSelection();
      return {
        anchorNode: selection.anchorNode,
        anchorOffset: selection.anchorOffset,
        focusNode: selection.focusNode,
        focusOffset: selection.focusOffset
      };
    } else if (document.selection) {
      var range = document.selection.createRange();
      return {
        parentElement: range.parentElement(),
        text: range.text,
        top: range.boundingTop,
        left: range.boundingLeft
      };
    }
  }
  function constructSelectEvent(nativeEvent, nativeEventTarget) {
    if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
      return null;
    }
    var currentSelection = getSelection(activeElement);
    if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
      lastSelection = currentSelection;
      var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent, nativeEventTarget);
      syntheticEvent.type = 'select';
      syntheticEvent.target = activeElement;
      EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
      return syntheticEvent;
    }
    return null;
  }
  var SelectEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
      if (!hasListener) {
        return null;
      }
      switch (topLevelType) {
        case topLevelTypes.topFocus:
          if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
            activeElement = topLevelTarget;
            activeElementID = topLevelTargetID;
            lastSelection = null;
          }
          break;
        case topLevelTypes.topBlur:
          activeElement = null;
          activeElementID = null;
          lastSelection = null;
          break;
        case topLevelTypes.topMouseDown:
          mouseDown = true;
          break;
        case topLevelTypes.topContextMenu:
        case topLevelTypes.topMouseUp:
          mouseDown = false;
          return constructSelectEvent(nativeEvent, nativeEventTarget);
        case topLevelTypes.topSelectionChange:
          if (skipSelectionChangeEvent) {
            break;
          }
        case topLevelTypes.topKeyDown:
        case topLevelTypes.topKeyUp:
          return constructSelectEvent(nativeEvent, nativeEventTarget);
      }
      return null;
    },
    didPutListener: function(id, registrationName, listener) {
      if (registrationName === ON_SELECT_KEY) {
        hasListener = true;
      }
    }
  };
  module.exports = SelectEventPlugin;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ServerReactRootIndex", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);
  var ServerReactRootIndex = {createReactRootIndex: function() {
      return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
    }};
  module.exports = ServerReactRootIndex;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/EventListener", ["npm:fbjs@0.6.1/lib/emptyFunction", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var emptyFunction = $__require('npm:fbjs@0.6.1/lib/emptyFunction');
    var EventListener = {
      listen: function(target, eventType, callback) {
        if (target.addEventListener) {
          target.addEventListener(eventType, callback, false);
          return {remove: function() {
              target.removeEventListener(eventType, callback, false);
            }};
        } else if (target.attachEvent) {
          target.attachEvent('on' + eventType, callback);
          return {remove: function() {
              target.detachEvent('on' + eventType, callback);
            }};
        }
      },
      capture: function(target, eventType, callback) {
        if (target.addEventListener) {
          target.addEventListener(eventType, callback, true);
          return {remove: function() {
              target.removeEventListener(eventType, callback, true);
            }};
        } else {
          if (process.env.NODE_ENV !== 'production') {
            console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
          }
          return {remove: emptyFunction};
        }
      },
      registerDefault: function() {}
    };
    module.exports = EventListener;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/EventPropagators", ["npm:react@0.14.6/lib/EventConstants", "npm:react@0.14.6/lib/EventPluginHub", "npm:fbjs@0.6.1/lib/warning", "npm:react@0.14.6/lib/accumulateInto", "npm:react@0.14.6/lib/forEachAccumulated", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var EventConstants = $__require('npm:react@0.14.6/lib/EventConstants');
    var EventPluginHub = $__require('npm:react@0.14.6/lib/EventPluginHub');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    var accumulateInto = $__require('npm:react@0.14.6/lib/accumulateInto');
    var forEachAccumulated = $__require('npm:react@0.14.6/lib/forEachAccumulated');
    var PropagationPhases = EventConstants.PropagationPhases;
    var getListener = EventPluginHub.getListener;
    function listenerAtPhase(id, event, propagationPhase) {
      var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
      return getListener(id, registrationName);
    }
    function accumulateDirectionalDispatches(domID, upwards, event) {
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(domID, 'Dispatching id must not be null') : undefined;
      }
      var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
      var listener = listenerAtPhase(domID, event, phase);
      if (listener) {
        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
        event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
      }
    }
    function accumulateTwoPhaseDispatchesSingle(event) {
      if (event && event.dispatchConfig.phasedRegistrationNames) {
        EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
      }
    }
    function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
      if (event && event.dispatchConfig.phasedRegistrationNames) {
        EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);
      }
    }
    function accumulateDispatches(id, ignoredDirection, event) {
      if (event && event.dispatchConfig.registrationName) {
        var registrationName = event.dispatchConfig.registrationName;
        var listener = getListener(id, registrationName);
        if (listener) {
          event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
          event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
        }
      }
    }
    function accumulateDirectDispatchesSingle(event) {
      if (event && event.dispatchConfig.registrationName) {
        accumulateDispatches(event.dispatchMarker, null, event);
      }
    }
    function accumulateTwoPhaseDispatches(events) {
      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
    }
    function accumulateTwoPhaseDispatchesSkipTarget(events) {
      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
    }
    function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
      EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
    }
    function accumulateDirectDispatches(events) {
      forEachAccumulated(events, accumulateDirectDispatchesSingle);
    }
    var EventPropagators = {
      accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
      accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
      accumulateDirectDispatches: accumulateDirectDispatches,
      accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
    };
    module.exports = EventPropagators;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/SyntheticClipboardEvent", ["npm:react@0.14.6/lib/SyntheticEvent"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var SyntheticEvent = $__require('npm:react@0.14.6/lib/SyntheticEvent');
  var ClipboardEventInterface = {clipboardData: function(event) {
      return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
    }};
  function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
  module.exports = SyntheticClipboardEvent;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/SyntheticFocusEvent", ["npm:react@0.14.6/lib/SyntheticUIEvent"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var SyntheticUIEvent = $__require('npm:react@0.14.6/lib/SyntheticUIEvent');
  var FocusEventInterface = {relatedTarget: null};
  function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
  module.exports = SyntheticFocusEvent;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/getEventKey", ["npm:react@0.14.6/lib/getEventCharCode"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getEventCharCode = $__require('npm:react@0.14.6/lib/getEventCharCode');
  var normalizeKey = {
    'Esc': 'Escape',
    'Spacebar': ' ',
    'Left': 'ArrowLeft',
    'Up': 'ArrowUp',
    'Right': 'ArrowRight',
    'Down': 'ArrowDown',
    'Del': 'Delete',
    'Win': 'OS',
    'Menu': 'ContextMenu',
    'Apps': 'ContextMenu',
    'Scroll': 'ScrollLock',
    'MozPrintableKey': 'Unidentified'
  };
  var translateToKey = {
    8: 'Backspace',
    9: 'Tab',
    12: 'Clear',
    13: 'Enter',
    16: 'Shift',
    17: 'Control',
    18: 'Alt',
    19: 'Pause',
    20: 'CapsLock',
    27: 'Escape',
    32: ' ',
    33: 'PageUp',
    34: 'PageDown',
    35: 'End',
    36: 'Home',
    37: 'ArrowLeft',
    38: 'ArrowUp',
    39: 'ArrowRight',
    40: 'ArrowDown',
    45: 'Insert',
    46: 'Delete',
    112: 'F1',
    113: 'F2',
    114: 'F3',
    115: 'F4',
    116: 'F5',
    117: 'F6',
    118: 'F7',
    119: 'F8',
    120: 'F9',
    121: 'F10',
    122: 'F11',
    123: 'F12',
    144: 'NumLock',
    145: 'ScrollLock',
    224: 'Meta'
  };
  function getEventKey(nativeEvent) {
    if (nativeEvent.key) {
      var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
      if (key !== 'Unidentified') {
        return key;
      }
    }
    if (nativeEvent.type === 'keypress') {
      var charCode = getEventCharCode(nativeEvent);
      return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
    }
    if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
      return translateToKey[nativeEvent.keyCode] || 'Unidentified';
    }
    return '';
  }
  module.exports = getEventKey;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/SyntheticKeyboardEvent", ["npm:react@0.14.6/lib/SyntheticUIEvent", "npm:react@0.14.6/lib/getEventCharCode", "npm:react@0.14.6/lib/getEventKey", "npm:react@0.14.6/lib/getEventModifierState"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var SyntheticUIEvent = $__require('npm:react@0.14.6/lib/SyntheticUIEvent');
  var getEventCharCode = $__require('npm:react@0.14.6/lib/getEventCharCode');
  var getEventKey = $__require('npm:react@0.14.6/lib/getEventKey');
  var getEventModifierState = $__require('npm:react@0.14.6/lib/getEventModifierState');
  var KeyboardEventInterface = {
    key: getEventKey,
    location: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    repeat: null,
    locale: null,
    getModifierState: getEventModifierState,
    charCode: function(event) {
      if (event.type === 'keypress') {
        return getEventCharCode(event);
      }
      return 0;
    },
    keyCode: function(event) {
      if (event.type === 'keydown' || event.type === 'keyup') {
        return event.keyCode;
      }
      return 0;
    },
    which: function(event) {
      if (event.type === 'keypress') {
        return getEventCharCode(event);
      }
      if (event.type === 'keydown' || event.type === 'keyup') {
        return event.keyCode;
      }
      return 0;
    }
  };
  function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
  module.exports = SyntheticKeyboardEvent;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/SyntheticDragEvent", ["npm:react@0.14.6/lib/SyntheticMouseEvent"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var SyntheticMouseEvent = $__require('npm:react@0.14.6/lib/SyntheticMouseEvent');
  var DragEventInterface = {dataTransfer: null};
  function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
  module.exports = SyntheticDragEvent;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/SyntheticTouchEvent", ["npm:react@0.14.6/lib/SyntheticUIEvent", "npm:react@0.14.6/lib/getEventModifierState"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var SyntheticUIEvent = $__require('npm:react@0.14.6/lib/SyntheticUIEvent');
  var getEventModifierState = $__require('npm:react@0.14.6/lib/getEventModifierState');
  var TouchEventInterface = {
    touches: null,
    targetTouches: null,
    changedTouches: null,
    altKey: null,
    metaKey: null,
    ctrlKey: null,
    shiftKey: null,
    getModifierState: getEventModifierState
  };
  function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
  module.exports = SyntheticTouchEvent;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/SyntheticEvent", ["npm:react@0.14.6/lib/PooledClass", "npm:react@0.14.6/lib/Object.assign", "npm:fbjs@0.6.1/lib/emptyFunction", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var PooledClass = $__require('npm:react@0.14.6/lib/PooledClass');
    var assign = $__require('npm:react@0.14.6/lib/Object.assign');
    var emptyFunction = $__require('npm:fbjs@0.6.1/lib/emptyFunction');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    var EventInterface = {
      type: null,
      currentTarget: emptyFunction.thatReturnsNull,
      eventPhase: null,
      bubbles: null,
      cancelable: null,
      timeStamp: function(event) {
        return event.timeStamp || Date.now();
      },
      defaultPrevented: null,
      isTrusted: null
    };
    function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
      this.dispatchConfig = dispatchConfig;
      this.dispatchMarker = dispatchMarker;
      this.nativeEvent = nativeEvent;
      this.target = nativeEventTarget;
      this.currentTarget = nativeEventTarget;
      var Interface = this.constructor.Interface;
      for (var propName in Interface) {
        if (!Interface.hasOwnProperty(propName)) {
          continue;
        }
        var normalize = Interface[propName];
        if (normalize) {
          this[propName] = normalize(nativeEvent);
        } else {
          this[propName] = nativeEvent[propName];
        }
      }
      var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
      if (defaultPrevented) {
        this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
      } else {
        this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
      }
      this.isPropagationStopped = emptyFunction.thatReturnsFalse;
    }
    assign(SyntheticEvent.prototype, {
      preventDefault: function() {
        this.defaultPrevented = true;
        var event = this.nativeEvent;
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `preventDefault` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
        }
        if (!event) {
          return;
        }
        if (event.preventDefault) {
          event.preventDefault();
        } else {
          event.returnValue = false;
        }
        this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
      },
      stopPropagation: function() {
        var event = this.nativeEvent;
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `stopPropagation` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
        }
        if (!event) {
          return;
        }
        if (event.stopPropagation) {
          event.stopPropagation();
        } else {
          event.cancelBubble = true;
        }
        this.isPropagationStopped = emptyFunction.thatReturnsTrue;
      },
      persist: function() {
        this.isPersistent = emptyFunction.thatReturnsTrue;
      },
      isPersistent: emptyFunction.thatReturnsFalse,
      destructor: function() {
        var Interface = this.constructor.Interface;
        for (var propName in Interface) {
          this[propName] = null;
        }
        this.dispatchConfig = null;
        this.dispatchMarker = null;
        this.nativeEvent = null;
      }
    });
    SyntheticEvent.Interface = EventInterface;
    SyntheticEvent.augmentClass = function(Class, Interface) {
      var Super = this;
      var prototype = Object.create(Super.prototype);
      assign(prototype, Class.prototype);
      Class.prototype = prototype;
      Class.prototype.constructor = Class;
      Class.Interface = assign({}, Super.Interface, Interface);
      Class.augmentClass = Super.augmentClass;
      PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
    };
    PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
    module.exports = SyntheticEvent;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/getEventTarget", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function getEventTarget(nativeEvent) {
    var target = nativeEvent.target || nativeEvent.srcElement || window;
    return target.nodeType === 3 ? target.parentNode : target;
  }
  module.exports = getEventTarget;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/SyntheticUIEvent", ["npm:react@0.14.6/lib/SyntheticEvent", "npm:react@0.14.6/lib/getEventTarget"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var SyntheticEvent = $__require('npm:react@0.14.6/lib/SyntheticEvent');
  var getEventTarget = $__require('npm:react@0.14.6/lib/getEventTarget');
  var UIEventInterface = {
    view: function(event) {
      if (event.view) {
        return event.view;
      }
      var target = getEventTarget(event);
      if (target != null && target.window === target) {
        return target;
      }
      var doc = target.ownerDocument;
      if (doc) {
        return doc.defaultView || doc.parentWindow;
      } else {
        return window;
      }
    },
    detail: function(event) {
      return event.detail || 0;
    }
  };
  function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
  module.exports = SyntheticUIEvent;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/getEventModifierState", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var modifierKeyToProp = {
    'Alt': 'altKey',
    'Control': 'ctrlKey',
    'Meta': 'metaKey',
    'Shift': 'shiftKey'
  };
  function modifierStateGetter(keyArg) {
    var syntheticEvent = this;
    var nativeEvent = syntheticEvent.nativeEvent;
    if (nativeEvent.getModifierState) {
      return nativeEvent.getModifierState(keyArg);
    }
    var keyProp = modifierKeyToProp[keyArg];
    return keyProp ? !!nativeEvent[keyProp] : false;
  }
  function getEventModifierState(nativeEvent) {
    return modifierStateGetter;
  }
  module.exports = getEventModifierState;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/SyntheticMouseEvent", ["npm:react@0.14.6/lib/SyntheticUIEvent", "npm:react@0.14.6/lib/ViewportMetrics", "npm:react@0.14.6/lib/getEventModifierState"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var SyntheticUIEvent = $__require('npm:react@0.14.6/lib/SyntheticUIEvent');
  var ViewportMetrics = $__require('npm:react@0.14.6/lib/ViewportMetrics');
  var getEventModifierState = $__require('npm:react@0.14.6/lib/getEventModifierState');
  var MouseEventInterface = {
    screenX: null,
    screenY: null,
    clientX: null,
    clientY: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    getModifierState: getEventModifierState,
    button: function(event) {
      var button = event.button;
      if ('which' in event) {
        return button;
      }
      return button === 2 ? 2 : button === 4 ? 1 : 0;
    },
    buttons: null,
    relatedTarget: function(event) {
      return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
    },
    pageX: function(event) {
      return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
    },
    pageY: function(event) {
      return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
    }
  };
  function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
  module.exports = SyntheticMouseEvent;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/SyntheticWheelEvent", ["npm:react@0.14.6/lib/SyntheticMouseEvent"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var SyntheticMouseEvent = $__require('npm:react@0.14.6/lib/SyntheticMouseEvent');
  var WheelEventInterface = {
    deltaX: function(event) {
      return 'deltaX' in event ? event.deltaX : 'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
    },
    deltaY: function(event) {
      return 'deltaY' in event ? event.deltaY : 'wheelDeltaY' in event ? -event.wheelDeltaY : 'wheelDelta' in event ? -event.wheelDelta : 0;
    },
    deltaZ: null,
    deltaMode: null
  };
  function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
  module.exports = SyntheticWheelEvent;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/getEventCharCode", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function getEventCharCode(nativeEvent) {
    var charCode;
    var keyCode = nativeEvent.keyCode;
    if ('charCode' in nativeEvent) {
      charCode = nativeEvent.charCode;
      if (charCode === 0 && keyCode === 13) {
        charCode = 13;
      }
    } else {
      charCode = keyCode;
    }
    if (charCode >= 32 || charCode === 13) {
      return charCode;
    }
    return 0;
  }
  module.exports = getEventCharCode;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/keyOf", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var keyOf = function(oneKeyObj) {
    var key;
    for (key in oneKeyObj) {
      if (!oneKeyObj.hasOwnProperty(key)) {
        continue;
      }
      return key;
    }
    return null;
  };
  module.exports = keyOf;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/SimpleEventPlugin", ["npm:react@0.14.6/lib/EventConstants", "npm:fbjs@0.6.1/lib/EventListener", "npm:react@0.14.6/lib/EventPropagators", "npm:react@0.14.6/lib/ReactMount", "npm:react@0.14.6/lib/SyntheticClipboardEvent", "npm:react@0.14.6/lib/SyntheticEvent", "npm:react@0.14.6/lib/SyntheticFocusEvent", "npm:react@0.14.6/lib/SyntheticKeyboardEvent", "npm:react@0.14.6/lib/SyntheticMouseEvent", "npm:react@0.14.6/lib/SyntheticDragEvent", "npm:react@0.14.6/lib/SyntheticTouchEvent", "npm:react@0.14.6/lib/SyntheticUIEvent", "npm:react@0.14.6/lib/SyntheticWheelEvent", "npm:fbjs@0.6.1/lib/emptyFunction", "npm:react@0.14.6/lib/getEventCharCode", "npm:fbjs@0.6.1/lib/invariant", "npm:fbjs@0.6.1/lib/keyOf", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var EventConstants = $__require('npm:react@0.14.6/lib/EventConstants');
    var EventListener = $__require('npm:fbjs@0.6.1/lib/EventListener');
    var EventPropagators = $__require('npm:react@0.14.6/lib/EventPropagators');
    var ReactMount = $__require('npm:react@0.14.6/lib/ReactMount');
    var SyntheticClipboardEvent = $__require('npm:react@0.14.6/lib/SyntheticClipboardEvent');
    var SyntheticEvent = $__require('npm:react@0.14.6/lib/SyntheticEvent');
    var SyntheticFocusEvent = $__require('npm:react@0.14.6/lib/SyntheticFocusEvent');
    var SyntheticKeyboardEvent = $__require('npm:react@0.14.6/lib/SyntheticKeyboardEvent');
    var SyntheticMouseEvent = $__require('npm:react@0.14.6/lib/SyntheticMouseEvent');
    var SyntheticDragEvent = $__require('npm:react@0.14.6/lib/SyntheticDragEvent');
    var SyntheticTouchEvent = $__require('npm:react@0.14.6/lib/SyntheticTouchEvent');
    var SyntheticUIEvent = $__require('npm:react@0.14.6/lib/SyntheticUIEvent');
    var SyntheticWheelEvent = $__require('npm:react@0.14.6/lib/SyntheticWheelEvent');
    var emptyFunction = $__require('npm:fbjs@0.6.1/lib/emptyFunction');
    var getEventCharCode = $__require('npm:react@0.14.6/lib/getEventCharCode');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var keyOf = $__require('npm:fbjs@0.6.1/lib/keyOf');
    var topLevelTypes = EventConstants.topLevelTypes;
    var eventTypes = {
      abort: {phasedRegistrationNames: {
          bubbled: keyOf({onAbort: true}),
          captured: keyOf({onAbortCapture: true})
        }},
      blur: {phasedRegistrationNames: {
          bubbled: keyOf({onBlur: true}),
          captured: keyOf({onBlurCapture: true})
        }},
      canPlay: {phasedRegistrationNames: {
          bubbled: keyOf({onCanPlay: true}),
          captured: keyOf({onCanPlayCapture: true})
        }},
      canPlayThrough: {phasedRegistrationNames: {
          bubbled: keyOf({onCanPlayThrough: true}),
          captured: keyOf({onCanPlayThroughCapture: true})
        }},
      click: {phasedRegistrationNames: {
          bubbled: keyOf({onClick: true}),
          captured: keyOf({onClickCapture: true})
        }},
      contextMenu: {phasedRegistrationNames: {
          bubbled: keyOf({onContextMenu: true}),
          captured: keyOf({onContextMenuCapture: true})
        }},
      copy: {phasedRegistrationNames: {
          bubbled: keyOf({onCopy: true}),
          captured: keyOf({onCopyCapture: true})
        }},
      cut: {phasedRegistrationNames: {
          bubbled: keyOf({onCut: true}),
          captured: keyOf({onCutCapture: true})
        }},
      doubleClick: {phasedRegistrationNames: {
          bubbled: keyOf({onDoubleClick: true}),
          captured: keyOf({onDoubleClickCapture: true})
        }},
      drag: {phasedRegistrationNames: {
          bubbled: keyOf({onDrag: true}),
          captured: keyOf({onDragCapture: true})
        }},
      dragEnd: {phasedRegistrationNames: {
          bubbled: keyOf({onDragEnd: true}),
          captured: keyOf({onDragEndCapture: true})
        }},
      dragEnter: {phasedRegistrationNames: {
          bubbled: keyOf({onDragEnter: true}),
          captured: keyOf({onDragEnterCapture: true})
        }},
      dragExit: {phasedRegistrationNames: {
          bubbled: keyOf({onDragExit: true}),
          captured: keyOf({onDragExitCapture: true})
        }},
      dragLeave: {phasedRegistrationNames: {
          bubbled: keyOf({onDragLeave: true}),
          captured: keyOf({onDragLeaveCapture: true})
        }},
      dragOver: {phasedRegistrationNames: {
          bubbled: keyOf({onDragOver: true}),
          captured: keyOf({onDragOverCapture: true})
        }},
      dragStart: {phasedRegistrationNames: {
          bubbled: keyOf({onDragStart: true}),
          captured: keyOf({onDragStartCapture: true})
        }},
      drop: {phasedRegistrationNames: {
          bubbled: keyOf({onDrop: true}),
          captured: keyOf({onDropCapture: true})
        }},
      durationChange: {phasedRegistrationNames: {
          bubbled: keyOf({onDurationChange: true}),
          captured: keyOf({onDurationChangeCapture: true})
        }},
      emptied: {phasedRegistrationNames: {
          bubbled: keyOf({onEmptied: true}),
          captured: keyOf({onEmptiedCapture: true})
        }},
      encrypted: {phasedRegistrationNames: {
          bubbled: keyOf({onEncrypted: true}),
          captured: keyOf({onEncryptedCapture: true})
        }},
      ended: {phasedRegistrationNames: {
          bubbled: keyOf({onEnded: true}),
          captured: keyOf({onEndedCapture: true})
        }},
      error: {phasedRegistrationNames: {
          bubbled: keyOf({onError: true}),
          captured: keyOf({onErrorCapture: true})
        }},
      focus: {phasedRegistrationNames: {
          bubbled: keyOf({onFocus: true}),
          captured: keyOf({onFocusCapture: true})
        }},
      input: {phasedRegistrationNames: {
          bubbled: keyOf({onInput: true}),
          captured: keyOf({onInputCapture: true})
        }},
      keyDown: {phasedRegistrationNames: {
          bubbled: keyOf({onKeyDown: true}),
          captured: keyOf({onKeyDownCapture: true})
        }},
      keyPress: {phasedRegistrationNames: {
          bubbled: keyOf({onKeyPress: true}),
          captured: keyOf({onKeyPressCapture: true})
        }},
      keyUp: {phasedRegistrationNames: {
          bubbled: keyOf({onKeyUp: true}),
          captured: keyOf({onKeyUpCapture: true})
        }},
      load: {phasedRegistrationNames: {
          bubbled: keyOf({onLoad: true}),
          captured: keyOf({onLoadCapture: true})
        }},
      loadedData: {phasedRegistrationNames: {
          bubbled: keyOf({onLoadedData: true}),
          captured: keyOf({onLoadedDataCapture: true})
        }},
      loadedMetadata: {phasedRegistrationNames: {
          bubbled: keyOf({onLoadedMetadata: true}),
          captured: keyOf({onLoadedMetadataCapture: true})
        }},
      loadStart: {phasedRegistrationNames: {
          bubbled: keyOf({onLoadStart: true}),
          captured: keyOf({onLoadStartCapture: true})
        }},
      mouseDown: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseDown: true}),
          captured: keyOf({onMouseDownCapture: true})
        }},
      mouseMove: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseMove: true}),
          captured: keyOf({onMouseMoveCapture: true})
        }},
      mouseOut: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseOut: true}),
          captured: keyOf({onMouseOutCapture: true})
        }},
      mouseOver: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseOver: true}),
          captured: keyOf({onMouseOverCapture: true})
        }},
      mouseUp: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseUp: true}),
          captured: keyOf({onMouseUpCapture: true})
        }},
      paste: {phasedRegistrationNames: {
          bubbled: keyOf({onPaste: true}),
          captured: keyOf({onPasteCapture: true})
        }},
      pause: {phasedRegistrationNames: {
          bubbled: keyOf({onPause: true}),
          captured: keyOf({onPauseCapture: true})
        }},
      play: {phasedRegistrationNames: {
          bubbled: keyOf({onPlay: true}),
          captured: keyOf({onPlayCapture: true})
        }},
      playing: {phasedRegistrationNames: {
          bubbled: keyOf({onPlaying: true}),
          captured: keyOf({onPlayingCapture: true})
        }},
      progress: {phasedRegistrationNames: {
          bubbled: keyOf({onProgress: true}),
          captured: keyOf({onProgressCapture: true})
        }},
      rateChange: {phasedRegistrationNames: {
          bubbled: keyOf({onRateChange: true}),
          captured: keyOf({onRateChangeCapture: true})
        }},
      reset: {phasedRegistrationNames: {
          bubbled: keyOf({onReset: true}),
          captured: keyOf({onResetCapture: true})
        }},
      scroll: {phasedRegistrationNames: {
          bubbled: keyOf({onScroll: true}),
          captured: keyOf({onScrollCapture: true})
        }},
      seeked: {phasedRegistrationNames: {
          bubbled: keyOf({onSeeked: true}),
          captured: keyOf({onSeekedCapture: true})
        }},
      seeking: {phasedRegistrationNames: {
          bubbled: keyOf({onSeeking: true}),
          captured: keyOf({onSeekingCapture: true})
        }},
      stalled: {phasedRegistrationNames: {
          bubbled: keyOf({onStalled: true}),
          captured: keyOf({onStalledCapture: true})
        }},
      submit: {phasedRegistrationNames: {
          bubbled: keyOf({onSubmit: true}),
          captured: keyOf({onSubmitCapture: true})
        }},
      suspend: {phasedRegistrationNames: {
          bubbled: keyOf({onSuspend: true}),
          captured: keyOf({onSuspendCapture: true})
        }},
      timeUpdate: {phasedRegistrationNames: {
          bubbled: keyOf({onTimeUpdate: true}),
          captured: keyOf({onTimeUpdateCapture: true})
        }},
      touchCancel: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchCancel: true}),
          captured: keyOf({onTouchCancelCapture: true})
        }},
      touchEnd: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchEnd: true}),
          captured: keyOf({onTouchEndCapture: true})
        }},
      touchMove: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchMove: true}),
          captured: keyOf({onTouchMoveCapture: true})
        }},
      touchStart: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchStart: true}),
          captured: keyOf({onTouchStartCapture: true})
        }},
      volumeChange: {phasedRegistrationNames: {
          bubbled: keyOf({onVolumeChange: true}),
          captured: keyOf({onVolumeChangeCapture: true})
        }},
      waiting: {phasedRegistrationNames: {
          bubbled: keyOf({onWaiting: true}),
          captured: keyOf({onWaitingCapture: true})
        }},
      wheel: {phasedRegistrationNames: {
          bubbled: keyOf({onWheel: true}),
          captured: keyOf({onWheelCapture: true})
        }}
    };
    var topLevelEventsToDispatchConfig = {
      topAbort: eventTypes.abort,
      topBlur: eventTypes.blur,
      topCanPlay: eventTypes.canPlay,
      topCanPlayThrough: eventTypes.canPlayThrough,
      topClick: eventTypes.click,
      topContextMenu: eventTypes.contextMenu,
      topCopy: eventTypes.copy,
      topCut: eventTypes.cut,
      topDoubleClick: eventTypes.doubleClick,
      topDrag: eventTypes.drag,
      topDragEnd: eventTypes.dragEnd,
      topDragEnter: eventTypes.dragEnter,
      topDragExit: eventTypes.dragExit,
      topDragLeave: eventTypes.dragLeave,
      topDragOver: eventTypes.dragOver,
      topDragStart: eventTypes.dragStart,
      topDrop: eventTypes.drop,
      topDurationChange: eventTypes.durationChange,
      topEmptied: eventTypes.emptied,
      topEncrypted: eventTypes.encrypted,
      topEnded: eventTypes.ended,
      topError: eventTypes.error,
      topFocus: eventTypes.focus,
      topInput: eventTypes.input,
      topKeyDown: eventTypes.keyDown,
      topKeyPress: eventTypes.keyPress,
      topKeyUp: eventTypes.keyUp,
      topLoad: eventTypes.load,
      topLoadedData: eventTypes.loadedData,
      topLoadedMetadata: eventTypes.loadedMetadata,
      topLoadStart: eventTypes.loadStart,
      topMouseDown: eventTypes.mouseDown,
      topMouseMove: eventTypes.mouseMove,
      topMouseOut: eventTypes.mouseOut,
      topMouseOver: eventTypes.mouseOver,
      topMouseUp: eventTypes.mouseUp,
      topPaste: eventTypes.paste,
      topPause: eventTypes.pause,
      topPlay: eventTypes.play,
      topPlaying: eventTypes.playing,
      topProgress: eventTypes.progress,
      topRateChange: eventTypes.rateChange,
      topReset: eventTypes.reset,
      topScroll: eventTypes.scroll,
      topSeeked: eventTypes.seeked,
      topSeeking: eventTypes.seeking,
      topStalled: eventTypes.stalled,
      topSubmit: eventTypes.submit,
      topSuspend: eventTypes.suspend,
      topTimeUpdate: eventTypes.timeUpdate,
      topTouchCancel: eventTypes.touchCancel,
      topTouchEnd: eventTypes.touchEnd,
      topTouchMove: eventTypes.touchMove,
      topTouchStart: eventTypes.touchStart,
      topVolumeChange: eventTypes.volumeChange,
      topWaiting: eventTypes.waiting,
      topWheel: eventTypes.wheel
    };
    for (var type in topLevelEventsToDispatchConfig) {
      topLevelEventsToDispatchConfig[type].dependencies = [type];
    }
    var ON_CLICK_KEY = keyOf({onClick: null});
    var onClickListeners = {};
    var SimpleEventPlugin = {
      eventTypes: eventTypes,
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
        var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
        if (!dispatchConfig) {
          return null;
        }
        var EventConstructor;
        switch (topLevelType) {
          case topLevelTypes.topAbort:
          case topLevelTypes.topCanPlay:
          case topLevelTypes.topCanPlayThrough:
          case topLevelTypes.topDurationChange:
          case topLevelTypes.topEmptied:
          case topLevelTypes.topEncrypted:
          case topLevelTypes.topEnded:
          case topLevelTypes.topError:
          case topLevelTypes.topInput:
          case topLevelTypes.topLoad:
          case topLevelTypes.topLoadedData:
          case topLevelTypes.topLoadedMetadata:
          case topLevelTypes.topLoadStart:
          case topLevelTypes.topPause:
          case topLevelTypes.topPlay:
          case topLevelTypes.topPlaying:
          case topLevelTypes.topProgress:
          case topLevelTypes.topRateChange:
          case topLevelTypes.topReset:
          case topLevelTypes.topSeeked:
          case topLevelTypes.topSeeking:
          case topLevelTypes.topStalled:
          case topLevelTypes.topSubmit:
          case topLevelTypes.topSuspend:
          case topLevelTypes.topTimeUpdate:
          case topLevelTypes.topVolumeChange:
          case topLevelTypes.topWaiting:
            EventConstructor = SyntheticEvent;
            break;
          case topLevelTypes.topKeyPress:
            if (getEventCharCode(nativeEvent) === 0) {
              return null;
            }
          case topLevelTypes.topKeyDown:
          case topLevelTypes.topKeyUp:
            EventConstructor = SyntheticKeyboardEvent;
            break;
          case topLevelTypes.topBlur:
          case topLevelTypes.topFocus:
            EventConstructor = SyntheticFocusEvent;
            break;
          case topLevelTypes.topClick:
            if (nativeEvent.button === 2) {
              return null;
            }
          case topLevelTypes.topContextMenu:
          case topLevelTypes.topDoubleClick:
          case topLevelTypes.topMouseDown:
          case topLevelTypes.topMouseMove:
          case topLevelTypes.topMouseOut:
          case topLevelTypes.topMouseOver:
          case topLevelTypes.topMouseUp:
            EventConstructor = SyntheticMouseEvent;
            break;
          case topLevelTypes.topDrag:
          case topLevelTypes.topDragEnd:
          case topLevelTypes.topDragEnter:
          case topLevelTypes.topDragExit:
          case topLevelTypes.topDragLeave:
          case topLevelTypes.topDragOver:
          case topLevelTypes.topDragStart:
          case topLevelTypes.topDrop:
            EventConstructor = SyntheticDragEvent;
            break;
          case topLevelTypes.topTouchCancel:
          case topLevelTypes.topTouchEnd:
          case topLevelTypes.topTouchMove:
          case topLevelTypes.topTouchStart:
            EventConstructor = SyntheticTouchEvent;
            break;
          case topLevelTypes.topScroll:
            EventConstructor = SyntheticUIEvent;
            break;
          case topLevelTypes.topWheel:
            EventConstructor = SyntheticWheelEvent;
            break;
          case topLevelTypes.topCopy:
          case topLevelTypes.topCut:
          case topLevelTypes.topPaste:
            EventConstructor = SyntheticClipboardEvent;
            break;
        }
        !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(false) : undefined;
        var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent, nativeEventTarget);
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      },
      didPutListener: function(id, registrationName, listener) {
        if (registrationName === ON_CLICK_KEY) {
          var node = ReactMount.getNode(id);
          if (!onClickListeners[id]) {
            onClickListeners[id] = EventListener.listen(node, 'click', emptyFunction);
          }
        }
      },
      willDeleteListener: function(id, registrationName) {
        if (registrationName === ON_CLICK_KEY) {
          onClickListeners[id].remove();
          delete onClickListeners[id];
        }
      }
    };
    module.exports = SimpleEventPlugin;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/SVGDOMPropertyConfig", ["npm:react@0.14.6/lib/DOMProperty"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var DOMProperty = $__require('npm:react@0.14.6/lib/DOMProperty');
  var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
  var NS = {
    xlink: 'http://www.w3.org/1999/xlink',
    xml: 'http://www.w3.org/XML/1998/namespace'
  };
  var SVGDOMPropertyConfig = {
    Properties: {
      clipPath: MUST_USE_ATTRIBUTE,
      cx: MUST_USE_ATTRIBUTE,
      cy: MUST_USE_ATTRIBUTE,
      d: MUST_USE_ATTRIBUTE,
      dx: MUST_USE_ATTRIBUTE,
      dy: MUST_USE_ATTRIBUTE,
      fill: MUST_USE_ATTRIBUTE,
      fillOpacity: MUST_USE_ATTRIBUTE,
      fontFamily: MUST_USE_ATTRIBUTE,
      fontSize: MUST_USE_ATTRIBUTE,
      fx: MUST_USE_ATTRIBUTE,
      fy: MUST_USE_ATTRIBUTE,
      gradientTransform: MUST_USE_ATTRIBUTE,
      gradientUnits: MUST_USE_ATTRIBUTE,
      markerEnd: MUST_USE_ATTRIBUTE,
      markerMid: MUST_USE_ATTRIBUTE,
      markerStart: MUST_USE_ATTRIBUTE,
      offset: MUST_USE_ATTRIBUTE,
      opacity: MUST_USE_ATTRIBUTE,
      patternContentUnits: MUST_USE_ATTRIBUTE,
      patternUnits: MUST_USE_ATTRIBUTE,
      points: MUST_USE_ATTRIBUTE,
      preserveAspectRatio: MUST_USE_ATTRIBUTE,
      r: MUST_USE_ATTRIBUTE,
      rx: MUST_USE_ATTRIBUTE,
      ry: MUST_USE_ATTRIBUTE,
      spreadMethod: MUST_USE_ATTRIBUTE,
      stopColor: MUST_USE_ATTRIBUTE,
      stopOpacity: MUST_USE_ATTRIBUTE,
      stroke: MUST_USE_ATTRIBUTE,
      strokeDasharray: MUST_USE_ATTRIBUTE,
      strokeLinecap: MUST_USE_ATTRIBUTE,
      strokeOpacity: MUST_USE_ATTRIBUTE,
      strokeWidth: MUST_USE_ATTRIBUTE,
      textAnchor: MUST_USE_ATTRIBUTE,
      transform: MUST_USE_ATTRIBUTE,
      version: MUST_USE_ATTRIBUTE,
      viewBox: MUST_USE_ATTRIBUTE,
      x1: MUST_USE_ATTRIBUTE,
      x2: MUST_USE_ATTRIBUTE,
      x: MUST_USE_ATTRIBUTE,
      xlinkActuate: MUST_USE_ATTRIBUTE,
      xlinkArcrole: MUST_USE_ATTRIBUTE,
      xlinkHref: MUST_USE_ATTRIBUTE,
      xlinkRole: MUST_USE_ATTRIBUTE,
      xlinkShow: MUST_USE_ATTRIBUTE,
      xlinkTitle: MUST_USE_ATTRIBUTE,
      xlinkType: MUST_USE_ATTRIBUTE,
      xmlBase: MUST_USE_ATTRIBUTE,
      xmlLang: MUST_USE_ATTRIBUTE,
      xmlSpace: MUST_USE_ATTRIBUTE,
      y1: MUST_USE_ATTRIBUTE,
      y2: MUST_USE_ATTRIBUTE,
      y: MUST_USE_ATTRIBUTE
    },
    DOMAttributeNamespaces: {
      xlinkActuate: NS.xlink,
      xlinkArcrole: NS.xlink,
      xlinkHref: NS.xlink,
      xlinkRole: NS.xlink,
      xlinkShow: NS.xlink,
      xlinkTitle: NS.xlink,
      xlinkType: NS.xlink,
      xmlBase: NS.xml,
      xmlLang: NS.xml,
      xmlSpace: NS.xml
    },
    DOMAttributeNames: {
      clipPath: 'clip-path',
      fillOpacity: 'fill-opacity',
      fontFamily: 'font-family',
      fontSize: 'font-size',
      gradientTransform: 'gradientTransform',
      gradientUnits: 'gradientUnits',
      markerEnd: 'marker-end',
      markerMid: 'marker-mid',
      markerStart: 'marker-start',
      patternContentUnits: 'patternContentUnits',
      patternUnits: 'patternUnits',
      preserveAspectRatio: 'preserveAspectRatio',
      spreadMethod: 'spreadMethod',
      stopColor: 'stop-color',
      stopOpacity: 'stop-opacity',
      strokeDasharray: 'stroke-dasharray',
      strokeLinecap: 'stroke-linecap',
      strokeOpacity: 'stroke-opacity',
      strokeWidth: 'stroke-width',
      textAnchor: 'text-anchor',
      viewBox: 'viewBox',
      xlinkActuate: 'xlink:actuate',
      xlinkArcrole: 'xlink:arcrole',
      xlinkHref: 'xlink:href',
      xlinkRole: 'xlink:role',
      xlinkShow: 'xlink:show',
      xlinkTitle: 'xlink:title',
      xlinkType: 'xlink:type',
      xmlBase: 'xml:base',
      xmlLang: 'xml:lang',
      xmlSpace: 'xml:space'
    }
  };
  module.exports = SVGDOMPropertyConfig;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactDefaultPerfAnalysis", ["npm:react@0.14.6/lib/Object.assign"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var assign = $__require('npm:react@0.14.6/lib/Object.assign');
  var DONT_CARE_THRESHOLD = 1.2;
  var DOM_OPERATION_TYPES = {
    '_mountImageIntoNode': 'set innerHTML',
    INSERT_MARKUP: 'set innerHTML',
    MOVE_EXISTING: 'move',
    REMOVE_NODE: 'remove',
    SET_MARKUP: 'set innerHTML',
    TEXT_CONTENT: 'set textContent',
    'setValueForProperty': 'update attribute',
    'setValueForAttribute': 'update attribute',
    'deleteValueForProperty': 'remove attribute',
    'setValueForStyles': 'update styles',
    'replaceNodeWithMarkup': 'replace',
    'updateTextContent': 'set textContent'
  };
  function getTotalTime(measurements) {
    var totalTime = 0;
    for (var i = 0; i < measurements.length; i++) {
      var measurement = measurements[i];
      totalTime += measurement.totalTime;
    }
    return totalTime;
  }
  function getDOMSummary(measurements) {
    var items = [];
    measurements.forEach(function(measurement) {
      Object.keys(measurement.writes).forEach(function(id) {
        measurement.writes[id].forEach(function(write) {
          items.push({
            id: id,
            type: DOM_OPERATION_TYPES[write.type] || write.type,
            args: write.args
          });
        });
      });
    });
    return items;
  }
  function getExclusiveSummary(measurements) {
    var candidates = {};
    var displayName;
    for (var i = 0; i < measurements.length; i++) {
      var measurement = measurements[i];
      var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
      for (var id in allIDs) {
        displayName = measurement.displayNames[id].current;
        candidates[displayName] = candidates[displayName] || {
          componentName: displayName,
          inclusive: 0,
          exclusive: 0,
          render: 0,
          count: 0
        };
        if (measurement.render[id]) {
          candidates[displayName].render += measurement.render[id];
        }
        if (measurement.exclusive[id]) {
          candidates[displayName].exclusive += measurement.exclusive[id];
        }
        if (measurement.inclusive[id]) {
          candidates[displayName].inclusive += measurement.inclusive[id];
        }
        if (measurement.counts[id]) {
          candidates[displayName].count += measurement.counts[id];
        }
      }
    }
    var arr = [];
    for (displayName in candidates) {
      if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
        arr.push(candidates[displayName]);
      }
    }
    arr.sort(function(a, b) {
      return b.exclusive - a.exclusive;
    });
    return arr;
  }
  function getInclusiveSummary(measurements, onlyClean) {
    var candidates = {};
    var inclusiveKey;
    for (var i = 0; i < measurements.length; i++) {
      var measurement = measurements[i];
      var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
      var cleanComponents;
      if (onlyClean) {
        cleanComponents = getUnchangedComponents(measurement);
      }
      for (var id in allIDs) {
        if (onlyClean && !cleanComponents[id]) {
          continue;
        }
        var displayName = measurement.displayNames[id];
        inclusiveKey = displayName.owner + ' > ' + displayName.current;
        candidates[inclusiveKey] = candidates[inclusiveKey] || {
          componentName: inclusiveKey,
          time: 0,
          count: 0
        };
        if (measurement.inclusive[id]) {
          candidates[inclusiveKey].time += measurement.inclusive[id];
        }
        if (measurement.counts[id]) {
          candidates[inclusiveKey].count += measurement.counts[id];
        }
      }
    }
    var arr = [];
    for (inclusiveKey in candidates) {
      if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
        arr.push(candidates[inclusiveKey]);
      }
    }
    arr.sort(function(a, b) {
      return b.time - a.time;
    });
    return arr;
  }
  function getUnchangedComponents(measurement) {
    var cleanComponents = {};
    var dirtyLeafIDs = Object.keys(measurement.writes);
    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
    for (var id in allIDs) {
      var isDirty = false;
      for (var i = 0; i < dirtyLeafIDs.length; i++) {
        if (dirtyLeafIDs[i].indexOf(id) === 0) {
          isDirty = true;
          break;
        }
      }
      if (measurement.created[id]) {
        isDirty = true;
      }
      if (!isDirty && measurement.counts[id] > 0) {
        cleanComponents[id] = true;
      }
    }
    return cleanComponents;
  }
  var ReactDefaultPerfAnalysis = {
    getExclusiveSummary: getExclusiveSummary,
    getInclusiveSummary: getInclusiveSummary,
    getDOMSummary: getDOMSummary,
    getTotalTime: getTotalTime
  };
  module.exports = ReactDefaultPerfAnalysis;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/performance", ["npm:fbjs@0.6.1/lib/ExecutionEnvironment"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ExecutionEnvironment = $__require('npm:fbjs@0.6.1/lib/ExecutionEnvironment');
  var performance;
  if (ExecutionEnvironment.canUseDOM) {
    performance = window.performance || window.msPerformance || window.webkitPerformance;
  }
  module.exports = performance || {};
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/performanceNow", ["npm:fbjs@0.6.1/lib/performance"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var performance = $__require('npm:fbjs@0.6.1/lib/performance');
  var performanceNow;
  if (performance.now) {
    performanceNow = function() {
      return performance.now();
    };
  } else {
    performanceNow = function() {
      return Date.now();
    };
  }
  module.exports = performanceNow;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactDefaultPerf", ["npm:react@0.14.6/lib/DOMProperty", "npm:react@0.14.6/lib/ReactDefaultPerfAnalysis", "npm:react@0.14.6/lib/ReactMount", "npm:react@0.14.6/lib/ReactPerf", "npm:fbjs@0.6.1/lib/performanceNow"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var DOMProperty = $__require('npm:react@0.14.6/lib/DOMProperty');
  var ReactDefaultPerfAnalysis = $__require('npm:react@0.14.6/lib/ReactDefaultPerfAnalysis');
  var ReactMount = $__require('npm:react@0.14.6/lib/ReactMount');
  var ReactPerf = $__require('npm:react@0.14.6/lib/ReactPerf');
  var performanceNow = $__require('npm:fbjs@0.6.1/lib/performanceNow');
  function roundFloat(val) {
    return Math.floor(val * 100) / 100;
  }
  function addValue(obj, key, val) {
    obj[key] = (obj[key] || 0) + val;
  }
  var ReactDefaultPerf = {
    _allMeasurements: [],
    _mountStack: [0],
    _injected: false,
    start: function() {
      if (!ReactDefaultPerf._injected) {
        ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
      }
      ReactDefaultPerf._allMeasurements.length = 0;
      ReactPerf.enableMeasure = true;
    },
    stop: function() {
      ReactPerf.enableMeasure = false;
    },
    getLastMeasurements: function() {
      return ReactDefaultPerf._allMeasurements;
    },
    printExclusive: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
      console.table(summary.map(function(item) {
        return {
          'Component class name': item.componentName,
          'Total inclusive time (ms)': roundFloat(item.inclusive),
          'Exclusive mount time (ms)': roundFloat(item.exclusive),
          'Exclusive render time (ms)': roundFloat(item.render),
          'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
          'Render time per instance (ms)': roundFloat(item.render / item.count),
          'Instances': item.count
        };
      }));
    },
    printInclusive: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
      console.table(summary.map(function(item) {
        return {
          'Owner > component': item.componentName,
          'Inclusive time (ms)': roundFloat(item.time),
          'Instances': item.count
        };
      }));
      console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
    },
    getMeasurementsSummaryMap: function(measurements) {
      var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
      return summary.map(function(item) {
        return {
          'Owner > component': item.componentName,
          'Wasted time (ms)': item.time,
          'Instances': item.count
        };
      });
    },
    printWasted: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
      console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
    },
    printDOM: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
      console.table(summary.map(function(item) {
        var result = {};
        result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
        result.type = item.type;
        result.args = JSON.stringify(item.args);
        return result;
      }));
      console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
    },
    _recordWrite: function(id, fnName, totalTime, args) {
      var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
      writes[id] = writes[id] || [];
      writes[id].push({
        type: fnName,
        time: totalTime,
        args: args
      });
    },
    measure: function(moduleName, fnName, func) {
      return function() {
        for (var _len = arguments.length,
            args = Array(_len),
            _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var totalTime;
        var rv;
        var start;
        if (fnName === '_renderNewRootComponent' || fnName === 'flushBatchedUpdates') {
          ReactDefaultPerf._allMeasurements.push({
            exclusive: {},
            inclusive: {},
            render: {},
            counts: {},
            writes: {},
            displayNames: {},
            totalTime: 0,
            created: {}
          });
          start = performanceNow();
          rv = func.apply(this, args);
          ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
          return rv;
        } else if (fnName === '_mountImageIntoNode' || moduleName === 'ReactBrowserEventEmitter' || moduleName === 'ReactDOMIDOperations' || moduleName === 'CSSPropertyOperations' || moduleName === 'DOMChildrenOperations' || moduleName === 'DOMPropertyOperations') {
          start = performanceNow();
          rv = func.apply(this, args);
          totalTime = performanceNow() - start;
          if (fnName === '_mountImageIntoNode') {
            var mountID = ReactMount.getID(args[1]);
            ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
          } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
            args[0].forEach(function(update) {
              var writeArgs = {};
              if (update.fromIndex !== null) {
                writeArgs.fromIndex = update.fromIndex;
              }
              if (update.toIndex !== null) {
                writeArgs.toIndex = update.toIndex;
              }
              if (update.textContent !== null) {
                writeArgs.textContent = update.textContent;
              }
              if (update.markupIndex !== null) {
                writeArgs.markup = args[1][update.markupIndex];
              }
              ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);
            });
          } else {
            var id = args[0];
            if (typeof id === 'object') {
              id = ReactMount.getID(args[0]);
            }
            ReactDefaultPerf._recordWrite(id, fnName, totalTime, Array.prototype.slice.call(args, 1));
          }
          return rv;
        } else if (moduleName === 'ReactCompositeComponent' && (fnName === 'mountComponent' || fnName === 'updateComponent' || fnName === '_renderValidatedComponent')) {
          if (this._currentElement.type === ReactMount.TopLevelWrapper) {
            return func.apply(this, args);
          }
          var rootNodeID = fnName === 'mountComponent' ? args[0] : this._rootNodeID;
          var isRender = fnName === '_renderValidatedComponent';
          var isMount = fnName === 'mountComponent';
          var mountStack = ReactDefaultPerf._mountStack;
          var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];
          if (isRender) {
            addValue(entry.counts, rootNodeID, 1);
          } else if (isMount) {
            entry.created[rootNodeID] = true;
            mountStack.push(0);
          }
          start = performanceNow();
          rv = func.apply(this, args);
          totalTime = performanceNow() - start;
          if (isRender) {
            addValue(entry.render, rootNodeID, totalTime);
          } else if (isMount) {
            var subMountTime = mountStack.pop();
            mountStack[mountStack.length - 1] += totalTime;
            addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
            addValue(entry.inclusive, rootNodeID, totalTime);
          } else {
            addValue(entry.inclusive, rootNodeID, totalTime);
          }
          entry.displayNames[rootNodeID] = {
            current: this.getName(),
            owner: this._currentElement._owner ? this._currentElement._owner.getName() : '<root>'
          };
          return rv;
        } else {
          return func.apply(this, args);
        }
      };
    }
  };
  module.exports = ReactDefaultPerf;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactDefaultInjection", ["npm:react@0.14.6/lib/BeforeInputEventPlugin", "npm:react@0.14.6/lib/ChangeEventPlugin", "npm:react@0.14.6/lib/ClientReactRootIndex", "npm:react@0.14.6/lib/DefaultEventPluginOrder", "npm:react@0.14.6/lib/EnterLeaveEventPlugin", "npm:fbjs@0.6.1/lib/ExecutionEnvironment", "npm:react@0.14.6/lib/HTMLDOMPropertyConfig", "npm:react@0.14.6/lib/ReactBrowserComponentMixin", "npm:react@0.14.6/lib/ReactComponentBrowserEnvironment", "npm:react@0.14.6/lib/ReactDefaultBatchingStrategy", "npm:react@0.14.6/lib/ReactDOMComponent", "npm:react@0.14.6/lib/ReactDOMTextComponent", "npm:react@0.14.6/lib/ReactEventListener", "npm:react@0.14.6/lib/ReactInjection", "npm:react@0.14.6/lib/ReactInstanceHandles", "npm:react@0.14.6/lib/ReactMount", "npm:react@0.14.6/lib/ReactReconcileTransaction", "npm:react@0.14.6/lib/SelectEventPlugin", "npm:react@0.14.6/lib/ServerReactRootIndex", "npm:react@0.14.6/lib/SimpleEventPlugin", "npm:react@0.14.6/lib/SVGDOMPropertyConfig", "npm:react@0.14.6/lib/ReactDefaultPerf", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var BeforeInputEventPlugin = $__require('npm:react@0.14.6/lib/BeforeInputEventPlugin');
    var ChangeEventPlugin = $__require('npm:react@0.14.6/lib/ChangeEventPlugin');
    var ClientReactRootIndex = $__require('npm:react@0.14.6/lib/ClientReactRootIndex');
    var DefaultEventPluginOrder = $__require('npm:react@0.14.6/lib/DefaultEventPluginOrder');
    var EnterLeaveEventPlugin = $__require('npm:react@0.14.6/lib/EnterLeaveEventPlugin');
    var ExecutionEnvironment = $__require('npm:fbjs@0.6.1/lib/ExecutionEnvironment');
    var HTMLDOMPropertyConfig = $__require('npm:react@0.14.6/lib/HTMLDOMPropertyConfig');
    var ReactBrowserComponentMixin = $__require('npm:react@0.14.6/lib/ReactBrowserComponentMixin');
    var ReactComponentBrowserEnvironment = $__require('npm:react@0.14.6/lib/ReactComponentBrowserEnvironment');
    var ReactDefaultBatchingStrategy = $__require('npm:react@0.14.6/lib/ReactDefaultBatchingStrategy');
    var ReactDOMComponent = $__require('npm:react@0.14.6/lib/ReactDOMComponent');
    var ReactDOMTextComponent = $__require('npm:react@0.14.6/lib/ReactDOMTextComponent');
    var ReactEventListener = $__require('npm:react@0.14.6/lib/ReactEventListener');
    var ReactInjection = $__require('npm:react@0.14.6/lib/ReactInjection');
    var ReactInstanceHandles = $__require('npm:react@0.14.6/lib/ReactInstanceHandles');
    var ReactMount = $__require('npm:react@0.14.6/lib/ReactMount');
    var ReactReconcileTransaction = $__require('npm:react@0.14.6/lib/ReactReconcileTransaction');
    var SelectEventPlugin = $__require('npm:react@0.14.6/lib/SelectEventPlugin');
    var ServerReactRootIndex = $__require('npm:react@0.14.6/lib/ServerReactRootIndex');
    var SimpleEventPlugin = $__require('npm:react@0.14.6/lib/SimpleEventPlugin');
    var SVGDOMPropertyConfig = $__require('npm:react@0.14.6/lib/SVGDOMPropertyConfig');
    var alreadyInjected = false;
    function inject() {
      if (alreadyInjected) {
        return;
      }
      alreadyInjected = true;
      ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
      ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
      ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
      ReactInjection.EventPluginHub.injectMount(ReactMount);
      ReactInjection.EventPluginHub.injectEventPluginsByName({
        SimpleEventPlugin: SimpleEventPlugin,
        EnterLeaveEventPlugin: EnterLeaveEventPlugin,
        ChangeEventPlugin: ChangeEventPlugin,
        SelectEventPlugin: SelectEventPlugin,
        BeforeInputEventPlugin: BeforeInputEventPlugin
      });
      ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);
      ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);
      ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);
      ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
      ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
      ReactInjection.EmptyComponent.injectEmptyComponent('noscript');
      ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
      ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
      ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);
      ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
      if (process.env.NODE_ENV !== 'production') {
        var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
        if (/[?&]react_perf\b/.test(url)) {
          var ReactDefaultPerf = $__require('npm:react@0.14.6/lib/ReactDefaultPerf');
          ReactDefaultPerf.start();
        }
      }
    }
    module.exports = {inject: inject};
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactVersion", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = '0.14.6';
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/findDOMNode", ["npm:react@0.14.6/lib/ReactCurrentOwner", "npm:react@0.14.6/lib/ReactInstanceMap", "npm:react@0.14.6/lib/ReactMount", "npm:fbjs@0.6.1/lib/invariant", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactCurrentOwner = $__require('npm:react@0.14.6/lib/ReactCurrentOwner');
    var ReactInstanceMap = $__require('npm:react@0.14.6/lib/ReactInstanceMap');
    var ReactMount = $__require('npm:react@0.14.6/lib/ReactMount');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    function findDOMNode(componentOrElement) {
      if (process.env.NODE_ENV !== 'production') {
        var owner = ReactCurrentOwner.current;
        if (owner !== null) {
          process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing getDOMNode or findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
          owner._warnedAboutRefsInRender = true;
        }
      }
      if (componentOrElement == null) {
        return null;
      }
      if (componentOrElement.nodeType === 1) {
        return componentOrElement;
      }
      if (ReactInstanceMap.has(componentOrElement)) {
        return ReactMount.getNodeFromInstance(componentOrElement);
      }
      !(componentOrElement.render == null || typeof componentOrElement.render !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : invariant(false) : undefined;
      !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : invariant(false) : undefined;
    }
    module.exports = findDOMNode;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/DOMProperty", ["npm:fbjs@0.6.1/lib/invariant", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    function checkMask(value, bitmask) {
      return (value & bitmask) === bitmask;
    }
    var DOMPropertyInjection = {
      MUST_USE_ATTRIBUTE: 0x1,
      MUST_USE_PROPERTY: 0x2,
      HAS_SIDE_EFFECTS: 0x4,
      HAS_BOOLEAN_VALUE: 0x8,
      HAS_NUMERIC_VALUE: 0x10,
      HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
      HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,
      injectDOMPropertyConfig: function(domPropertyConfig) {
        var Injection = DOMPropertyInjection;
        var Properties = domPropertyConfig.Properties || {};
        var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
        var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
        var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
        var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
        if (domPropertyConfig.isCustomAttribute) {
          DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
        }
        for (var propName in Properties) {
          !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(false) : undefined;
          var lowerCased = propName.toLowerCase();
          var propConfig = Properties[propName];
          var propertyInfo = {
            attributeName: lowerCased,
            attributeNamespace: null,
            propertyName: propName,
            mutationMethod: null,
            mustUseAttribute: checkMask(propConfig, Injection.MUST_USE_ATTRIBUTE),
            mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
            hasSideEffects: checkMask(propConfig, Injection.HAS_SIDE_EFFECTS),
            hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
            hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
            hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
            hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
          };
          !(!propertyInfo.mustUseAttribute || !propertyInfo.mustUseProperty) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(false) : undefined;
          !(propertyInfo.mustUseProperty || !propertyInfo.hasSideEffects) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(false) : undefined;
          !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(false) : undefined;
          if (process.env.NODE_ENV !== 'production') {
            DOMProperty.getPossibleStandardName[lowerCased] = propName;
          }
          if (DOMAttributeNames.hasOwnProperty(propName)) {
            var attributeName = DOMAttributeNames[propName];
            propertyInfo.attributeName = attributeName;
            if (process.env.NODE_ENV !== 'production') {
              DOMProperty.getPossibleStandardName[attributeName] = propName;
            }
          }
          if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
            propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
          }
          if (DOMPropertyNames.hasOwnProperty(propName)) {
            propertyInfo.propertyName = DOMPropertyNames[propName];
          }
          if (DOMMutationMethods.hasOwnProperty(propName)) {
            propertyInfo.mutationMethod = DOMMutationMethods[propName];
          }
          DOMProperty.properties[propName] = propertyInfo;
        }
      }
    };
    var defaultValueCache = {};
    var DOMProperty = {
      ID_ATTRIBUTE_NAME: 'data-reactid',
      properties: {},
      getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {} : null,
      _isCustomAttributeFunctions: [],
      isCustomAttribute: function(attributeName) {
        for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
          var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
          if (isCustomAttributeFn(attributeName)) {
            return true;
          }
        }
        return false;
      },
      getDefaultValueForProperty: function(nodeName, prop) {
        var nodeDefaults = defaultValueCache[nodeName];
        var testElement;
        if (!nodeDefaults) {
          defaultValueCache[nodeName] = nodeDefaults = {};
        }
        if (!(prop in nodeDefaults)) {
          testElement = document.createElement(nodeName);
          nodeDefaults[prop] = testElement[prop];
        }
        return nodeDefaults[prop];
      },
      injection: DOMPropertyInjection
    };
    module.exports = DOMProperty;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/EventPluginRegistry", ["npm:fbjs@0.6.1/lib/invariant", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var EventPluginOrder = null;
    var namesToPlugins = {};
    function recomputePluginOrdering() {
      if (!EventPluginOrder) {
        return;
      }
      for (var pluginName in namesToPlugins) {
        var PluginModule = namesToPlugins[pluginName];
        var pluginIndex = EventPluginOrder.indexOf(pluginName);
        !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : undefined;
        if (EventPluginRegistry.plugins[pluginIndex]) {
          continue;
        }
        !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : undefined;
        EventPluginRegistry.plugins[pluginIndex] = PluginModule;
        var publishedEvents = PluginModule.eventTypes;
        for (var eventName in publishedEvents) {
          !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : undefined;
        }
      }
    }
    function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
      !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : undefined;
      EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
      if (phasedRegistrationNames) {
        for (var phaseName in phasedRegistrationNames) {
          if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
            var phasedRegistrationName = phasedRegistrationNames[phaseName];
            publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
          }
        }
        return true;
      } else if (dispatchConfig.registrationName) {
        publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
        return true;
      }
      return false;
    }
    function publishRegistrationName(registrationName, PluginModule, eventName) {
      !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : undefined;
      EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
      EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
    }
    var EventPluginRegistry = {
      plugins: [],
      eventNameDispatchConfigs: {},
      registrationNameModules: {},
      registrationNameDependencies: {},
      injectEventPluginOrder: function(InjectedEventPluginOrder) {
        !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : undefined;
        EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
        recomputePluginOrdering();
      },
      injectEventPluginsByName: function(injectedNamesToPlugins) {
        var isOrderingDirty = false;
        for (var pluginName in injectedNamesToPlugins) {
          if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
            continue;
          }
          var PluginModule = injectedNamesToPlugins[pluginName];
          if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
            !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : undefined;
            namesToPlugins[pluginName] = PluginModule;
            isOrderingDirty = true;
          }
        }
        if (isOrderingDirty) {
          recomputePluginOrdering();
        }
      },
      getPluginModuleForEvent: function(event) {
        var dispatchConfig = event.dispatchConfig;
        if (dispatchConfig.registrationName) {
          return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
        }
        for (var phase in dispatchConfig.phasedRegistrationNames) {
          if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
            continue;
          }
          var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
          if (PluginModule) {
            return PluginModule;
          }
        }
        return null;
      },
      _resetEventPlugins: function() {
        EventPluginOrder = null;
        for (var pluginName in namesToPlugins) {
          if (namesToPlugins.hasOwnProperty(pluginName)) {
            delete namesToPlugins[pluginName];
          }
        }
        EventPluginRegistry.plugins.length = 0;
        var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
        for (var eventName in eventNameDispatchConfigs) {
          if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
            delete eventNameDispatchConfigs[eventName];
          }
        }
        var registrationNameModules = EventPluginRegistry.registrationNameModules;
        for (var registrationName in registrationNameModules) {
          if (registrationNameModules.hasOwnProperty(registrationName)) {
            delete registrationNameModules[registrationName];
          }
        }
      }
    };
    module.exports = EventPluginRegistry;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/EventConstants", ["npm:fbjs@0.6.1/lib/keyMirror"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var keyMirror = $__require('npm:fbjs@0.6.1/lib/keyMirror');
  var PropagationPhases = keyMirror({
    bubbled: null,
    captured: null
  });
  var topLevelTypes = keyMirror({
    topAbort: null,
    topBlur: null,
    topCanPlay: null,
    topCanPlayThrough: null,
    topChange: null,
    topClick: null,
    topCompositionEnd: null,
    topCompositionStart: null,
    topCompositionUpdate: null,
    topContextMenu: null,
    topCopy: null,
    topCut: null,
    topDoubleClick: null,
    topDrag: null,
    topDragEnd: null,
    topDragEnter: null,
    topDragExit: null,
    topDragLeave: null,
    topDragOver: null,
    topDragStart: null,
    topDrop: null,
    topDurationChange: null,
    topEmptied: null,
    topEncrypted: null,
    topEnded: null,
    topError: null,
    topFocus: null,
    topInput: null,
    topKeyDown: null,
    topKeyPress: null,
    topKeyUp: null,
    topLoad: null,
    topLoadedData: null,
    topLoadedMetadata: null,
    topLoadStart: null,
    topMouseDown: null,
    topMouseMove: null,
    topMouseOut: null,
    topMouseOver: null,
    topMouseUp: null,
    topPaste: null,
    topPause: null,
    topPlay: null,
    topPlaying: null,
    topProgress: null,
    topRateChange: null,
    topReset: null,
    topScroll: null,
    topSeeked: null,
    topSeeking: null,
    topSelectionChange: null,
    topStalled: null,
    topSubmit: null,
    topSuspend: null,
    topTextInput: null,
    topTimeUpdate: null,
    topTouchCancel: null,
    topTouchEnd: null,
    topTouchMove: null,
    topTouchStart: null,
    topVolumeChange: null,
    topWaiting: null,
    topWheel: null
  });
  var EventConstants = {
    topLevelTypes: topLevelTypes,
    PropagationPhases: PropagationPhases
  };
  module.exports = EventConstants;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/EventPluginUtils", ["npm:react@0.14.6/lib/EventConstants", "npm:react@0.14.6/lib/ReactErrorUtils", "npm:fbjs@0.6.1/lib/invariant", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var EventConstants = $__require('npm:react@0.14.6/lib/EventConstants');
    var ReactErrorUtils = $__require('npm:react@0.14.6/lib/ReactErrorUtils');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    var injection = {
      Mount: null,
      injectMount: function(InjectedMount) {
        injection.Mount = InjectedMount;
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(InjectedMount && InjectedMount.getNode && InjectedMount.getID, 'EventPluginUtils.injection.injectMount(...): Injected Mount ' + 'module is missing getNode or getID.') : undefined;
        }
      }
    };
    var topLevelTypes = EventConstants.topLevelTypes;
    function isEndish(topLevelType) {
      return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
    }
    function isMoveish(topLevelType) {
      return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
    }
    function isStartish(topLevelType) {
      return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
    }
    var validateEventDispatches;
    if (process.env.NODE_ENV !== 'production') {
      validateEventDispatches = function(event) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchIDs = event._dispatchIDs;
        var listenersIsArr = Array.isArray(dispatchListeners);
        var idsIsArr = Array.isArray(dispatchIDs);
        var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
        var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
        process.env.NODE_ENV !== 'production' ? warning(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : undefined;
      };
    }
    function executeDispatch(event, simulated, listener, domID) {
      var type = event.type || 'unknown-event';
      event.currentTarget = injection.Mount.getNode(domID);
      if (simulated) {
        ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event, domID);
      } else {
        ReactErrorUtils.invokeGuardedCallback(type, listener, event, domID);
      }
      event.currentTarget = null;
    }
    function executeDispatchesInOrder(event, simulated) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchIDs = event._dispatchIDs;
      if (process.env.NODE_ENV !== 'production') {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }
          executeDispatch(event, simulated, dispatchListeners[i], dispatchIDs[i]);
        }
      } else if (dispatchListeners) {
        executeDispatch(event, simulated, dispatchListeners, dispatchIDs);
      }
      event._dispatchListeners = null;
      event._dispatchIDs = null;
    }
    function executeDispatchesInOrderStopAtTrueImpl(event) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchIDs = event._dispatchIDs;
      if (process.env.NODE_ENV !== 'production') {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }
          if (dispatchListeners[i](event, dispatchIDs[i])) {
            return dispatchIDs[i];
          }
        }
      } else if (dispatchListeners) {
        if (dispatchListeners(event, dispatchIDs)) {
          return dispatchIDs;
        }
      }
      return null;
    }
    function executeDispatchesInOrderStopAtTrue(event) {
      var ret = executeDispatchesInOrderStopAtTrueImpl(event);
      event._dispatchIDs = null;
      event._dispatchListeners = null;
      return ret;
    }
    function executeDirectDispatch(event) {
      if (process.env.NODE_ENV !== 'production') {
        validateEventDispatches(event);
      }
      var dispatchListener = event._dispatchListeners;
      var dispatchID = event._dispatchIDs;
      !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : undefined;
      var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
      event._dispatchListeners = null;
      event._dispatchIDs = null;
      return res;
    }
    function hasDispatches(event) {
      return !!event._dispatchListeners;
    }
    var EventPluginUtils = {
      isEndish: isEndish,
      isMoveish: isMoveish,
      isStartish: isStartish,
      executeDirectDispatch: executeDirectDispatch,
      executeDispatchesInOrder: executeDispatchesInOrder,
      executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
      hasDispatches: hasDispatches,
      getNode: function(id) {
        return injection.Mount.getNode(id);
      },
      getID: function(node) {
        return injection.Mount.getID(node);
      },
      injection: injection
    };
    module.exports = EventPluginUtils;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactErrorUtils", ["github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var caughtError = null;
    function invokeGuardedCallback(name, func, a, b) {
      try {
        return func(a, b);
      } catch (x) {
        if (caughtError === null) {
          caughtError = x;
        }
        return undefined;
      }
    }
    var ReactErrorUtils = {
      invokeGuardedCallback: invokeGuardedCallback,
      invokeGuardedCallbackWithCatch: invokeGuardedCallback,
      rethrowCaughtError: function() {
        if (caughtError) {
          var error = caughtError;
          caughtError = null;
          throw error;
        }
      }
    };
    if (process.env.NODE_ENV !== 'production') {
      if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
        var fakeNode = document.createElement('react');
        ReactErrorUtils.invokeGuardedCallback = function(name, func, a, b) {
          var boundFunc = func.bind(null, a, b);
          var evtType = 'react-' + name;
          fakeNode.addEventListener(evtType, boundFunc, false);
          var evt = document.createEvent('Event');
          evt.initEvent(evtType, false, false);
          fakeNode.dispatchEvent(evt);
          fakeNode.removeEventListener(evtType, boundFunc, false);
        };
      }
    }
    module.exports = ReactErrorUtils;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/accumulateInto", ["npm:fbjs@0.6.1/lib/invariant", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    function accumulateInto(current, next) {
      !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(false) : undefined;
      if (current == null) {
        return next;
      }
      var currentIsArray = Array.isArray(current);
      var nextIsArray = Array.isArray(next);
      if (currentIsArray && nextIsArray) {
        current.push.apply(current, next);
        return current;
      }
      if (currentIsArray) {
        current.push(next);
        return current;
      }
      if (nextIsArray) {
        return [current].concat(next);
      }
      return [current, next];
    }
    module.exports = accumulateInto;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/forEachAccumulated", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var forEachAccumulated = function(arr, cb, scope) {
    if (Array.isArray(arr)) {
      arr.forEach(cb, scope);
    } else if (arr) {
      cb.call(scope, arr);
    }
  };
  module.exports = forEachAccumulated;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/EventPluginHub", ["npm:react@0.14.6/lib/EventPluginRegistry", "npm:react@0.14.6/lib/EventPluginUtils", "npm:react@0.14.6/lib/ReactErrorUtils", "npm:react@0.14.6/lib/accumulateInto", "npm:react@0.14.6/lib/forEachAccumulated", "npm:fbjs@0.6.1/lib/invariant", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var EventPluginRegistry = $__require('npm:react@0.14.6/lib/EventPluginRegistry');
    var EventPluginUtils = $__require('npm:react@0.14.6/lib/EventPluginUtils');
    var ReactErrorUtils = $__require('npm:react@0.14.6/lib/ReactErrorUtils');
    var accumulateInto = $__require('npm:react@0.14.6/lib/accumulateInto');
    var forEachAccumulated = $__require('npm:react@0.14.6/lib/forEachAccumulated');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    var listenerBank = {};
    var eventQueue = null;
    var executeDispatchesAndRelease = function(event, simulated) {
      if (event) {
        EventPluginUtils.executeDispatchesInOrder(event, simulated);
        if (!event.isPersistent()) {
          event.constructor.release(event);
        }
      }
    };
    var executeDispatchesAndReleaseSimulated = function(e) {
      return executeDispatchesAndRelease(e, true);
    };
    var executeDispatchesAndReleaseTopLevel = function(e) {
      return executeDispatchesAndRelease(e, false);
    };
    var InstanceHandle = null;
    function validateInstanceHandle() {
      var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;
      process.env.NODE_ENV !== 'production' ? warning(valid, 'InstanceHandle not injected before use!') : undefined;
    }
    var EventPluginHub = {
      injection: {
        injectMount: EventPluginUtils.injection.injectMount,
        injectInstanceHandle: function(InjectedInstanceHandle) {
          InstanceHandle = InjectedInstanceHandle;
          if (process.env.NODE_ENV !== 'production') {
            validateInstanceHandle();
          }
        },
        getInstanceHandle: function() {
          if (process.env.NODE_ENV !== 'production') {
            validateInstanceHandle();
          }
          return InstanceHandle;
        },
        injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
        injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
      },
      eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,
      registrationNameModules: EventPluginRegistry.registrationNameModules,
      putListener: function(id, registrationName, listener) {
        !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : invariant(false) : undefined;
        var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
        bankForRegistrationName[id] = listener;
        var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
        if (PluginModule && PluginModule.didPutListener) {
          PluginModule.didPutListener(id, registrationName, listener);
        }
      },
      getListener: function(id, registrationName) {
        var bankForRegistrationName = listenerBank[registrationName];
        return bankForRegistrationName && bankForRegistrationName[id];
      },
      deleteListener: function(id, registrationName) {
        var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
        if (PluginModule && PluginModule.willDeleteListener) {
          PluginModule.willDeleteListener(id, registrationName);
        }
        var bankForRegistrationName = listenerBank[registrationName];
        if (bankForRegistrationName) {
          delete bankForRegistrationName[id];
        }
      },
      deleteAllListeners: function(id) {
        for (var registrationName in listenerBank) {
          if (!listenerBank[registrationName][id]) {
            continue;
          }
          var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
          if (PluginModule && PluginModule.willDeleteListener) {
            PluginModule.willDeleteListener(id, registrationName);
          }
          delete listenerBank[registrationName][id];
        }
      },
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
        var events;
        var plugins = EventPluginRegistry.plugins;
        for (var i = 0; i < plugins.length; i++) {
          var possiblePlugin = plugins[i];
          if (possiblePlugin) {
            var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
            if (extractedEvents) {
              events = accumulateInto(events, extractedEvents);
            }
          }
        }
        return events;
      },
      enqueueEvents: function(events) {
        if (events) {
          eventQueue = accumulateInto(eventQueue, events);
        }
      },
      processEventQueue: function(simulated) {
        var processingEventQueue = eventQueue;
        eventQueue = null;
        if (simulated) {
          forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
        } else {
          forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
        }
        !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(false) : undefined;
        ReactErrorUtils.rethrowCaughtError();
      },
      __purge: function() {
        listenerBank = {};
      },
      __getListenerBank: function() {
        return listenerBank;
      }
    };
    module.exports = EventPluginHub;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactEventEmitterMixin", ["npm:react@0.14.6/lib/EventPluginHub"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var EventPluginHub = $__require('npm:react@0.14.6/lib/EventPluginHub');
  function runEventQueueInBatch(events) {
    EventPluginHub.enqueueEvents(events);
    EventPluginHub.processEventQueue(false);
  }
  var ReactEventEmitterMixin = {handleTopLevel: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
      var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
      runEventQueueInBatch(events);
    }};
  module.exports = ReactEventEmitterMixin;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ViewportMetrics", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ViewportMetrics = {
    currentScrollLeft: 0,
    currentScrollTop: 0,
    refreshScrollValues: function(scrollPosition) {
      ViewportMetrics.currentScrollLeft = scrollPosition.x;
      ViewportMetrics.currentScrollTop = scrollPosition.y;
    }
  };
  module.exports = ViewportMetrics;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/isEventSupported", ["npm:fbjs@0.6.1/lib/ExecutionEnvironment"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ExecutionEnvironment = $__require('npm:fbjs@0.6.1/lib/ExecutionEnvironment');
  var useHasFeature;
  if (ExecutionEnvironment.canUseDOM) {
    useHasFeature = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature('', '') !== true;
  }
  function isEventSupported(eventNameSuffix, capture) {
    if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
      return false;
    }
    var eventName = 'on' + eventNameSuffix;
    var isSupported = (eventName in document);
    if (!isSupported) {
      var element = document.createElement('div');
      element.setAttribute(eventName, 'return;');
      isSupported = typeof element[eventName] === 'function';
    }
    if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
      isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
    }
    return isSupported;
  }
  module.exports = isEventSupported;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactBrowserEventEmitter", ["npm:react@0.14.6/lib/EventConstants", "npm:react@0.14.6/lib/EventPluginHub", "npm:react@0.14.6/lib/EventPluginRegistry", "npm:react@0.14.6/lib/ReactEventEmitterMixin", "npm:react@0.14.6/lib/ReactPerf", "npm:react@0.14.6/lib/ViewportMetrics", "npm:react@0.14.6/lib/Object.assign", "npm:react@0.14.6/lib/isEventSupported", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var EventConstants = $__require('npm:react@0.14.6/lib/EventConstants');
    var EventPluginHub = $__require('npm:react@0.14.6/lib/EventPluginHub');
    var EventPluginRegistry = $__require('npm:react@0.14.6/lib/EventPluginRegistry');
    var ReactEventEmitterMixin = $__require('npm:react@0.14.6/lib/ReactEventEmitterMixin');
    var ReactPerf = $__require('npm:react@0.14.6/lib/ReactPerf');
    var ViewportMetrics = $__require('npm:react@0.14.6/lib/ViewportMetrics');
    var assign = $__require('npm:react@0.14.6/lib/Object.assign');
    var isEventSupported = $__require('npm:react@0.14.6/lib/isEventSupported');
    var alreadyListeningTo = {};
    var isMonitoringScrollValue = false;
    var reactTopListenersCounter = 0;
    var topEventMapping = {
      topAbort: 'abort',
      topBlur: 'blur',
      topCanPlay: 'canplay',
      topCanPlayThrough: 'canplaythrough',
      topChange: 'change',
      topClick: 'click',
      topCompositionEnd: 'compositionend',
      topCompositionStart: 'compositionstart',
      topCompositionUpdate: 'compositionupdate',
      topContextMenu: 'contextmenu',
      topCopy: 'copy',
      topCut: 'cut',
      topDoubleClick: 'dblclick',
      topDrag: 'drag',
      topDragEnd: 'dragend',
      topDragEnter: 'dragenter',
      topDragExit: 'dragexit',
      topDragLeave: 'dragleave',
      topDragOver: 'dragover',
      topDragStart: 'dragstart',
      topDrop: 'drop',
      topDurationChange: 'durationchange',
      topEmptied: 'emptied',
      topEncrypted: 'encrypted',
      topEnded: 'ended',
      topError: 'error',
      topFocus: 'focus',
      topInput: 'input',
      topKeyDown: 'keydown',
      topKeyPress: 'keypress',
      topKeyUp: 'keyup',
      topLoadedData: 'loadeddata',
      topLoadedMetadata: 'loadedmetadata',
      topLoadStart: 'loadstart',
      topMouseDown: 'mousedown',
      topMouseMove: 'mousemove',
      topMouseOut: 'mouseout',
      topMouseOver: 'mouseover',
      topMouseUp: 'mouseup',
      topPaste: 'paste',
      topPause: 'pause',
      topPlay: 'play',
      topPlaying: 'playing',
      topProgress: 'progress',
      topRateChange: 'ratechange',
      topScroll: 'scroll',
      topSeeked: 'seeked',
      topSeeking: 'seeking',
      topSelectionChange: 'selectionchange',
      topStalled: 'stalled',
      topSuspend: 'suspend',
      topTextInput: 'textInput',
      topTimeUpdate: 'timeupdate',
      topTouchCancel: 'touchcancel',
      topTouchEnd: 'touchend',
      topTouchMove: 'touchmove',
      topTouchStart: 'touchstart',
      topVolumeChange: 'volumechange',
      topWaiting: 'waiting',
      topWheel: 'wheel'
    };
    var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
    function getListeningForDocument(mountAt) {
      if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
        mountAt[topListenersIDKey] = reactTopListenersCounter++;
        alreadyListeningTo[mountAt[topListenersIDKey]] = {};
      }
      return alreadyListeningTo[mountAt[topListenersIDKey]];
    }
    var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {
      ReactEventListener: null,
      injection: {injectReactEventListener: function(ReactEventListener) {
          ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
          ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
        }},
      setEnabled: function(enabled) {
        if (ReactBrowserEventEmitter.ReactEventListener) {
          ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
        }
      },
      isEnabled: function() {
        return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
      },
      listenTo: function(registrationName, contentDocumentHandle) {
        var mountAt = contentDocumentHandle;
        var isListening = getListeningForDocument(mountAt);
        var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
        var topLevelTypes = EventConstants.topLevelTypes;
        for (var i = 0; i < dependencies.length; i++) {
          var dependency = dependencies[i];
          if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
            if (dependency === topLevelTypes.topWheel) {
              if (isEventSupported('wheel')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
              } else if (isEventSupported('mousewheel')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
              } else {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
              }
            } else if (dependency === topLevelTypes.topScroll) {
              if (isEventSupported('scroll', true)) {
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
              } else {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
              }
            } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
              if (isEventSupported('focus', true)) {
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
              } else if (isEventSupported('focusin')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
              }
              isListening[topLevelTypes.topBlur] = true;
              isListening[topLevelTypes.topFocus] = true;
            } else if (topEventMapping.hasOwnProperty(dependency)) {
              ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
            }
            isListening[dependency] = true;
          }
        }
      },
      trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
        return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
      },
      trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
        return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
      },
      ensureScrollValueMonitoring: function() {
        if (!isMonitoringScrollValue) {
          var refresh = ViewportMetrics.refreshScrollValues;
          ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
          isMonitoringScrollValue = true;
        }
      },
      eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,
      registrationNameModules: EventPluginHub.registrationNameModules,
      putListener: EventPluginHub.putListener,
      getListener: EventPluginHub.getListener,
      deleteListener: EventPluginHub.deleteListener,
      deleteAllListeners: EventPluginHub.deleteAllListeners
    });
    ReactPerf.measureMethods(ReactBrowserEventEmitter, 'ReactBrowserEventEmitter', {
      putListener: 'putListener',
      deleteListener: 'deleteListener'
    });
    module.exports = ReactBrowserEventEmitter;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactDOMFeatureFlags", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ReactDOMFeatureFlags = {useCreateElement: false};
  module.exports = ReactDOMFeatureFlags;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactRootIndex", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ReactRootIndexInjection = {injectCreateReactRootIndex: function(_createReactRootIndex) {
      ReactRootIndex.createReactRootIndex = _createReactRootIndex;
    }};
  var ReactRootIndex = {
    createReactRootIndex: null,
    injection: ReactRootIndexInjection
  };
  module.exports = ReactRootIndex;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactInstanceHandles", ["npm:react@0.14.6/lib/ReactRootIndex", "npm:fbjs@0.6.1/lib/invariant", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactRootIndex = $__require('npm:react@0.14.6/lib/ReactRootIndex');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var SEPARATOR = '.';
    var SEPARATOR_LENGTH = SEPARATOR.length;
    var MAX_TREE_DEPTH = 10000;
    function getReactRootIDString(index) {
      return SEPARATOR + index.toString(36);
    }
    function isBoundary(id, index) {
      return id.charAt(index) === SEPARATOR || index === id.length;
    }
    function isValidID(id) {
      return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;
    }
    function isAncestorIDOf(ancestorID, descendantID) {
      return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);
    }
    function getParentID(id) {
      return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
    }
    function getNextDescendantID(ancestorID, destinationID) {
      !(isValidID(ancestorID) && isValidID(destinationID)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;
      !isAncestorIDOf(ancestorID, destinationID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;
      if (ancestorID === destinationID) {
        return ancestorID;
      }
      var start = ancestorID.length + SEPARATOR_LENGTH;
      var i;
      for (i = start; i < destinationID.length; i++) {
        if (isBoundary(destinationID, i)) {
          break;
        }
      }
      return destinationID.substr(0, i);
    }
    function getFirstCommonAncestorID(oneID, twoID) {
      var minLength = Math.min(oneID.length, twoID.length);
      if (minLength === 0) {
        return '';
      }
      var lastCommonMarkerIndex = 0;
      for (var i = 0; i <= minLength; i++) {
        if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
          lastCommonMarkerIndex = i;
        } else if (oneID.charAt(i) !== twoID.charAt(i)) {
          break;
        }
      }
      var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
      !isValidID(longestCommonID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;
      return longestCommonID;
    }
    function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
      start = start || '';
      stop = stop || '';
      !(start !== stop) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;
      var traverseUp = isAncestorIDOf(stop, start);
      !(traverseUp || isAncestorIDOf(start, stop)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined;
      var depth = 0;
      var traverse = traverseUp ? getParentID : getNextDescendantID;
      for (var id = start; ; id = traverse(id, stop)) {
        var ret;
        if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
          ret = cb(id, traverseUp, arg);
        }
        if (ret === false || id === stop) {
          break;
        }
        !(depth++ < MAX_TREE_DEPTH) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop, id) : invariant(false) : undefined;
      }
    }
    var ReactInstanceHandles = {
      createReactRootID: function() {
        return getReactRootIDString(ReactRootIndex.createReactRootIndex());
      },
      createReactID: function(rootID, name) {
        return rootID + name;
      },
      getReactRootIDFromNodeID: function(id) {
        if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
          var index = id.indexOf(SEPARATOR, 1);
          return index > -1 ? id.substr(0, index) : id;
        }
        return null;
      },
      traverseEnterLeave: function(leaveID, enterID, cb, upArg, downArg) {
        var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
        if (ancestorID !== leaveID) {
          traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
        }
        if (ancestorID !== enterID) {
          traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
        }
      },
      traverseTwoPhase: function(targetID, cb, arg) {
        if (targetID) {
          traverseParentPath('', targetID, cb, arg, true, false);
          traverseParentPath(targetID, '', cb, arg, false, true);
        }
      },
      traverseTwoPhaseSkipTarget: function(targetID, cb, arg) {
        if (targetID) {
          traverseParentPath('', targetID, cb, arg, true, true);
          traverseParentPath(targetID, '', cb, arg, true, true);
        }
      },
      traverseAncestors: function(targetID, cb, arg) {
        traverseParentPath('', targetID, cb, arg, true, false);
      },
      getFirstCommonAncestorID: getFirstCommonAncestorID,
      _getNextDescendantID: getNextDescendantID,
      isAncestorIDOf: isAncestorIDOf,
      SEPARATOR: SEPARATOR
    };
    module.exports = ReactInstanceHandles;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/adler32", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var MOD = 65521;
  function adler32(data) {
    var a = 1;
    var b = 0;
    var i = 0;
    var l = data.length;
    var m = l & ~0x3;
    while (i < m) {
      for (; i < Math.min(i + 4096, m); i += 4) {
        b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
      }
      a %= MOD;
      b %= MOD;
    }
    for (; i < l; i++) {
      b += a += data.charCodeAt(i);
    }
    a %= MOD;
    b %= MOD;
    return a | b << 16;
  }
  module.exports = adler32;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactMarkupChecksum", ["npm:react@0.14.6/lib/adler32"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var adler32 = $__require('npm:react@0.14.6/lib/adler32');
  var TAG_END = /\/?>/;
  var ReactMarkupChecksum = {
    CHECKSUM_ATTR_NAME: 'data-react-checksum',
    addChecksumToMarkup: function(markup) {
      var checksum = adler32(markup);
      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
    },
    canReuseMarkup: function(markup, element) {
      var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
      existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
      var markupChecksum = adler32(markup);
      return markupChecksum === existingChecksum;
    }
  };
  module.exports = ReactMarkupChecksum;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/isNode", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function isNode(object) {
    return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
  }
  module.exports = isNode;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/isTextNode", ["npm:fbjs@0.6.1/lib/isNode"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isNode = $__require('npm:fbjs@0.6.1/lib/isNode');
  function isTextNode(object) {
    return isNode(object) && object.nodeType == 3;
  }
  module.exports = isTextNode;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/containsNode", ["npm:fbjs@0.6.1/lib/isTextNode"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isTextNode = $__require('npm:fbjs@0.6.1/lib/isTextNode');
  function containsNode(_x, _x2) {
    var _again = true;
    _function: while (_again) {
      var outerNode = _x,
          innerNode = _x2;
      _again = false;
      if (!outerNode || !innerNode) {
        return false;
      } else if (outerNode === innerNode) {
        return true;
      } else if (isTextNode(outerNode)) {
        return false;
      } else if (isTextNode(innerNode)) {
        _x = outerNode;
        _x2 = innerNode.parentNode;
        _again = true;
        continue _function;
      } else if (outerNode.contains) {
        return outerNode.contains(innerNode);
      } else if (outerNode.compareDocumentPosition) {
        return !!(outerNode.compareDocumentPosition(innerNode) & 16);
      } else {
        return false;
      }
    }
  }
  module.exports = containsNode;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactComponentEnvironment", ["npm:fbjs@0.6.1/lib/invariant", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var injected = false;
    var ReactComponentEnvironment = {
      unmountIDFromEnvironment: null,
      replaceNodeWithMarkupByID: null,
      processChildrenUpdates: null,
      injection: {injectEnvironment: function(environment) {
          !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : invariant(false) : undefined;
          ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
          ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID;
          ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
          injected = true;
        }}
    };
    module.exports = ReactComponentEnvironment;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/keyMirror", ["npm:fbjs@0.6.1/lib/invariant", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var keyMirror = function(obj) {
      var ret = {};
      var key;
      !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : undefined;
      for (key in obj) {
        if (!obj.hasOwnProperty(key)) {
          continue;
        }
        ret[key] = key;
      }
      return ret;
    };
    module.exports = keyMirror;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactPropTypeLocations", ["npm:fbjs@0.6.1/lib/keyMirror"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var keyMirror = $__require('npm:fbjs@0.6.1/lib/keyMirror');
  var ReactPropTypeLocations = keyMirror({
    prop: null,
    context: null,
    childContext: null
  });
  module.exports = ReactPropTypeLocations;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactPropTypeLocationNames", ["github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactPropTypeLocationNames = {};
    if (process.env.NODE_ENV !== 'production') {
      ReactPropTypeLocationNames = {
        prop: 'prop',
        context: 'context',
        childContext: 'child context'
      };
    }
    module.exports = ReactPropTypeLocationNames;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactInstanceMap", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ReactInstanceMap = {
    remove: function(key) {
      key._reactInternalInstance = undefined;
    },
    get: function(key) {
      return key._reactInternalInstance;
    },
    has: function(key) {
      return key._reactInternalInstance !== undefined;
    },
    set: function(key, value) {
      key._reactInternalInstance = value;
    }
  };
  module.exports = ReactInstanceMap;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/CallbackQueue", ["npm:react@0.14.6/lib/PooledClass", "npm:react@0.14.6/lib/Object.assign", "npm:fbjs@0.6.1/lib/invariant", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var PooledClass = $__require('npm:react@0.14.6/lib/PooledClass');
    var assign = $__require('npm:react@0.14.6/lib/Object.assign');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    function CallbackQueue() {
      this._callbacks = null;
      this._contexts = null;
    }
    assign(CallbackQueue.prototype, {
      enqueue: function(callback, context) {
        this._callbacks = this._callbacks || [];
        this._contexts = this._contexts || [];
        this._callbacks.push(callback);
        this._contexts.push(context);
      },
      notifyAll: function() {
        var callbacks = this._callbacks;
        var contexts = this._contexts;
        if (callbacks) {
          !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : invariant(false) : undefined;
          this._callbacks = null;
          this._contexts = null;
          for (var i = 0; i < callbacks.length; i++) {
            callbacks[i].call(contexts[i]);
          }
          callbacks.length = 0;
          contexts.length = 0;
        }
      },
      reset: function() {
        this._callbacks = null;
        this._contexts = null;
      },
      destructor: function() {
        this.reset();
      }
    });
    PooledClass.addPoolingTo(CallbackQueue);
    module.exports = CallbackQueue;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/PooledClass", ["npm:fbjs@0.6.1/lib/invariant", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var oneArgumentPooler = function(copyFieldsFrom) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, copyFieldsFrom);
        return instance;
      } else {
        return new Klass(copyFieldsFrom);
      }
    };
    var twoArgumentPooler = function(a1, a2) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2);
        return instance;
      } else {
        return new Klass(a1, a2);
      }
    };
    var threeArgumentPooler = function(a1, a2, a3) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3);
        return instance;
      } else {
        return new Klass(a1, a2, a3);
      }
    };
    var fourArgumentPooler = function(a1, a2, a3, a4) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3, a4);
        return instance;
      } else {
        return new Klass(a1, a2, a3, a4);
      }
    };
    var fiveArgumentPooler = function(a1, a2, a3, a4, a5) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3, a4, a5);
        return instance;
      } else {
        return new Klass(a1, a2, a3, a4, a5);
      }
    };
    var standardReleaser = function(instance) {
      var Klass = this;
      !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : invariant(false) : undefined;
      instance.destructor();
      if (Klass.instancePool.length < Klass.poolSize) {
        Klass.instancePool.push(instance);
      }
    };
    var DEFAULT_POOL_SIZE = 10;
    var DEFAULT_POOLER = oneArgumentPooler;
    var addPoolingTo = function(CopyConstructor, pooler) {
      var NewKlass = CopyConstructor;
      NewKlass.instancePool = [];
      NewKlass.getPooled = pooler || DEFAULT_POOLER;
      if (!NewKlass.poolSize) {
        NewKlass.poolSize = DEFAULT_POOL_SIZE;
      }
      NewKlass.release = standardReleaser;
      return NewKlass;
    };
    var PooledClass = {
      addPoolingTo: addPoolingTo,
      oneArgumentPooler: oneArgumentPooler,
      twoArgumentPooler: twoArgumentPooler,
      threeArgumentPooler: threeArgumentPooler,
      fourArgumentPooler: fourArgumentPooler,
      fiveArgumentPooler: fiveArgumentPooler
    };
    module.exports = PooledClass;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactPerf", ["github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactPerf = {
      enableMeasure: false,
      storedMeasure: _noMeasure,
      measureMethods: function(object, objectName, methodNames) {
        if (process.env.NODE_ENV !== 'production') {
          for (var key in methodNames) {
            if (!methodNames.hasOwnProperty(key)) {
              continue;
            }
            object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);
          }
        }
      },
      measure: function(objName, fnName, func) {
        if (process.env.NODE_ENV !== 'production') {
          var measuredFunc = null;
          var wrapper = function() {
            if (ReactPerf.enableMeasure) {
              if (!measuredFunc) {
                measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
              }
              return measuredFunc.apply(this, arguments);
            }
            return func.apply(this, arguments);
          };
          wrapper.displayName = objName + '_' + fnName;
          return wrapper;
        }
        return func;
      },
      injection: {injectMeasure: function(measure) {
          ReactPerf.storedMeasure = measure;
        }}
    };
    function _noMeasure(objName, fnName, func) {
      return func;
    }
    module.exports = ReactPerf;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/Transaction", ["npm:fbjs@0.6.1/lib/invariant", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var Mixin = {
      reinitializeTransaction: function() {
        this.transactionWrappers = this.getTransactionWrappers();
        if (this.wrapperInitData) {
          this.wrapperInitData.length = 0;
        } else {
          this.wrapperInitData = [];
        }
        this._isInTransaction = false;
      },
      _isInTransaction: false,
      getTransactionWrappers: null,
      isInTransaction: function() {
        return !!this._isInTransaction;
      },
      perform: function(method, scope, a, b, c, d, e, f) {
        !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(false) : undefined;
        var errorThrown;
        var ret;
        try {
          this._isInTransaction = true;
          errorThrown = true;
          this.initializeAll(0);
          ret = method.call(scope, a, b, c, d, e, f);
          errorThrown = false;
        } finally {
          try {
            if (errorThrown) {
              try {
                this.closeAll(0);
              } catch (err) {}
            } else {
              this.closeAll(0);
            }
          } finally {
            this._isInTransaction = false;
          }
        }
        return ret;
      },
      initializeAll: function(startIndex) {
        var transactionWrappers = this.transactionWrappers;
        for (var i = startIndex; i < transactionWrappers.length; i++) {
          var wrapper = transactionWrappers[i];
          try {
            this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
            this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
          } finally {
            if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
              try {
                this.initializeAll(i + 1);
              } catch (err) {}
            }
          }
        }
      },
      closeAll: function(startIndex) {
        !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(false) : undefined;
        var transactionWrappers = this.transactionWrappers;
        for (var i = startIndex; i < transactionWrappers.length; i++) {
          var wrapper = transactionWrappers[i];
          var initData = this.wrapperInitData[i];
          var errorThrown;
          try {
            errorThrown = true;
            if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
              wrapper.close.call(this, initData);
            }
            errorThrown = false;
          } finally {
            if (errorThrown) {
              try {
                this.closeAll(i + 1);
              } catch (e) {}
            }
          }
        }
        this.wrapperInitData.length = 0;
      }
    };
    var Transaction = {
      Mixin: Mixin,
      OBSERVED_ERROR: {}
    };
    module.exports = Transaction;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactUpdates", ["npm:react@0.14.6/lib/CallbackQueue", "npm:react@0.14.6/lib/PooledClass", "npm:react@0.14.6/lib/ReactPerf", "npm:react@0.14.6/lib/ReactReconciler", "npm:react@0.14.6/lib/Transaction", "npm:react@0.14.6/lib/Object.assign", "npm:fbjs@0.6.1/lib/invariant", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var CallbackQueue = $__require('npm:react@0.14.6/lib/CallbackQueue');
    var PooledClass = $__require('npm:react@0.14.6/lib/PooledClass');
    var ReactPerf = $__require('npm:react@0.14.6/lib/ReactPerf');
    var ReactReconciler = $__require('npm:react@0.14.6/lib/ReactReconciler');
    var Transaction = $__require('npm:react@0.14.6/lib/Transaction');
    var assign = $__require('npm:react@0.14.6/lib/Object.assign');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var dirtyComponents = [];
    var asapCallbackQueue = CallbackQueue.getPooled();
    var asapEnqueued = false;
    var batchingStrategy = null;
    function ensureInjected() {
      !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;
    }
    var NESTED_UPDATES = {
      initialize: function() {
        this.dirtyComponentsLength = dirtyComponents.length;
      },
      close: function() {
        if (this.dirtyComponentsLength !== dirtyComponents.length) {
          dirtyComponents.splice(0, this.dirtyComponentsLength);
          flushBatchedUpdates();
        } else {
          dirtyComponents.length = 0;
        }
      }
    };
    var UPDATE_QUEUEING = {
      initialize: function() {
        this.callbackQueue.reset();
      },
      close: function() {
        this.callbackQueue.notifyAll();
      }
    };
    var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
    function ReactUpdatesFlushTransaction() {
      this.reinitializeTransaction();
      this.dirtyComponentsLength = null;
      this.callbackQueue = CallbackQueue.getPooled();
      this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(false);
    }
    assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
      getTransactionWrappers: function() {
        return TRANSACTION_WRAPPERS;
      },
      destructor: function() {
        this.dirtyComponentsLength = null;
        CallbackQueue.release(this.callbackQueue);
        this.callbackQueue = null;
        ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
        this.reconcileTransaction = null;
      },
      perform: function(method, scope, a) {
        return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
      }
    });
    PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
    function batchedUpdates(callback, a, b, c, d, e) {
      ensureInjected();
      batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
    }
    function mountOrderComparator(c1, c2) {
      return c1._mountOrder - c2._mountOrder;
    }
    function runBatchedUpdates(transaction) {
      var len = transaction.dirtyComponentsLength;
      !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;
      dirtyComponents.sort(mountOrderComparator);
      for (var i = 0; i < len; i++) {
        var component = dirtyComponents[i];
        var callbacks = component._pendingCallbacks;
        component._pendingCallbacks = null;
        ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);
        if (callbacks) {
          for (var j = 0; j < callbacks.length; j++) {
            transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
          }
        }
      }
    }
    var flushBatchedUpdates = function() {
      while (dirtyComponents.length || asapEnqueued) {
        if (dirtyComponents.length) {
          var transaction = ReactUpdatesFlushTransaction.getPooled();
          transaction.perform(runBatchedUpdates, null, transaction);
          ReactUpdatesFlushTransaction.release(transaction);
        }
        if (asapEnqueued) {
          asapEnqueued = false;
          var queue = asapCallbackQueue;
          asapCallbackQueue = CallbackQueue.getPooled();
          queue.notifyAll();
          CallbackQueue.release(queue);
        }
      }
    };
    flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);
    function enqueueUpdate(component) {
      ensureInjected();
      if (!batchingStrategy.isBatchingUpdates) {
        batchingStrategy.batchedUpdates(enqueueUpdate, component);
        return;
      }
      dirtyComponents.push(component);
    }
    function asap(callback, context) {
      !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;
      asapCallbackQueue.enqueue(callback, context);
      asapEnqueued = true;
    }
    var ReactUpdatesInjection = {
      injectReconcileTransaction: function(ReconcileTransaction) {
        !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;
        ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
      },
      injectBatchingStrategy: function(_batchingStrategy) {
        !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;
        !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;
        !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;
        batchingStrategy = _batchingStrategy;
      }
    };
    var ReactUpdates = {
      ReactReconcileTransaction: null,
      batchedUpdates: batchedUpdates,
      enqueueUpdate: enqueueUpdate,
      flushBatchedUpdates: flushBatchedUpdates,
      injection: ReactUpdatesInjection,
      asap: asap
    };
    module.exports = ReactUpdates;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactUpdateQueue", ["npm:react@0.14.6/lib/ReactCurrentOwner", "npm:react@0.14.6/lib/ReactElement", "npm:react@0.14.6/lib/ReactInstanceMap", "npm:react@0.14.6/lib/ReactUpdates", "npm:react@0.14.6/lib/Object.assign", "npm:fbjs@0.6.1/lib/invariant", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactCurrentOwner = $__require('npm:react@0.14.6/lib/ReactCurrentOwner');
    var ReactElement = $__require('npm:react@0.14.6/lib/ReactElement');
    var ReactInstanceMap = $__require('npm:react@0.14.6/lib/ReactInstanceMap');
    var ReactUpdates = $__require('npm:react@0.14.6/lib/ReactUpdates');
    var assign = $__require('npm:react@0.14.6/lib/Object.assign');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    function enqueueUpdate(internalInstance) {
      ReactUpdates.enqueueUpdate(internalInstance);
    }
    function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
      var internalInstance = ReactInstanceMap.get(publicInstance);
      if (!internalInstance) {
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : undefined;
        }
        return null;
      }
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : undefined;
      }
      return internalInstance;
    }
    var ReactUpdateQueue = {
      isMounted: function(publicInstance) {
        if (process.env.NODE_ENV !== 'production') {
          var owner = ReactCurrentOwner.current;
          if (owner !== null) {
            process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
            owner._warnedAboutRefsInRender = true;
          }
        }
        var internalInstance = ReactInstanceMap.get(publicInstance);
        if (internalInstance) {
          return !!internalInstance._renderedComponent;
        } else {
          return false;
        }
      },
      enqueueCallback: function(publicInstance, callback) {
        !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
        if (!internalInstance) {
          return null;
        }
        if (internalInstance._pendingCallbacks) {
          internalInstance._pendingCallbacks.push(callback);
        } else {
          internalInstance._pendingCallbacks = [callback];
        }
        enqueueUpdate(internalInstance);
      },
      enqueueCallbackInternal: function(internalInstance, callback) {
        !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
        if (internalInstance._pendingCallbacks) {
          internalInstance._pendingCallbacks.push(callback);
        } else {
          internalInstance._pendingCallbacks = [callback];
        }
        enqueueUpdate(internalInstance);
      },
      enqueueForceUpdate: function(publicInstance) {
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
        if (!internalInstance) {
          return;
        }
        internalInstance._pendingForceUpdate = true;
        enqueueUpdate(internalInstance);
      },
      enqueueReplaceState: function(publicInstance, completeState) {
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
        if (!internalInstance) {
          return;
        }
        internalInstance._pendingStateQueue = [completeState];
        internalInstance._pendingReplaceState = true;
        enqueueUpdate(internalInstance);
      },
      enqueueSetState: function(publicInstance, partialState) {
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
        if (!internalInstance) {
          return;
        }
        var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
        queue.push(partialState);
        enqueueUpdate(internalInstance);
      },
      enqueueSetProps: function(publicInstance, partialProps) {
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');
        if (!internalInstance) {
          return;
        }
        ReactUpdateQueue.enqueueSetPropsInternal(internalInstance, partialProps);
      },
      enqueueSetPropsInternal: function(internalInstance, partialProps) {
        var topLevelWrapper = internalInstance._topLevelWrapper;
        !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;
        var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
        var element = wrapElement.props;
        var props = assign({}, element.props, partialProps);
        topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));
        enqueueUpdate(topLevelWrapper);
      },
      enqueueReplaceProps: function(publicInstance, props) {
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');
        if (!internalInstance) {
          return;
        }
        ReactUpdateQueue.enqueueReplacePropsInternal(internalInstance, props);
      },
      enqueueReplacePropsInternal: function(internalInstance, props) {
        var topLevelWrapper = internalInstance._topLevelWrapper;
        !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;
        var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
        var element = wrapElement.props;
        topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));
        enqueueUpdate(topLevelWrapper);
      },
      enqueueElementInternal: function(internalInstance, newElement) {
        internalInstance._pendingElement = newElement;
        enqueueUpdate(internalInstance);
      }
    };
    module.exports = ReactUpdateQueue;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/emptyObject", ["github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var emptyObject = {};
    if (process.env.NODE_ENV !== 'production') {
      Object.freeze(emptyObject);
    }
    module.exports = emptyObject;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactCompositeComponent", ["npm:react@0.14.6/lib/ReactComponentEnvironment", "npm:react@0.14.6/lib/ReactCurrentOwner", "npm:react@0.14.6/lib/ReactElement", "npm:react@0.14.6/lib/ReactInstanceMap", "npm:react@0.14.6/lib/ReactPerf", "npm:react@0.14.6/lib/ReactPropTypeLocations", "npm:react@0.14.6/lib/ReactPropTypeLocationNames", "npm:react@0.14.6/lib/ReactReconciler", "npm:react@0.14.6/lib/ReactUpdateQueue", "npm:react@0.14.6/lib/Object.assign", "npm:fbjs@0.6.1/lib/emptyObject", "npm:fbjs@0.6.1/lib/invariant", "npm:react@0.14.6/lib/shouldUpdateReactComponent", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactComponentEnvironment = $__require('npm:react@0.14.6/lib/ReactComponentEnvironment');
    var ReactCurrentOwner = $__require('npm:react@0.14.6/lib/ReactCurrentOwner');
    var ReactElement = $__require('npm:react@0.14.6/lib/ReactElement');
    var ReactInstanceMap = $__require('npm:react@0.14.6/lib/ReactInstanceMap');
    var ReactPerf = $__require('npm:react@0.14.6/lib/ReactPerf');
    var ReactPropTypeLocations = $__require('npm:react@0.14.6/lib/ReactPropTypeLocations');
    var ReactPropTypeLocationNames = $__require('npm:react@0.14.6/lib/ReactPropTypeLocationNames');
    var ReactReconciler = $__require('npm:react@0.14.6/lib/ReactReconciler');
    var ReactUpdateQueue = $__require('npm:react@0.14.6/lib/ReactUpdateQueue');
    var assign = $__require('npm:react@0.14.6/lib/Object.assign');
    var emptyObject = $__require('npm:fbjs@0.6.1/lib/emptyObject');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var shouldUpdateReactComponent = $__require('npm:react@0.14.6/lib/shouldUpdateReactComponent');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    function getDeclarationErrorAddendum(component) {
      var owner = component._currentElement._owner || null;
      if (owner) {
        var name = owner.getName();
        if (name) {
          return ' Check the render method of `' + name + '`.';
        }
      }
      return '';
    }
    function StatelessComponent(Component) {}
    StatelessComponent.prototype.render = function() {
      var Component = ReactInstanceMap.get(this)._currentElement.type;
      return Component(this.props, this.context, this.updater);
    };
    var nextMountID = 1;
    var ReactCompositeComponentMixin = {
      construct: function(element) {
        this._currentElement = element;
        this._rootNodeID = null;
        this._instance = null;
        this._pendingElement = null;
        this._pendingStateQueue = null;
        this._pendingReplaceState = false;
        this._pendingForceUpdate = false;
        this._renderedComponent = null;
        this._context = null;
        this._mountOrder = 0;
        this._topLevelWrapper = null;
        this._pendingCallbacks = null;
      },
      mountComponent: function(rootID, transaction, context) {
        this._context = context;
        this._mountOrder = nextMountID++;
        this._rootNodeID = rootID;
        var publicProps = this._processProps(this._currentElement.props);
        var publicContext = this._processContext(context);
        var Component = this._currentElement.type;
        var inst;
        var renderedElement;
        var canInstantiate = ('prototype' in Component);
        if (canInstantiate) {
          if (process.env.NODE_ENV !== 'production') {
            ReactCurrentOwner.current = this;
            try {
              inst = new Component(publicProps, publicContext, ReactUpdateQueue);
            } finally {
              ReactCurrentOwner.current = null;
            }
          } else {
            inst = new Component(publicProps, publicContext, ReactUpdateQueue);
          }
        }
        if (!canInstantiate || inst === null || inst === false || ReactElement.isValidElement(inst)) {
          renderedElement = inst;
          inst = new StatelessComponent(Component);
        }
        if (process.env.NODE_ENV !== 'production') {
          if (inst.render == null) {
            process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`, returned ' + 'null/false from a stateless component, or tried to render an ' + 'element whose type is a function that isn\'t a React component.', Component.displayName || Component.name || 'Component') : undefined;
          } else {
            process.env.NODE_ENV !== 'production' ? warning(Component.prototype && Component.prototype.isReactComponent || !canInstantiate || !(inst instanceof Component), '%s(...): React component classes must extend React.Component.', Component.displayName || Component.name || 'Component') : undefined;
          }
        }
        inst.props = publicProps;
        inst.context = publicContext;
        inst.refs = emptyObject;
        inst.updater = ReactUpdateQueue;
        this._instance = inst;
        ReactInstanceMap.set(inst, this);
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : undefined;
          process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : undefined;
          process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : undefined;
          process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : undefined;
          process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : undefined;
          process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : undefined;
          process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : undefined;
        }
        var initialState = inst.state;
        if (initialState === undefined) {
          inst.state = initialState = null;
        }
        !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
        this._pendingStateQueue = null;
        this._pendingReplaceState = false;
        this._pendingForceUpdate = false;
        if (inst.componentWillMount) {
          inst.componentWillMount();
          if (this._pendingStateQueue) {
            inst.state = this._processPendingState(inst.props, inst.context);
          }
        }
        if (renderedElement === undefined) {
          renderedElement = this._renderValidatedComponent();
        }
        this._renderedComponent = this._instantiateReactComponent(renderedElement);
        var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));
        if (inst.componentDidMount) {
          transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
        }
        return markup;
      },
      unmountComponent: function() {
        var inst = this._instance;
        if (inst.componentWillUnmount) {
          inst.componentWillUnmount();
        }
        ReactReconciler.unmountComponent(this._renderedComponent);
        this._renderedComponent = null;
        this._instance = null;
        this._pendingStateQueue = null;
        this._pendingReplaceState = false;
        this._pendingForceUpdate = false;
        this._pendingCallbacks = null;
        this._pendingElement = null;
        this._context = null;
        this._rootNodeID = null;
        this._topLevelWrapper = null;
        ReactInstanceMap.remove(inst);
      },
      _maskContext: function(context) {
        var maskedContext = null;
        var Component = this._currentElement.type;
        var contextTypes = Component.contextTypes;
        if (!contextTypes) {
          return emptyObject;
        }
        maskedContext = {};
        for (var contextName in contextTypes) {
          maskedContext[contextName] = context[contextName];
        }
        return maskedContext;
      },
      _processContext: function(context) {
        var maskedContext = this._maskContext(context);
        if (process.env.NODE_ENV !== 'production') {
          var Component = this._currentElement.type;
          if (Component.contextTypes) {
            this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
          }
        }
        return maskedContext;
      },
      _processChildContext: function(currentContext) {
        var Component = this._currentElement.type;
        var inst = this._instance;
        var childContext = inst.getChildContext && inst.getChildContext();
        if (childContext) {
          !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
          if (process.env.NODE_ENV !== 'production') {
            this._checkPropTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
          }
          for (var name in childContext) {
            !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : undefined;
          }
          return assign({}, currentContext, childContext);
        }
        return currentContext;
      },
      _processProps: function(newProps) {
        if (process.env.NODE_ENV !== 'production') {
          var Component = this._currentElement.type;
          if (Component.propTypes) {
            this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);
          }
        }
        return newProps;
      },
      _checkPropTypes: function(propTypes, props, location) {
        var componentName = this.getName();
        for (var propName in propTypes) {
          if (propTypes.hasOwnProperty(propName)) {
            var error;
            try {
              !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
              error = propTypes[propName](props, propName, componentName, location);
            } catch (ex) {
              error = ex;
            }
            if (error instanceof Error) {
              var addendum = getDeclarationErrorAddendum(this);
              if (location === ReactPropTypeLocations.prop) {
                process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : undefined;
              } else {
                process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : undefined;
              }
            }
          }
        }
      },
      receiveComponent: function(nextElement, transaction, nextContext) {
        var prevElement = this._currentElement;
        var prevContext = this._context;
        this._pendingElement = null;
        this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
      },
      performUpdateIfNecessary: function(transaction) {
        if (this._pendingElement != null) {
          ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);
        }
        if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
          this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
        }
      },
      updateComponent: function(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
        var inst = this._instance;
        var nextContext = this._context === nextUnmaskedContext ? inst.context : this._processContext(nextUnmaskedContext);
        var nextProps;
        if (prevParentElement === nextParentElement) {
          nextProps = nextParentElement.props;
        } else {
          nextProps = this._processProps(nextParentElement.props);
          if (inst.componentWillReceiveProps) {
            inst.componentWillReceiveProps(nextProps, nextContext);
          }
        }
        var nextState = this._processPendingState(nextProps, nextContext);
        var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : undefined;
        }
        if (shouldUpdate) {
          this._pendingForceUpdate = false;
          this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
        } else {
          this._currentElement = nextParentElement;
          this._context = nextUnmaskedContext;
          inst.props = nextProps;
          inst.state = nextState;
          inst.context = nextContext;
        }
      },
      _processPendingState: function(props, context) {
        var inst = this._instance;
        var queue = this._pendingStateQueue;
        var replace = this._pendingReplaceState;
        this._pendingReplaceState = false;
        this._pendingStateQueue = null;
        if (!queue) {
          return inst.state;
        }
        if (replace && queue.length === 1) {
          return queue[0];
        }
        var nextState = assign({}, replace ? queue[0] : inst.state);
        for (var i = replace ? 1 : 0; i < queue.length; i++) {
          var partial = queue[i];
          assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
        }
        return nextState;
      },
      _performComponentUpdate: function(nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
        var inst = this._instance;
        var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
        var prevProps;
        var prevState;
        var prevContext;
        if (hasComponentDidUpdate) {
          prevProps = inst.props;
          prevState = inst.state;
          prevContext = inst.context;
        }
        if (inst.componentWillUpdate) {
          inst.componentWillUpdate(nextProps, nextState, nextContext);
        }
        this._currentElement = nextElement;
        this._context = unmaskedContext;
        inst.props = nextProps;
        inst.state = nextState;
        inst.context = nextContext;
        this._updateRenderedComponent(transaction, unmaskedContext);
        if (hasComponentDidUpdate) {
          transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
        }
      },
      _updateRenderedComponent: function(transaction, context) {
        var prevComponentInstance = this._renderedComponent;
        var prevRenderedElement = prevComponentInstance._currentElement;
        var nextRenderedElement = this._renderValidatedComponent();
        if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
          ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
        } else {
          var thisID = this._rootNodeID;
          var prevComponentID = prevComponentInstance._rootNodeID;
          ReactReconciler.unmountComponent(prevComponentInstance);
          this._renderedComponent = this._instantiateReactComponent(nextRenderedElement);
          var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));
          this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
        }
      },
      _replaceNodeWithMarkupByID: function(prevComponentID, nextMarkup) {
        ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
      },
      _renderValidatedComponentWithoutOwnerOrContext: function() {
        var inst = this._instance;
        var renderedComponent = inst.render();
        if (process.env.NODE_ENV !== 'production') {
          if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {
            renderedComponent = null;
          }
        }
        return renderedComponent;
      },
      _renderValidatedComponent: function() {
        var renderedComponent;
        ReactCurrentOwner.current = this;
        try {
          renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
        } finally {
          ReactCurrentOwner.current = null;
        }
        !(renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
        return renderedComponent;
      },
      attachRef: function(ref, component) {
        var inst = this.getPublicInstance();
        !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : invariant(false) : undefined;
        var publicComponentInstance = component.getPublicInstance();
        if (process.env.NODE_ENV !== 'production') {
          var componentName = component && component.getName ? component.getName() : 'a component';
          process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : undefined;
        }
        var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
        refs[ref] = publicComponentInstance;
      },
      detachRef: function(ref) {
        var refs = this.getPublicInstance().refs;
        delete refs[ref];
      },
      getName: function() {
        var type = this._currentElement.type;
        var constructor = this._instance && this._instance.constructor;
        return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
      },
      getPublicInstance: function() {
        var inst = this._instance;
        if (inst instanceof StatelessComponent) {
          return null;
        }
        return inst;
      },
      _instantiateReactComponent: null
    };
    ReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {
      mountComponent: 'mountComponent',
      updateComponent: 'updateComponent',
      _renderValidatedComponent: '_renderValidatedComponent'
    });
    var ReactCompositeComponent = {Mixin: ReactCompositeComponentMixin};
    module.exports = ReactCompositeComponent;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactCurrentOwner", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ReactCurrentOwner = {current: null};
  module.exports = ReactCurrentOwner;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/canDefineProperty", ["github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var canDefineProperty = false;
    if (process.env.NODE_ENV !== 'production') {
      try {
        Object.defineProperty({}, 'x', {get: function() {}});
        canDefineProperty = true;
      } catch (x) {}
    }
    module.exports = canDefineProperty;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactElement", ["npm:react@0.14.6/lib/ReactCurrentOwner", "npm:react@0.14.6/lib/Object.assign", "npm:react@0.14.6/lib/canDefineProperty", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactCurrentOwner = $__require('npm:react@0.14.6/lib/ReactCurrentOwner');
    var assign = $__require('npm:react@0.14.6/lib/Object.assign');
    var canDefineProperty = $__require('npm:react@0.14.6/lib/canDefineProperty');
    var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
    var RESERVED_PROPS = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    };
    var ReactElement = function(type, key, ref, self, source, owner, props) {
      var element = {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type,
        key: key,
        ref: ref,
        props: props,
        _owner: owner
      };
      if (process.env.NODE_ENV !== 'production') {
        element._store = {};
        if (canDefineProperty) {
          Object.defineProperty(element._store, 'validated', {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, '_self', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self
          });
          Object.defineProperty(element, '_source', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
        } else {
          element._store.validated = false;
          element._self = self;
          element._source = source;
        }
        Object.freeze(element.props);
        Object.freeze(element);
      }
      return element;
    };
    ReactElement.createElement = function(type, config, children) {
      var propName;
      var props = {};
      var key = null;
      var ref = null;
      var self = null;
      var source = null;
      if (config != null) {
        ref = config.ref === undefined ? null : config.ref;
        key = config.key === undefined ? null : '' + config.key;
        self = config.__self === undefined ? null : config.__self;
        source = config.__source === undefined ? null : config.__source;
        for (propName in config) {
          if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      }
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        props.children = childArray;
      }
      if (type && type.defaultProps) {
        var defaultProps = type.defaultProps;
        for (propName in defaultProps) {
          if (typeof props[propName] === 'undefined') {
            props[propName] = defaultProps[propName];
          }
        }
      }
      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
    };
    ReactElement.createFactory = function(type) {
      var factory = ReactElement.createElement.bind(null, type);
      factory.type = type;
      return factory;
    };
    ReactElement.cloneAndReplaceKey = function(oldElement, newKey) {
      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
      return newElement;
    };
    ReactElement.cloneAndReplaceProps = function(oldElement, newProps) {
      var newElement = ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, newProps);
      if (process.env.NODE_ENV !== 'production') {
        newElement._store.validated = oldElement._store.validated;
      }
      return newElement;
    };
    ReactElement.cloneElement = function(element, config, children) {
      var propName;
      var props = assign({}, element.props);
      var key = element.key;
      var ref = element.ref;
      var self = element._self;
      var source = element._source;
      var owner = element._owner;
      if (config != null) {
        if (config.ref !== undefined) {
          ref = config.ref;
          owner = ReactCurrentOwner.current;
        }
        if (config.key !== undefined) {
          key = '' + config.key;
        }
        for (propName in config) {
          if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      }
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        props.children = childArray;
      }
      return ReactElement(element.type, key, ref, self, source, owner, props);
    };
    ReactElement.isValidElement = function(object) {
      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    };
    module.exports = ReactElement;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactEmptyComponentRegistry", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var nullComponentIDsRegistry = {};
  function isNullComponentID(id) {
    return !!nullComponentIDsRegistry[id];
  }
  function registerNullComponentID(id) {
    nullComponentIDsRegistry[id] = true;
  }
  function deregisterNullComponentID(id) {
    delete nullComponentIDsRegistry[id];
  }
  var ReactEmptyComponentRegistry = {
    isNullComponentID: isNullComponentID,
    registerNullComponentID: registerNullComponentID,
    deregisterNullComponentID: deregisterNullComponentID
  };
  module.exports = ReactEmptyComponentRegistry;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactOwner", ["npm:fbjs@0.6.1/lib/invariant", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var ReactOwner = {
      isValidOwner: function(object) {
        return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
      },
      addComponentAsRefTo: function(component, ref, owner) {
        !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might ' + 'be adding a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
        owner.attachRef(ref, component);
      },
      removeComponentAsRefFrom: function(component, ref, owner) {
        !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might ' + 'be removing a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
        if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {
          owner.detachRef(ref);
        }
      }
    };
    module.exports = ReactOwner;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactRef", ["npm:react@0.14.6/lib/ReactOwner", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactOwner = $__require('npm:react@0.14.6/lib/ReactOwner');
    var ReactRef = {};
    function attachRef(ref, component, owner) {
      if (typeof ref === 'function') {
        ref(component.getPublicInstance());
      } else {
        ReactOwner.addComponentAsRefTo(component, ref, owner);
      }
    }
    function detachRef(ref, component, owner) {
      if (typeof ref === 'function') {
        ref(null);
      } else {
        ReactOwner.removeComponentAsRefFrom(component, ref, owner);
      }
    }
    ReactRef.attachRefs = function(instance, element) {
      if (element === null || element === false) {
        return;
      }
      var ref = element.ref;
      if (ref != null) {
        attachRef(ref, instance, element._owner);
      }
    };
    ReactRef.shouldUpdateRefs = function(prevElement, nextElement) {
      var prevEmpty = prevElement === null || prevElement === false;
      var nextEmpty = nextElement === null || nextElement === false;
      return (prevEmpty || nextEmpty || nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref);
    };
    ReactRef.detachRefs = function(instance, element) {
      if (element === null || element === false) {
        return;
      }
      var ref = element.ref;
      if (ref != null) {
        detachRef(ref, instance, element._owner);
      }
    };
    module.exports = ReactRef;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactReconciler", ["npm:react@0.14.6/lib/ReactRef"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ReactRef = $__require('npm:react@0.14.6/lib/ReactRef');
  function attachRefs() {
    ReactRef.attachRefs(this, this._currentElement);
  }
  var ReactReconciler = {
    mountComponent: function(internalInstance, rootID, transaction, context) {
      var markup = internalInstance.mountComponent(rootID, transaction, context);
      if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
        transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
      }
      return markup;
    },
    unmountComponent: function(internalInstance) {
      ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
      internalInstance.unmountComponent();
    },
    receiveComponent: function(internalInstance, nextElement, transaction, context) {
      var prevElement = internalInstance._currentElement;
      if (nextElement === prevElement && context === internalInstance._context) {
        return;
      }
      var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
      if (refsChanged) {
        ReactRef.detachRefs(internalInstance, prevElement);
      }
      internalInstance.receiveComponent(nextElement, transaction, context);
      if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
        transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
      }
    },
    performUpdateIfNecessary: function(internalInstance, transaction) {
      internalInstance.performUpdateIfNecessary(transaction);
    }
  };
  module.exports = ReactReconciler;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactEmptyComponent", ["npm:react@0.14.6/lib/ReactElement", "npm:react@0.14.6/lib/ReactEmptyComponentRegistry", "npm:react@0.14.6/lib/ReactReconciler", "npm:react@0.14.6/lib/Object.assign"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ReactElement = $__require('npm:react@0.14.6/lib/ReactElement');
  var ReactEmptyComponentRegistry = $__require('npm:react@0.14.6/lib/ReactEmptyComponentRegistry');
  var ReactReconciler = $__require('npm:react@0.14.6/lib/ReactReconciler');
  var assign = $__require('npm:react@0.14.6/lib/Object.assign');
  var placeholderElement;
  var ReactEmptyComponentInjection = {injectEmptyComponent: function(component) {
      placeholderElement = ReactElement.createElement(component);
    }};
  var ReactEmptyComponent = function(instantiate) {
    this._currentElement = null;
    this._rootNodeID = null;
    this._renderedComponent = instantiate(placeholderElement);
  };
  assign(ReactEmptyComponent.prototype, {
    construct: function(element) {},
    mountComponent: function(rootID, transaction, context) {
      ReactEmptyComponentRegistry.registerNullComponentID(rootID);
      this._rootNodeID = rootID;
      return ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, context);
    },
    receiveComponent: function() {},
    unmountComponent: function(rootID, transaction, context) {
      ReactReconciler.unmountComponent(this._renderedComponent);
      ReactEmptyComponentRegistry.deregisterNullComponentID(this._rootNodeID);
      this._rootNodeID = null;
      this._renderedComponent = null;
    }
  });
  ReactEmptyComponent.injection = ReactEmptyComponentInjection;
  module.exports = ReactEmptyComponent;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactNativeComponent", ["npm:react@0.14.6/lib/Object.assign", "npm:fbjs@0.6.1/lib/invariant", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var assign = $__require('npm:react@0.14.6/lib/Object.assign');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var autoGenerateWrapperClass = null;
    var genericComponentClass = null;
    var tagToComponentClass = {};
    var textComponentClass = null;
    var ReactNativeComponentInjection = {
      injectGenericComponentClass: function(componentClass) {
        genericComponentClass = componentClass;
      },
      injectTextComponentClass: function(componentClass) {
        textComponentClass = componentClass;
      },
      injectComponentClasses: function(componentClasses) {
        assign(tagToComponentClass, componentClasses);
      }
    };
    function getComponentClassForElement(element) {
      if (typeof element.type === 'function') {
        return element.type;
      }
      var tag = element.type;
      var componentClass = tagToComponentClass[tag];
      if (componentClass == null) {
        tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
      }
      return componentClass;
    }
    function createInternalComponent(element) {
      !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : invariant(false) : undefined;
      return new genericComponentClass(element.type, element.props);
    }
    function createInstanceForText(text) {
      return new textComponentClass(text);
    }
    function isTextComponent(component) {
      return component instanceof textComponentClass;
    }
    var ReactNativeComponent = {
      getComponentClassForElement: getComponentClassForElement,
      createInternalComponent: createInternalComponent,
      createInstanceForText: createInstanceForText,
      isTextComponent: isTextComponent,
      injection: ReactNativeComponentInjection
    };
    module.exports = ReactNativeComponent;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/instantiateReactComponent", ["npm:react@0.14.6/lib/ReactCompositeComponent", "npm:react@0.14.6/lib/ReactEmptyComponent", "npm:react@0.14.6/lib/ReactNativeComponent", "npm:react@0.14.6/lib/Object.assign", "npm:fbjs@0.6.1/lib/invariant", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactCompositeComponent = $__require('npm:react@0.14.6/lib/ReactCompositeComponent');
    var ReactEmptyComponent = $__require('npm:react@0.14.6/lib/ReactEmptyComponent');
    var ReactNativeComponent = $__require('npm:react@0.14.6/lib/ReactNativeComponent');
    var assign = $__require('npm:react@0.14.6/lib/Object.assign');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    var ReactCompositeComponentWrapper = function() {};
    assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {_instantiateReactComponent: instantiateReactComponent});
    function getDeclarationErrorAddendum(owner) {
      if (owner) {
        var name = owner.getName();
        if (name) {
          return ' Check the render method of `' + name + '`.';
        }
      }
      return '';
    }
    function isInternalComponentType(type) {
      return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
    }
    function instantiateReactComponent(node) {
      var instance;
      if (node === null || node === false) {
        instance = new ReactEmptyComponent(instantiateReactComponent);
      } else if (typeof node === 'object') {
        var element = node;
        !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) ' + 'or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : invariant(false) : undefined;
        if (typeof element.type === 'string') {
          instance = ReactNativeComponent.createInternalComponent(element);
        } else if (isInternalComponentType(element.type)) {
          instance = new element.type(element);
        } else {
          instance = new ReactCompositeComponentWrapper();
        }
      } else if (typeof node === 'string' || typeof node === 'number') {
        instance = ReactNativeComponent.createInstanceForText(node);
      } else {
        !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : invariant(false) : undefined;
      }
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : undefined;
      }
      instance.construct(node);
      instance._mountIndex = 0;
      instance._mountImage = null;
      if (process.env.NODE_ENV !== 'production') {
        instance._isOwnerNecessary = false;
        instance._warnedAboutRefsInRender = false;
      }
      if (process.env.NODE_ENV !== 'production') {
        if (Object.preventExtensions) {
          Object.preventExtensions(instance);
        }
      }
      return instance;
    }
    module.exports = instantiateReactComponent;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/invariant", ["github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    function invariant(condition, format, a, b, c, d, e, f) {
      if (process.env.NODE_ENV !== 'production') {
        if (format === undefined) {
          throw new Error('invariant requires an error message argument');
        }
      }
      if (!condition) {
        var error;
        if (format === undefined) {
          error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(format.replace(/%s/g, function() {
            return args[argIndex++];
          }));
          error.name = 'Invariant Violation';
        }
        error.framesToPop = 1;
        throw error;
      }
    }
    module.exports = invariant;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/setInnerHTML", ["npm:fbjs@0.6.1/lib/ExecutionEnvironment", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ExecutionEnvironment = $__require('npm:fbjs@0.6.1/lib/ExecutionEnvironment');
    var WHITESPACE_TEST = /^[ \r\n\t\f]/;
    var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
    var setInnerHTML = function(node, html) {
      node.innerHTML = html;
    };
    if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
      setInnerHTML = function(node, html) {
        MSApp.execUnsafeLocalFunction(function() {
          node.innerHTML = html;
        });
      };
    }
    if (ExecutionEnvironment.canUseDOM) {
      var testElement = document.createElement('div');
      testElement.innerHTML = ' ';
      if (testElement.innerHTML === '') {
        setInnerHTML = function(node, html) {
          if (node.parentNode) {
            node.parentNode.replaceChild(node, node);
          }
          if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
            node.innerHTML = String.fromCharCode(0xFEFF) + html;
            var textNode = node.firstChild;
            if (textNode.data.length === 1) {
              node.removeChild(textNode);
            } else {
              textNode.deleteData(0, 1);
            }
          } else {
            node.innerHTML = html;
          }
        };
      }
    }
    module.exports = setInnerHTML;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/shouldUpdateReactComponent", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function shouldUpdateReactComponent(prevElement, nextElement) {
    var prevEmpty = prevElement === null || prevElement === false;
    var nextEmpty = nextElement === null || nextElement === false;
    if (prevEmpty || nextEmpty) {
      return prevEmpty === nextEmpty;
    }
    var prevType = typeof prevElement;
    var nextType = typeof nextElement;
    if (prevType === 'string' || prevType === 'number') {
      return nextType === 'string' || nextType === 'number';
    } else {
      return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
    }
    return false;
  }
  module.exports = shouldUpdateReactComponent;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/Object.assign", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function assign(target, sources) {
    if (target == null) {
      throw new TypeError('Object.assign target cannot be null or undefined');
    }
    var to = Object(target);
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
      var nextSource = arguments[nextIndex];
      if (nextSource == null) {
        continue;
      }
      var from = Object(nextSource);
      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }
    }
    return to;
  }
  module.exports = assign;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/validateDOMNesting", ["npm:react@0.14.6/lib/Object.assign", "npm:fbjs@0.6.1/lib/emptyFunction", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var assign = $__require('npm:react@0.14.6/lib/Object.assign');
    var emptyFunction = $__require('npm:fbjs@0.6.1/lib/emptyFunction');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    var validateDOMNesting = emptyFunction;
    if (process.env.NODE_ENV !== 'production') {
      var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
      var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template', 'foreignObject', 'desc', 'title'];
      var buttonScopeTags = inScopeTags.concat(['button']);
      var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
      var emptyAncestorInfo = {
        parentTag: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      var updatedAncestorInfo = function(oldInfo, tag, instance) {
        var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
        var info = {
          tag: tag,
          instance: instance
        };
        if (inScopeTags.indexOf(tag) !== -1) {
          ancestorInfo.aTagInScope = null;
          ancestorInfo.buttonTagInScope = null;
          ancestorInfo.nobrTagInScope = null;
        }
        if (buttonScopeTags.indexOf(tag) !== -1) {
          ancestorInfo.pTagInButtonScope = null;
        }
        if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
          ancestorInfo.listItemTagAutoclosing = null;
          ancestorInfo.dlItemTagAutoclosing = null;
        }
        ancestorInfo.parentTag = info;
        if (tag === 'form') {
          ancestorInfo.formTag = info;
        }
        if (tag === 'a') {
          ancestorInfo.aTagInScope = info;
        }
        if (tag === 'button') {
          ancestorInfo.buttonTagInScope = info;
        }
        if (tag === 'nobr') {
          ancestorInfo.nobrTagInScope = info;
        }
        if (tag === 'p') {
          ancestorInfo.pTagInButtonScope = info;
        }
        if (tag === 'li') {
          ancestorInfo.listItemTagAutoclosing = info;
        }
        if (tag === 'dd' || tag === 'dt') {
          ancestorInfo.dlItemTagAutoclosing = info;
        }
        return ancestorInfo;
      };
      var isTagValidWithParent = function(tag, parentTag) {
        switch (parentTag) {
          case 'select':
            return tag === 'option' || tag === 'optgroup' || tag === '#text';
          case 'optgroup':
            return tag === 'option' || tag === '#text';
          case 'option':
            return tag === '#text';
          case 'tr':
            return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
          case 'tbody':
          case 'thead':
          case 'tfoot':
            return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
          case 'colgroup':
            return tag === 'col' || tag === 'template';
          case 'table':
            return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
          case 'head':
            return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
          case 'html':
            return tag === 'head' || tag === 'body';
        }
        switch (tag) {
          case 'h1':
          case 'h2':
          case 'h3':
          case 'h4':
          case 'h5':
          case 'h6':
            return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
          case 'rp':
          case 'rt':
            return impliedEndTags.indexOf(parentTag) === -1;
          case 'caption':
          case 'col':
          case 'colgroup':
          case 'frame':
          case 'head':
          case 'tbody':
          case 'td':
          case 'tfoot':
          case 'th':
          case 'thead':
          case 'tr':
            return parentTag == null;
        }
        return true;
      };
      var findInvalidAncestorForTag = function(tag, ancestorInfo) {
        switch (tag) {
          case 'address':
          case 'article':
          case 'aside':
          case 'blockquote':
          case 'center':
          case 'details':
          case 'dialog':
          case 'dir':
          case 'div':
          case 'dl':
          case 'fieldset':
          case 'figcaption':
          case 'figure':
          case 'footer':
          case 'header':
          case 'hgroup':
          case 'main':
          case 'menu':
          case 'nav':
          case 'ol':
          case 'p':
          case 'section':
          case 'summary':
          case 'ul':
          case 'pre':
          case 'listing':
          case 'table':
          case 'hr':
          case 'xmp':
          case 'h1':
          case 'h2':
          case 'h3':
          case 'h4':
          case 'h5':
          case 'h6':
            return ancestorInfo.pTagInButtonScope;
          case 'form':
            return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
          case 'li':
            return ancestorInfo.listItemTagAutoclosing;
          case 'dd':
          case 'dt':
            return ancestorInfo.dlItemTagAutoclosing;
          case 'button':
            return ancestorInfo.buttonTagInScope;
          case 'a':
            return ancestorInfo.aTagInScope;
          case 'nobr':
            return ancestorInfo.nobrTagInScope;
        }
        return null;
      };
      var findOwnerStack = function(instance) {
        if (!instance) {
          return [];
        }
        var stack = [];
        do {
          stack.push(instance);
        } while (instance = instance._currentElement._owner);
        stack.reverse();
        return stack;
      };
      var didWarn = {};
      validateDOMNesting = function(childTag, childInstance, ancestorInfo) {
        ancestorInfo = ancestorInfo || emptyAncestorInfo;
        var parentInfo = ancestorInfo.parentTag;
        var parentTag = parentInfo && parentInfo.tag;
        var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
        var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
        var problematic = invalidParent || invalidAncestor;
        if (problematic) {
          var ancestorTag = problematic.tag;
          var ancestorInstance = problematic.instance;
          var childOwner = childInstance && childInstance._currentElement._owner;
          var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
          var childOwners = findOwnerStack(childOwner);
          var ancestorOwners = findOwnerStack(ancestorOwner);
          var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
          var i;
          var deepestCommon = -1;
          for (i = 0; i < minStackLen; i++) {
            if (childOwners[i] === ancestorOwners[i]) {
              deepestCommon = i;
            } else {
              break;
            }
          }
          var UNKNOWN = '(unknown)';
          var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function(inst) {
            return inst.getName() || UNKNOWN;
          });
          var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function(inst) {
            return inst.getName() || UNKNOWN;
          });
          var ownerInfo = [].concat(deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag, invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
          var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
          if (didWarn[warnKey]) {
            return;
          }
          didWarn[warnKey] = true;
          if (invalidParent) {
            var info = '';
            if (ancestorTag === 'table' && childTag === 'tr') {
              info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
            }
            process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a child of <%s>. ' + 'See %s.%s', childTag, ancestorTag, ownerInfo, info) : undefined;
          } else {
            process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a descendant of ' + '<%s>. See %s.', childTag, ancestorTag, ownerInfo) : undefined;
          }
        }
      };
      validateDOMNesting.ancestorInfoContextKey = '__validateDOMNesting_ancestorInfo$' + Math.random().toString(36).slice(2);
      validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
      validateDOMNesting.isTagValidInContext = function(tag, ancestorInfo) {
        ancestorInfo = ancestorInfo || emptyAncestorInfo;
        var parentInfo = ancestorInfo.parentTag;
        var parentTag = parentInfo && parentInfo.tag;
        return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
      };
    }
    module.exports = validateDOMNesting;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactMount", ["npm:react@0.14.6/lib/DOMProperty", "npm:react@0.14.6/lib/ReactBrowserEventEmitter", "npm:react@0.14.6/lib/ReactCurrentOwner", "npm:react@0.14.6/lib/ReactDOMFeatureFlags", "npm:react@0.14.6/lib/ReactElement", "npm:react@0.14.6/lib/ReactEmptyComponentRegistry", "npm:react@0.14.6/lib/ReactInstanceHandles", "npm:react@0.14.6/lib/ReactInstanceMap", "npm:react@0.14.6/lib/ReactMarkupChecksum", "npm:react@0.14.6/lib/ReactPerf", "npm:react@0.14.6/lib/ReactReconciler", "npm:react@0.14.6/lib/ReactUpdateQueue", "npm:react@0.14.6/lib/ReactUpdates", "npm:react@0.14.6/lib/Object.assign", "npm:fbjs@0.6.1/lib/emptyObject", "npm:fbjs@0.6.1/lib/containsNode", "npm:react@0.14.6/lib/instantiateReactComponent", "npm:fbjs@0.6.1/lib/invariant", "npm:react@0.14.6/lib/setInnerHTML", "npm:react@0.14.6/lib/shouldUpdateReactComponent", "npm:react@0.14.6/lib/validateDOMNesting", "npm:fbjs@0.6.1/lib/warning", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var DOMProperty = $__require('npm:react@0.14.6/lib/DOMProperty');
    var ReactBrowserEventEmitter = $__require('npm:react@0.14.6/lib/ReactBrowserEventEmitter');
    var ReactCurrentOwner = $__require('npm:react@0.14.6/lib/ReactCurrentOwner');
    var ReactDOMFeatureFlags = $__require('npm:react@0.14.6/lib/ReactDOMFeatureFlags');
    var ReactElement = $__require('npm:react@0.14.6/lib/ReactElement');
    var ReactEmptyComponentRegistry = $__require('npm:react@0.14.6/lib/ReactEmptyComponentRegistry');
    var ReactInstanceHandles = $__require('npm:react@0.14.6/lib/ReactInstanceHandles');
    var ReactInstanceMap = $__require('npm:react@0.14.6/lib/ReactInstanceMap');
    var ReactMarkupChecksum = $__require('npm:react@0.14.6/lib/ReactMarkupChecksum');
    var ReactPerf = $__require('npm:react@0.14.6/lib/ReactPerf');
    var ReactReconciler = $__require('npm:react@0.14.6/lib/ReactReconciler');
    var ReactUpdateQueue = $__require('npm:react@0.14.6/lib/ReactUpdateQueue');
    var ReactUpdates = $__require('npm:react@0.14.6/lib/ReactUpdates');
    var assign = $__require('npm:react@0.14.6/lib/Object.assign');
    var emptyObject = $__require('npm:fbjs@0.6.1/lib/emptyObject');
    var containsNode = $__require('npm:fbjs@0.6.1/lib/containsNode');
    var instantiateReactComponent = $__require('npm:react@0.14.6/lib/instantiateReactComponent');
    var invariant = $__require('npm:fbjs@0.6.1/lib/invariant');
    var setInnerHTML = $__require('npm:react@0.14.6/lib/setInnerHTML');
    var shouldUpdateReactComponent = $__require('npm:react@0.14.6/lib/shouldUpdateReactComponent');
    var validateDOMNesting = $__require('npm:react@0.14.6/lib/validateDOMNesting');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
    var nodeCache = {};
    var ELEMENT_NODE_TYPE = 1;
    var DOC_NODE_TYPE = 9;
    var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
    var ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);
    var instancesByReactRootID = {};
    var containersByReactRootID = {};
    if (process.env.NODE_ENV !== 'production') {
      var rootElementsByReactRootID = {};
    }
    var findComponentRootReusableArray = [];
    function firstDifferenceIndex(string1, string2) {
      var minLen = Math.min(string1.length, string2.length);
      for (var i = 0; i < minLen; i++) {
        if (string1.charAt(i) !== string2.charAt(i)) {
          return i;
        }
      }
      return string1.length === string2.length ? -1 : minLen;
    }
    function getReactRootElementInContainer(container) {
      if (!container) {
        return null;
      }
      if (container.nodeType === DOC_NODE_TYPE) {
        return container.documentElement;
      } else {
        return container.firstChild;
      }
    }
    function getReactRootID(container) {
      var rootElement = getReactRootElementInContainer(container);
      return rootElement && ReactMount.getID(rootElement);
    }
    function getID(node) {
      var id = internalGetID(node);
      if (id) {
        if (nodeCache.hasOwnProperty(id)) {
          var cached = nodeCache[id];
          if (cached !== node) {
            !!isValid(cached, id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;
            nodeCache[id] = node;
          }
        } else {
          nodeCache[id] = node;
        }
      }
      return id;
    }
    function internalGetID(node) {
      return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
    }
    function setID(node, id) {
      var oldID = internalGetID(node);
      if (oldID !== id) {
        delete nodeCache[oldID];
      }
      node.setAttribute(ATTR_NAME, id);
      nodeCache[id] = node;
    }
    function getNode(id) {
      if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
        nodeCache[id] = ReactMount.findReactNodeByID(id);
      }
      return nodeCache[id];
    }
    function getNodeFromInstance(instance) {
      var id = ReactInstanceMap.get(instance)._rootNodeID;
      if (ReactEmptyComponentRegistry.isNullComponentID(id)) {
        return null;
      }
      if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
        nodeCache[id] = ReactMount.findReactNodeByID(id);
      }
      return nodeCache[id];
    }
    function isValid(node, id) {
      if (node) {
        !(internalGetID(node) === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;
        var container = ReactMount.findReactContainerForID(id);
        if (container && containsNode(container, node)) {
          return true;
        }
      }
      return false;
    }
    function purgeID(id) {
      delete nodeCache[id];
    }
    var deepestNodeSoFar = null;
    function findDeepestCachedAncestorImpl(ancestorID) {
      var ancestor = nodeCache[ancestorID];
      if (ancestor && isValid(ancestor, ancestorID)) {
        deepestNodeSoFar = ancestor;
      } else {
        return false;
      }
    }
    function findDeepestCachedAncestor(targetID) {
      deepestNodeSoFar = null;
      ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);
      var foundNode = deepestNodeSoFar;
      deepestNodeSoFar = null;
      return foundNode;
    }
    function mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {
      if (ReactDOMFeatureFlags.useCreateElement) {
        context = assign({}, context);
        if (container.nodeType === DOC_NODE_TYPE) {
          context[ownerDocumentContextKey] = container;
        } else {
          context[ownerDocumentContextKey] = container.ownerDocument;
        }
      }
      if (process.env.NODE_ENV !== 'production') {
        if (context === emptyObject) {
          context = {};
        }
        var tag = container.nodeName.toLowerCase();
        context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);
      }
      var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);
      componentInstance._renderedComponent._topLevelWrapper = componentInstance;
      ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);
    }
    function batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {
      var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(shouldReuseMarkup);
      transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);
      ReactUpdates.ReactReconcileTransaction.release(transaction);
    }
    function unmountComponentFromNode(instance, container) {
      ReactReconciler.unmountComponent(instance);
      if (container.nodeType === DOC_NODE_TYPE) {
        container = container.documentElement;
      }
      while (container.lastChild) {
        container.removeChild(container.lastChild);
      }
    }
    function hasNonRootReactChild(node) {
      var reactRootID = getReactRootID(node);
      return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;
    }
    function findFirstReactDOMImpl(node) {
      for (; node && node.parentNode !== node; node = node.parentNode) {
        if (node.nodeType !== 1) {
          continue;
        }
        var nodeID = internalGetID(node);
        if (!nodeID) {
          continue;
        }
        var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
        var current = node;
        var lastID;
        do {
          lastID = internalGetID(current);
          current = current.parentNode;
          if (current == null) {
            return null;
          }
        } while (lastID !== reactRootID);
        if (current === containersByReactRootID[reactRootID]) {
          return node;
        }
      }
      return null;
    }
    var TopLevelWrapper = function() {};
    TopLevelWrapper.prototype.isReactComponent = {};
    if (process.env.NODE_ENV !== 'production') {
      TopLevelWrapper.displayName = 'TopLevelWrapper';
    }
    TopLevelWrapper.prototype.render = function() {
      return this.props;
    };
    var ReactMount = {
      TopLevelWrapper: TopLevelWrapper,
      _instancesByReactRootID: instancesByReactRootID,
      scrollMonitor: function(container, renderCallback) {
        renderCallback();
      },
      _updateRootComponent: function(prevComponent, nextElement, container, callback) {
        ReactMount.scrollMonitor(container, function() {
          ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
          if (callback) {
            ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
          }
        });
        if (process.env.NODE_ENV !== 'production') {
          rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
        }
        return prevComponent;
      },
      _registerComponent: function(nextComponent, container) {
        !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;
        ReactBrowserEventEmitter.ensureScrollValueMonitoring();
        var reactRootID = ReactMount.registerContainer(container);
        instancesByReactRootID[reactRootID] = nextComponent;
        return reactRootID;
      },
      _renderNewRootComponent: function(nextElement, container, shouldReuseMarkup, context) {
        process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;
        var componentInstance = instantiateReactComponent(nextElement, null);
        var reactRootID = ReactMount._registerComponent(componentInstance, container);
        ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);
        if (process.env.NODE_ENV !== 'production') {
          rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
        }
        return componentInstance;
      },
      renderSubtreeIntoContainer: function(parentComponent, nextElement, container, callback) {
        !(parentComponent != null && parentComponent._reactInternalInstance != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;
        return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
      },
      _renderSubtreeIntoContainer: function(parentComponent, nextElement, container, callback) {
        !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;
        process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;
        var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);
        var prevComponent = instancesByReactRootID[getReactRootID(container)];
        if (prevComponent) {
          var prevWrappedElement = prevComponent._currentElement;
          var prevElement = prevWrappedElement.props;
          if (shouldUpdateReactComponent(prevElement, nextElement)) {
            var publicInst = prevComponent._renderedComponent.getPublicInstance();
            var updatedCallback = callback && function() {
              callback.call(publicInst);
            };
            ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);
            return publicInst;
          } else {
            ReactMount.unmountComponentAtNode(container);
          }
        }
        var reactRootElement = getReactRootElementInContainer(container);
        var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
        var containerHasNonRootReactChild = hasNonRootReactChild(container);
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;
          if (!containerHasReactMarkup || reactRootElement.nextSibling) {
            var rootElementSibling = reactRootElement;
            while (rootElementSibling) {
              if (internalGetID(rootElementSibling)) {
                process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;
                break;
              }
              rootElementSibling = rootElementSibling.nextSibling;
            }
          }
        }
        var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
        var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();
        if (callback) {
          callback.call(component);
        }
        return component;
      },
      render: function(nextElement, container, callback) {
        return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
      },
      registerContainer: function(container) {
        var reactRootID = getReactRootID(container);
        if (reactRootID) {
          reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
        }
        if (!reactRootID) {
          reactRootID = ReactInstanceHandles.createReactRootID();
        }
        containersByReactRootID[reactRootID] = container;
        return reactRootID;
      },
      unmountComponentAtNode: function(container) {
        process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;
        !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;
        var reactRootID = getReactRootID(container);
        var component = instancesByReactRootID[reactRootID];
        if (!component) {
          var containerHasNonRootReactChild = hasNonRootReactChild(container);
          var containerID = internalGetID(container);
          var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);
          if (process.env.NODE_ENV !== 'production') {
            process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;
          }
          return false;
        }
        ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);
        delete instancesByReactRootID[reactRootID];
        delete containersByReactRootID[reactRootID];
        if (process.env.NODE_ENV !== 'production') {
          delete rootElementsByReactRootID[reactRootID];
        }
        return true;
      },
      findReactContainerForID: function(id) {
        var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
        var container = containersByReactRootID[reactRootID];
        if (process.env.NODE_ENV !== 'production') {
          var rootElement = rootElementsByReactRootID[reactRootID];
          if (rootElement && rootElement.parentNode !== container) {
            process.env.NODE_ENV !== 'production' ? warning(internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;
            var containerChild = container.firstChild;
            if (containerChild && reactRootID === internalGetID(containerChild)) {
              rootElementsByReactRootID[reactRootID] = containerChild;
            } else {
              process.env.NODE_ENV !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;
            }
          }
        }
        return container;
      },
      findReactNodeByID: function(id) {
        var reactRoot = ReactMount.findReactContainerForID(id);
        return ReactMount.findComponentRoot(reactRoot, id);
      },
      getFirstReactDOM: function(node) {
        return findFirstReactDOMImpl(node);
      },
      findComponentRoot: function(ancestorNode, targetID) {
        var firstChildren = findComponentRootReusableArray;
        var childIndex = 0;
        var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(deepestAncestor != null, 'React can\'t find the root component node for data-reactid value ' + '`%s`. If you\'re seeing this message, it probably means that ' + 'you\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;
        }
        firstChildren[0] = deepestAncestor.firstChild;
        firstChildren.length = 1;
        while (childIndex < firstChildren.length) {
          var child = firstChildren[childIndex++];
          var targetChild;
          while (child) {
            var childID = ReactMount.getID(child);
            if (childID) {
              if (targetID === childID) {
                targetChild = child;
              } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
                firstChildren.length = childIndex = 0;
                firstChildren.push(child.firstChild);
              }
            } else {
              firstChildren.push(child.firstChild);
            }
            child = child.nextSibling;
          }
          if (targetChild) {
            firstChildren.length = 0;
            return targetChild;
          }
        }
        firstChildren.length = 0;
        !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;
      },
      _mountImageIntoNode: function(markup, container, shouldReuseMarkup, transaction) {
        !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;
        if (shouldReuseMarkup) {
          var rootElement = getReactRootElementInContainer(container);
          if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
            return;
          } else {
            var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
            rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
            var rootMarkup = rootElement.outerHTML;
            rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
            var normalizedMarkup = markup;
            if (process.env.NODE_ENV !== 'production') {
              var normalizer;
              if (container.nodeType === ELEMENT_NODE_TYPE) {
                normalizer = document.createElement('div');
                normalizer.innerHTML = markup;
                normalizedMarkup = normalizer.innerHTML;
              } else {
                normalizer = document.createElement('iframe');
                document.body.appendChild(normalizer);
                normalizer.contentDocument.write(markup);
                normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
                document.body.removeChild(normalizer);
              }
            }
            var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
            var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
            !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\n%s', difference) : invariant(false) : undefined;
            if (process.env.NODE_ENV !== 'production') {
              process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : undefined;
            }
          }
        }
        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
        if (transaction.useCreateElement) {
          while (container.lastChild) {
            container.removeChild(container.lastChild);
          }
          container.appendChild(markup);
        } else {
          setInnerHTML(container, markup);
        }
      },
      ownerDocumentContextKey: ownerDocumentContextKey,
      getReactRootID: getReactRootID,
      getID: getID,
      setID: setID,
      getNode: getNode,
      getNodeFromInstance: getNodeFromInstance,
      isValid: isValid,
      purgeID: purgeID
    };
    ReactPerf.measureMethods(ReactMount, 'ReactMount', {
      _renderNewRootComponent: '_renderNewRootComponent',
      _mountImageIntoNode: '_mountImageIntoNode'
    });
    module.exports = ReactMount;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/renderSubtreeIntoContainer", ["npm:react@0.14.6/lib/ReactMount"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ReactMount = $__require('npm:react@0.14.6/lib/ReactMount');
  module.exports = ReactMount.renderSubtreeIntoContainer;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/emptyFunction", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function makeEmptyFunction(arg) {
    return function() {
      return arg;
    };
  }
  function emptyFunction() {}
  emptyFunction.thatReturns = makeEmptyFunction;
  emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
  emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
  emptyFunction.thatReturnsNull = makeEmptyFunction(null);
  emptyFunction.thatReturnsThis = function() {
    return this;
  };
  emptyFunction.thatReturnsArgument = function(arg) {
    return arg;
  };
  module.exports = emptyFunction;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/warning", ["npm:fbjs@0.6.1/lib/emptyFunction", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var emptyFunction = $__require('npm:fbjs@0.6.1/lib/emptyFunction');
    var warning = emptyFunction;
    if (process.env.NODE_ENV !== 'production') {
      warning = function(condition, format) {
        for (var _len = arguments.length,
            args = Array(_len > 2 ? _len - 2 : 0),
            _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }
        if (format === undefined) {
          throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
        }
        if (format.indexOf('Failed Composite propType: ') === 0) {
          return;
        }
        if (!condition) {
          var argIndex = 0;
          var message = 'Warning: ' + format.replace(/%s/g, function() {
            return args[argIndex++];
          });
          if (typeof console !== 'undefined') {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x) {}
        }
      };
    }
    module.exports = warning;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fbjs@0.6.1/lib/ExecutionEnvironment", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
  var ExecutionEnvironment = {
    canUseDOM: canUseDOM,
    canUseWorkers: typeof Worker !== 'undefined',
    canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
    canUseViewport: canUseDOM && !!window.screen,
    isInWorker: !canUseDOM
  };
  module.exports = ExecutionEnvironment;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react@0.14.6/lib/ReactDOM", ["npm:react@0.14.6/lib/ReactCurrentOwner", "npm:react@0.14.6/lib/ReactDOMTextComponent", "npm:react@0.14.6/lib/ReactDefaultInjection", "npm:react@0.14.6/lib/ReactInstanceHandles", "npm:react@0.14.6/lib/ReactMount", "npm:react@0.14.6/lib/ReactPerf", "npm:react@0.14.6/lib/ReactReconciler", "npm:react@0.14.6/lib/ReactUpdates", "npm:react@0.14.6/lib/ReactVersion", "npm:react@0.14.6/lib/findDOMNode", "npm:react@0.14.6/lib/renderSubtreeIntoContainer", "npm:fbjs@0.6.1/lib/warning", "npm:fbjs@0.6.1/lib/ExecutionEnvironment", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactCurrentOwner = $__require('npm:react@0.14.6/lib/ReactCurrentOwner');
    var ReactDOMTextComponent = $__require('npm:react@0.14.6/lib/ReactDOMTextComponent');
    var ReactDefaultInjection = $__require('npm:react@0.14.6/lib/ReactDefaultInjection');
    var ReactInstanceHandles = $__require('npm:react@0.14.6/lib/ReactInstanceHandles');
    var ReactMount = $__require('npm:react@0.14.6/lib/ReactMount');
    var ReactPerf = $__require('npm:react@0.14.6/lib/ReactPerf');
    var ReactReconciler = $__require('npm:react@0.14.6/lib/ReactReconciler');
    var ReactUpdates = $__require('npm:react@0.14.6/lib/ReactUpdates');
    var ReactVersion = $__require('npm:react@0.14.6/lib/ReactVersion');
    var findDOMNode = $__require('npm:react@0.14.6/lib/findDOMNode');
    var renderSubtreeIntoContainer = $__require('npm:react@0.14.6/lib/renderSubtreeIntoContainer');
    var warning = $__require('npm:fbjs@0.6.1/lib/warning');
    ReactDefaultInjection.inject();
    var render = ReactPerf.measure('React', 'render', ReactMount.render);
    var React = {
      findDOMNode: findDOMNode,
      render: render,
      unmountComponentAtNode: ReactMount.unmountComponentAtNode,
      version: ReactVersion,
      unstable_batchedUpdates: ReactUpdates.batchedUpdates,
      unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
        CurrentOwner: ReactCurrentOwner,
        InstanceHandles: ReactInstanceHandles,
        Mount: ReactMount,
        Reconciler: ReactReconciler,
        TextComponent: ReactDOMTextComponent
      });
    }
    if (process.env.NODE_ENV !== 'production') {
      var ExecutionEnvironment = $__require('npm:fbjs@0.6.1/lib/ExecutionEnvironment');
      if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
          if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
            console.debug('Download the React DevTools for a better development experience: ' + 'https://fb.me/react-devtools');
          }
        }
        var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
        process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : undefined;
        var expectedFeatures = [Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim, Object.create, Object.freeze];
        for (var i = 0; i < expectedFeatures.length; i++) {
          if (!expectedFeatures[i]) {
            console.error('One or more ES5 shim/shams expected by React are not available: ' + 'https://fb.me/react-warning-polyfills');
            break;
          }
        }
      }
    }
    module.exports = React;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react-dom@0.14.6/index", ["npm:react@0.14.6/lib/ReactDOM"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:react@0.14.6/lib/ReactDOM');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:react-dom@0.14.6", ["npm:react-dom@0.14.6/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:react-dom@0.14.6/index');
  global.define = __define;
  return module.exports;
});

System.register('src/js/components/features.js', ['npm:react@0.14.6', 'npm:react-dom@0.14.6'], function (_export) {
    'use strict';

    var React, ReactDOM, Dial;
    return {
        setters: [function (_npmReact0146) {
            React = _npmReact0146;
        }, function (_npmReactDom0146) {
            ReactDOM = _npmReactDom0146;
        }],
        execute: function () {
            Dial = React.createClass({
                displayName: "Dial",
                _normalizeDegrees: function _normalizeDegrees(degrees) {
                    // Normalize to a positive value between 0 and 360
                    return (360 + degrees) % 360;
                },
                _getDegrees: function _getDegrees() {
                    return this._normalizeDegrees(this.props.degrees || this.state.degrees);
                },
                _getRotation: function _getRotation() {
                    var factor = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];

                    // 45 gets the arrow to the top.
                    return 'rotate(' + factor * (this._getDegrees() + 45) + 'deg)';
                },
                _onMouseDown: function _onMouseDown(evt) {
                    // We are now moving
                    this.setState({ mouseDragging: true });
                },
                _onMouseMove: function _onMouseMove(evt) {
                    if (!this.state.mouseDragging) {
                        return;
                    }

                    var dialRect = this.refs.dialFace.getBoundingClientRect();
                    var mousePos = [evt.clientX, evt.clientY];
                    var dialPos = [dialRect.left + dialRect.width / 2, dialRect.top + dialRect.height / 2];
                    var radians = Math.atan2(dialPos[1] - mousePos[1], dialPos[0] - mousePos[0]);
                    var degrees = radians * (180 / Math.PI) - 90;

                    // Save it internally
                    this.setState({ degrees: degrees });

                    // Notify parent
                    if (this.props.onChange) {
                        this.props.onChange(this._normalizeDegrees(degrees));
                    }
                },
                _onMouseUp: function _onMouseUp(evt) {
                    if (!this.state.mouseDragging) {
                        return;
                    }

                    // We are no longer moving
                    this.setState({ mouseDragging: false });
                },
                getInitialState: function getInitialState() {
                    return { mouseDragging: false, degrees: 0 };
                },
                componentDidMount: function componentDidMount() {
                    window.addEventListener("mouseup", this._onMouseUp);
                    window.addEventListener("mousemove", this._onMouseMove);
                },
                componentWillUnmount: function componentWillUnmount() {
                    window.removeEventListener("mouseup", this._onMouseUp);
                    window.removeEventListener("mousemove", this._onMouseMove);
                },
                render: function render() {
                    return React.createElement(
                        'div',
                        { className: 'dial', onMouseDown: this._onMouseDown },
                        React.createElement(
                            'div',
                            { className: 'dial__chamfer' },
                            React.createElement(
                                'div',
                                { className: 'dial__face',
                                    style: { transform: this._getRotation() },
                                    ref: 'dialFace' },
                                React.createElement('div', { className: 'dial__arrow' }),
                                React.createElement('div', { className: 'dial__inner' })
                            )
                        ),
                        React.createElement(
                            'div',
                            { className: 'dial__text' },
                            this.props.children,
                            ' ',
                            (Math.abs(this._getDegrees()) / 3.6).toFixed(0),
                            '%'
                        )
                    );
                }
            });

            _export('Dial', Dial);
        }
    };
});
System.register('src/js/components/boxes.js', ['npm:react@0.14.6', 'npm:react-dom@0.14.6', 'npm:react-redux@4.0.6', 'src/js/components/features.js'], function (_export) {
    'use strict';

    var React, ReactDOM, connect, Dial, BoxContainer, Box, Name, Contact, Instructions, BackgroundSpeed, BackgroundMaxScale, BackgroundMinScale;

    function connectBgProp(propName, stateName, factor) {
        function stateToProps(state) {
            var ret = {};

            ret[propName] = state.background[stateName] * factor;

            return ret;
        }

        return connect(stateToProps);
    }

    return {
        setters: [function (_npmReact0146) {
            React = _npmReact0146;
        }, function (_npmReactDom0146) {
            ReactDOM = _npmReactDom0146;
        }, function (_npmReactRedux406) {
            connect = _npmReactRedux406.connect;
        }, function (_srcJsComponentsFeaturesJs) {
            Dial = _srcJsComponentsFeaturesJs.Dial;
        }],
        execute: function () {
            BoxContainer = React.createClass({
                displayName: "BoxContainer",
                render: function render() {
                    return React.createElement(
                        'div',
                        { className: 'box-container grid' },
                        this.props.children
                    );
                }
            });
            Box = React.createClass({
                displayName: "Box",
                render: function render() {
                    return React.createElement(
                        'div',
                        { className: 'grid__col-xs-6 grid__col-md-4' },
                        React.createElement(
                            'div',
                            { className: 'box-item' },
                            this.props.children
                        )
                    );
                }
            });
            Name = React.createClass({
                displayName: "Name",
                render: function render() {
                    return React.createElement(
                        Box,
                        null,
                        React.createElement(
                            'h1',
                            null,
                            'Heya!'
                        ),
                        React.createElement(
                            'div',
                            { className: 'grid' },
                            React.createElement(
                                'div',
                                { className: 'grid__col-xs-4 align-cols' },
                                React.createElement('img', { src: '/src/img/headshot.png', width: '80px;', className: 'circle' })
                            ),
                            React.createElement(
                                'i',
                                { className: 'grid__col-xs-8' },
                                'My name is Jon. I\'m a web developer. I love to learn, I love to code, and I love to make ridiculous sites like this one.'
                            )
                        )
                    );
                }
            });
            Contact = React.createClass({
                displayName: "Contact",
                render: function render() {
                    return React.createElement(
                        Box,
                        null,
                        React.createElement(
                            'div',
                            { className: 'align-rows align-cols full-height' },
                            React.createElement(
                                'i',
                                null,
                                'Work with me here.'
                            ),
                            React.createElement(
                                'div',
                                null,
                                React.createElement(
                                    'div',
                                    { className: 'grid' },
                                    React.createElement(
                                        'a',
                                        { className: 'grid__col-xs-3 text-center',
                                            href: 'https://github.com/staab',
                                            title: 'Check out my OSS contributions',
                                            target: '_blank' },
                                        React.createElement('i', { className: 'fa fa-github' })
                                    ),
                                    React.createElement(
                                        'a',
                                        { className: 'grid__col-xs-3 text-center',
                                            href: 'mailto:shtaab@gmail.com',
                                            title: 'Chuck an email in my direction',
                                            target: '_blank' },
                                        React.createElement('i', { className: 'fa fa-envelope' })
                                    ),
                                    React.createElement(
                                        'a',
                                        { className: 'grid__col-xs-3 text-center',
                                            href: 'https://twitter.com/SanStaab',
                                            title: 'Tweetify me',
                                            target: '_blank' },
                                        React.createElement('i', { className: 'fa fa-twitter' })
                                    ),
                                    React.createElement(
                                        'a',
                                        { className: 'grid__col-xs-3 text-center',
                                            href: '/src/img/resume_staab_2016_01.pdf',
                                            title: 'Skim my resume',
                                            target: '_blank' },
                                        React.createElement('i', { className: 'fa fa-file' })
                                    )
                                )
                            )
                        )
                    );
                }
            });
            Instructions = React.createClass({
                displayName: 'Instructions',
                render: function render() {
                    return React.createElement(
                        Box,
                        null,
                        React.createElement(
                            'div',
                            { className: 'align-rows align-cols full-height' },
                            React.createElement(
                                'i',
                                null,
                                'Tweak the dials! Have some fun.'
                            )
                        )
                    );
                }
            });
            BackgroundSpeed = connectBgProp('degrees', 'speed', 360)(React.createClass({
                displayName: "BackgroundSpeed",
                _setBgSpeed: function _setBgSpeed(degrees) {
                    // Convert degrees to fraction
                    this.props.store.dispatch({ type: 'setBgSpeed', value: degrees / 360 });
                },
                render: function render() {
                    return React.createElement(
                        Box,
                        null,
                        React.createElement(
                            Dial,
                            { onChange: this._setBgSpeed, degrees: this.props.degrees },
                            'Speed'
                        )
                    );
                }
            }));
            BackgroundMaxScale = connectBgProp('degrees', 'maxScale', 36)(React.createClass({
                displayName: "BackgroundMaxScale",
                _setDegrees: function _setDegrees(degrees) {
                    // Convert degrees to fraction
                    this.props.store.dispatch({ type: 'setBgMaxScale', value: degrees / 36 });
                },
                render: function render() {
                    return React.createElement(
                        Box,
                        null,
                        React.createElement(
                            Dial,
                            { onChange: this._setDegrees, degrees: this.props.degrees },
                            'Max Size'
                        )
                    );
                }
            }));
            BackgroundMinScale = connectBgProp('degrees', 'minScale', 36)(React.createClass({
                displayName: "BackgroundMinScale",
                _setDegrees: function _setDegrees(degrees) {
                    // Convert degrees to fraction
                    this.props.store.dispatch({ type: 'setBgMinScale', value: degrees / 36 });
                },
                render: function render() {
                    return React.createElement(
                        Box,
                        null,
                        React.createElement(
                            Dial,
                            { onChange: this._setDegrees, degrees: this.props.degrees },
                            'Min Size'
                        )
                    );
                }
            }));

            _export('BoxContainer', BoxContainer);

            _export('Name', Name);

            _export('Instructions', Instructions);

            _export('Contact', Contact);

            _export('BackgroundSpeed', BackgroundSpeed);

            _export('BackgroundMaxScale', BackgroundMaxScale);

            _export('BackgroundMinScale', BackgroundMinScale);
        }
    };
});
System.register('src/js/components/layout.js', ['npm:react@0.14.6', 'npm:react-dom@0.14.6', 'src/js/state.js', 'src/js/components/boxes.js'], function (_export) {
    'use strict';

    var React, ReactDOM, store, boxes, Background, App;
    return {
        setters: [function (_npmReact0146) {
            React = _npmReact0146;
        }, function (_npmReactDom0146) {
            ReactDOM = _npmReactDom0146;
        }, function (_srcJsStateJs) {
            store = _srcJsStateJs.store;
        }, function (_srcJsComponentsBoxesJs) {
            boxes = _srcJsComponentsBoxesJs;
        }],
        execute: function () {
            Background = React.createClass({
                displayName: "Background",
                render: function render() {
                    return React.createElement('div', { className: 'l-background', id: 'main-background' });
                }
            });
            App = React.createClass({
                displayName: "App",
                _onResize: function _onResize(evt) {
                    console.log(this);
                    this.setState({ height: window.innerHeight });
                },
                getInitialState: function getInitialState() {
                    return { height: window.innerHeight };
                },
                componentDidMount: function componentDidMount() {
                    window.addEventListener("resize", this._onResize);
                    document.addEventListener('visibilitychange', this._onResize);
                },
                componentWillUnmount: function componentWillUnmount() {
                    window.removeEventListener("resize", this._onResize);
                    document.removeEventListener('visibilitychange', this._onResize);
                },
                render: function render() {
                    return React.createElement(
                        'div',
                        { className: 'l-content', style: { height: this.state.height } },
                        React.createElement(Background, null),
                        React.createElement(
                            boxes.BoxContainer,
                            null,
                            React.createElement(boxes.Name, { store: store }),
                            React.createElement(boxes.Instructions, { store: store }),
                            React.createElement(boxes.Contact, { store: store }),
                            React.createElement(boxes.BackgroundSpeed, { store: store }),
                            React.createElement(boxes.BackgroundMaxScale, { store: store }),
                            React.createElement(boxes.BackgroundMinScale, { store: store })
                        )
                    );
                }
            });

            _export('App', App);
        }
    };
});
System.registerDynamic("npm:core-js@1.2.6/library/modules/$.is-object", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.an-object", ["npm:core-js@1.2.6/library/modules/$.is-object"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('npm:core-js@1.2.6/library/modules/$.is-object');
  module.exports = function(it) {
    if (!isObject(it))
      throw TypeError(it + ' is not an object!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/core.get-iterator-method", ["npm:core-js@1.2.6/library/modules/$.classof", "npm:core-js@1.2.6/library/modules/$.wks", "npm:core-js@1.2.6/library/modules/$.iterators", "npm:core-js@1.2.6/library/modules/$.core"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var classof = $__require('npm:core-js@1.2.6/library/modules/$.classof'),
      ITERATOR = $__require('npm:core-js@1.2.6/library/modules/$.wks')('iterator'),
      Iterators = $__require('npm:core-js@1.2.6/library/modules/$.iterators');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.core').getIteratorMethod = function(it) {
    if (it != undefined)
      return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/core.get-iterator", ["npm:core-js@1.2.6/library/modules/$.an-object", "npm:core-js@1.2.6/library/modules/core.get-iterator-method", "npm:core-js@1.2.6/library/modules/$.core"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('npm:core-js@1.2.6/library/modules/$.an-object'),
      get = $__require('npm:core-js@1.2.6/library/modules/core.get-iterator-method');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.core').getIterator = function(it) {
    var iterFn = get(it);
    if (typeof iterFn != 'function')
      throw TypeError(it + ' is not iterable!');
    return anObject(iterFn.call(it));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/get-iterator", ["npm:core-js@1.2.6/library/modules/web.dom.iterable", "npm:core-js@1.2.6/library/modules/es6.string.iterator", "npm:core-js@1.2.6/library/modules/core.get-iterator"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.6/library/modules/web.dom.iterable');
  $__require('npm:core-js@1.2.6/library/modules/es6.string.iterator');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/core.get-iterator');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.34/core-js/get-iterator", ["npm:core-js@1.2.6/library/fn/get-iterator"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/get-iterator'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.add-to-unscopables", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function() {};
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iter-step", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(done, value) {
    return {
      value: value,
      done: !!done
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iobject", ["npm:core-js@1.2.6/library/modules/$.cof"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('npm:core-js@1.2.6/library/modules/$.cof');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.to-iobject", ["npm:core-js@1.2.6/library/modules/$.iobject", "npm:core-js@1.2.6/library/modules/$.defined"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var IObject = $__require('npm:core-js@1.2.6/library/modules/$.iobject'),
      defined = $__require('npm:core-js@1.2.6/library/modules/$.defined');
  module.exports = function(it) {
    return IObject(defined(it));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.array.iterator", ["npm:core-js@1.2.6/library/modules/$.add-to-unscopables", "npm:core-js@1.2.6/library/modules/$.iter-step", "npm:core-js@1.2.6/library/modules/$.iterators", "npm:core-js@1.2.6/library/modules/$.to-iobject", "npm:core-js@1.2.6/library/modules/$.iter-define"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var addToUnscopables = $__require('npm:core-js@1.2.6/library/modules/$.add-to-unscopables'),
      step = $__require('npm:core-js@1.2.6/library/modules/$.iter-step'),
      Iterators = $__require('npm:core-js@1.2.6/library/modules/$.iterators'),
      toIObject = $__require('npm:core-js@1.2.6/library/modules/$.to-iobject');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.iter-define')(Array, 'Array', function(iterated, kind) {
    this._t = toIObject(iterated);
    this._i = 0;
    this._k = kind;
  }, function() {
    var O = this._t,
        kind = this._k,
        index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == 'keys')
      return step(0, index);
    if (kind == 'values')
      return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');
  Iterators.Arguments = Iterators.Array;
  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/web.dom.iterable", ["npm:core-js@1.2.6/library/modules/es6.array.iterator", "npm:core-js@1.2.6/library/modules/$.iterators"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.6/library/modules/es6.array.iterator');
  var Iterators = $__require('npm:core-js@1.2.6/library/modules/$.iterators');
  Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.to-integer", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ceil = Math.ceil,
      floor = Math.floor;
  module.exports = function(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.defined", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.string-at", ["npm:core-js@1.2.6/library/modules/$.to-integer", "npm:core-js@1.2.6/library/modules/$.defined"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = $__require('npm:core-js@1.2.6/library/modules/$.to-integer'),
      defined = $__require('npm:core-js@1.2.6/library/modules/$.defined');
  module.exports = function(TO_STRING) {
    return function(that, pos) {
      var s = String(defined(that)),
          i = toInteger(pos),
          l = s.length,
          a,
          b;
      if (i < 0 || i >= l)
        return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.library", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.a-function", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (typeof it != 'function')
      throw TypeError(it + ' is not a function!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.ctx", ["npm:core-js@1.2.6/library/modules/$.a-function"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var aFunction = $__require('npm:core-js@1.2.6/library/modules/$.a-function');
  module.exports = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined)
      return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.export", ["npm:core-js@1.2.6/library/modules/$.global", "npm:core-js@1.2.6/library/modules/$.core", "npm:core-js@1.2.6/library/modules/$.ctx"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('npm:core-js@1.2.6/library/modules/$.global'),
      core = $__require('npm:core-js@1.2.6/library/modules/$.core'),
      ctx = $__require('npm:core-js@1.2.6/library/modules/$.ctx'),
      PROTOTYPE = 'prototype';
  var $export = function(type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        IS_WRAP = type & $export.W,
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
        key,
        own,
        out;
    if (IS_GLOBAL)
      source = name;
    for (key in source) {
      own = !IS_FORCED && target && key in target;
      if (own && key in exports)
        continue;
      out = own ? target[key] : source[key];
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? (function(C) {
        var F = function(param) {
          return this instanceof C ? new C(param) : C(param);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (IS_PROTO)
        (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  module.exports = $export;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.redefine", ["npm:core-js@1.2.6/library/modules/$.hide"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.hide');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.property-desc", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.fails", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.descriptors", ["npm:core-js@1.2.6/library/modules/$.fails"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = !$__require('npm:core-js@1.2.6/library/modules/$.fails')(function() {
    return Object.defineProperty({}, 'a', {get: function() {
        return 7;
      }}).a != 7;
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.hide", ["npm:core-js@1.2.6/library/modules/$", "npm:core-js@1.2.6/library/modules/$.property-desc", "npm:core-js@1.2.6/library/modules/$.descriptors"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.6/library/modules/$'),
      createDesc = $__require('npm:core-js@1.2.6/library/modules/$.property-desc');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.descriptors') ? function(object, key, value) {
    return $.setDesc(object, key, createDesc(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iter-create", ["npm:core-js@1.2.6/library/modules/$", "npm:core-js@1.2.6/library/modules/$.property-desc", "npm:core-js@1.2.6/library/modules/$.set-to-string-tag", "npm:core-js@1.2.6/library/modules/$.hide", "npm:core-js@1.2.6/library/modules/$.wks"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.6/library/modules/$'),
      descriptor = $__require('npm:core-js@1.2.6/library/modules/$.property-desc'),
      setToStringTag = $__require('npm:core-js@1.2.6/library/modules/$.set-to-string-tag'),
      IteratorPrototype = {};
  $__require('npm:core-js@1.2.6/library/modules/$.hide')(IteratorPrototype, $__require('npm:core-js@1.2.6/library/modules/$.wks')('iterator'), function() {
    return this;
  });
  module.exports = function(Constructor, NAME, next) {
    Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});
    setToStringTag(Constructor, NAME + ' Iterator');
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.has", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function(it, key) {
    return hasOwnProperty.call(it, key);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.set-to-string-tag", ["npm:core-js@1.2.6/library/modules/$", "npm:core-js@1.2.6/library/modules/$.has", "npm:core-js@1.2.6/library/modules/$.wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var def = $__require('npm:core-js@1.2.6/library/modules/$').setDesc,
      has = $__require('npm:core-js@1.2.6/library/modules/$.has'),
      TAG = $__require('npm:core-js@1.2.6/library/modules/$.wks')('toStringTag');
  module.exports = function(it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG))
      def(it, TAG, {
        configurable: true,
        value: tag
      });
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iter-define", ["npm:core-js@1.2.6/library/modules/$.library", "npm:core-js@1.2.6/library/modules/$.export", "npm:core-js@1.2.6/library/modules/$.redefine", "npm:core-js@1.2.6/library/modules/$.hide", "npm:core-js@1.2.6/library/modules/$.has", "npm:core-js@1.2.6/library/modules/$.iterators", "npm:core-js@1.2.6/library/modules/$.iter-create", "npm:core-js@1.2.6/library/modules/$.set-to-string-tag", "npm:core-js@1.2.6/library/modules/$", "npm:core-js@1.2.6/library/modules/$.wks"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var LIBRARY = $__require('npm:core-js@1.2.6/library/modules/$.library'),
      $export = $__require('npm:core-js@1.2.6/library/modules/$.export'),
      redefine = $__require('npm:core-js@1.2.6/library/modules/$.redefine'),
      hide = $__require('npm:core-js@1.2.6/library/modules/$.hide'),
      has = $__require('npm:core-js@1.2.6/library/modules/$.has'),
      Iterators = $__require('npm:core-js@1.2.6/library/modules/$.iterators'),
      $iterCreate = $__require('npm:core-js@1.2.6/library/modules/$.iter-create'),
      setToStringTag = $__require('npm:core-js@1.2.6/library/modules/$.set-to-string-tag'),
      getProto = $__require('npm:core-js@1.2.6/library/modules/$').getProto,
      ITERATOR = $__require('npm:core-js@1.2.6/library/modules/$.wks')('iterator'),
      BUGGY = !([].keys && 'next' in [].keys()),
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values';
  var returnThis = function() {
    return this;
  };
  module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    $iterCreate(Constructor, NAME, next);
    var getMethod = function(kind) {
      if (!BUGGY && kind in proto)
        return proto[kind];
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + ' Iterator',
        DEF_VALUES = DEFAULT == VALUES,
        VALUES_BUG = false,
        proto = Base.prototype,
        $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        $default = $native || getMethod(DEFAULT),
        methods,
        key;
    if ($native) {
      var IteratorPrototype = getProto($default.call(new Base));
      setToStringTag(IteratorPrototype, TAG, true);
      if (!LIBRARY && has(proto, FF_ITERATOR))
        hide(IteratorPrototype, ITERATOR, returnThis);
      if (DEF_VALUES && $native.name !== VALUES) {
        VALUES_BUG = true;
        $default = function values() {
          return $native.call(this);
        };
      }
    }
    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      hide(proto, ITERATOR, $default);
    }
    Iterators[NAME] = $default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: !DEF_VALUES ? $default : getMethod('entries')
      };
      if (FORCED)
        for (key in methods) {
          if (!(key in proto))
            redefine(proto, key, methods[key]);
        }
      else
        $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.string.iterator", ["npm:core-js@1.2.6/library/modules/$.string-at", "npm:core-js@1.2.6/library/modules/$.iter-define"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $at = $__require('npm:core-js@1.2.6/library/modules/$.string-at')(true);
  $__require('npm:core-js@1.2.6/library/modules/$.iter-define')(String, 'String', function(iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function() {
    var O = this._t,
        index = this._i,
        point;
    if (index >= O.length)
      return {
        value: undefined,
        done: true
      };
    point = $at(O, index);
    this._i += point.length;
    return {
      value: point,
      done: false
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.cof", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString;
  module.exports = function(it) {
    return toString.call(it).slice(8, -1);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.classof", ["npm:core-js@1.2.6/library/modules/$.cof", "npm:core-js@1.2.6/library/modules/$.wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('npm:core-js@1.2.6/library/modules/$.cof'),
      TAG = $__require('npm:core-js@1.2.6/library/modules/$.wks')('toStringTag'),
      ARG = cof(function() {
        return arguments;
      }()) == 'Arguments';
  module.exports = function(it) {
    var O,
        T,
        B;
    return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof(T = (O = Object(it))[TAG]) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.shared", ["npm:core-js@1.2.6/library/modules/$.global"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('npm:core-js@1.2.6/library/modules/$.global'),
      SHARED = '__core-js_shared__',
      store = global[SHARED] || (global[SHARED] = {});
  module.exports = function(key) {
    return store[key] || (store[key] = {});
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.uid", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var id = 0,
      px = Math.random();
  module.exports = function(key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.global", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number')
    __g = global;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.wks", ["npm:core-js@1.2.6/library/modules/$.shared", "npm:core-js@1.2.6/library/modules/$.uid", "npm:core-js@1.2.6/library/modules/$.global"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var store = $__require('npm:core-js@1.2.6/library/modules/$.shared')('wks'),
      uid = $__require('npm:core-js@1.2.6/library/modules/$.uid'),
      Symbol = $__require('npm:core-js@1.2.6/library/modules/$.global').Symbol;
  module.exports = function(name) {
    return store[name] || (store[name] = Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iterators", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {};
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.core", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var core = module.exports = {version: '1.2.6'};
  if (typeof __e == 'number')
    __e = core;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/core.is-iterable", ["npm:core-js@1.2.6/library/modules/$.classof", "npm:core-js@1.2.6/library/modules/$.wks", "npm:core-js@1.2.6/library/modules/$.iterators", "npm:core-js@1.2.6/library/modules/$.core"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var classof = $__require('npm:core-js@1.2.6/library/modules/$.classof'),
      ITERATOR = $__require('npm:core-js@1.2.6/library/modules/$.wks')('iterator'),
      Iterators = $__require('npm:core-js@1.2.6/library/modules/$.iterators');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.core').isIterable = function(it) {
    var O = Object(it);
    return O[ITERATOR] !== undefined || '@@iterator' in O || Iterators.hasOwnProperty(classof(O));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/is-iterable", ["npm:core-js@1.2.6/library/modules/web.dom.iterable", "npm:core-js@1.2.6/library/modules/es6.string.iterator", "npm:core-js@1.2.6/library/modules/core.is-iterable"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.6/library/modules/web.dom.iterable');
  $__require('npm:core-js@1.2.6/library/modules/es6.string.iterator');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/core.is-iterable');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.34/core-js/is-iterable", ["npm:core-js@1.2.6/library/fn/is-iterable"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/is-iterable'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.34/helpers/sliced-to-array", ["npm:babel-runtime@5.8.34/core-js/get-iterator", "npm:babel-runtime@5.8.34/core-js/is-iterable"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _getIterator = $__require('npm:babel-runtime@5.8.34/core-js/get-iterator')["default"];
  var _isIterable = $__require('npm:babel-runtime@5.8.34/core-js/is-iterable')["default"];
  exports["default"] = (function() {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = _getIterator(arr),
            _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"])
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    return function(arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (_isIterable(Object(arr))) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  })();
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:base64-js@0.0.8/lib/b64", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  ;
  (function(exports) {
    'use strict';
    var Arr = (typeof Uint8Array !== 'undefined') ? Uint8Array : Array;
    var PLUS = '+'.charCodeAt(0);
    var SLASH = '/'.charCodeAt(0);
    var NUMBER = '0'.charCodeAt(0);
    var LOWER = 'a'.charCodeAt(0);
    var UPPER = 'A'.charCodeAt(0);
    var PLUS_URL_SAFE = '-'.charCodeAt(0);
    var SLASH_URL_SAFE = '_'.charCodeAt(0);
    function decode(elt) {
      var code = elt.charCodeAt(0);
      if (code === PLUS || code === PLUS_URL_SAFE)
        return 62;
      if (code === SLASH || code === SLASH_URL_SAFE)
        return 63;
      if (code < NUMBER)
        return -1;
      if (code < NUMBER + 10)
        return code - NUMBER + 26 + 26;
      if (code < UPPER + 26)
        return code - UPPER;
      if (code < LOWER + 26)
        return code - LOWER + 26;
    }
    function b64ToByteArray(b64) {
      var i,
          j,
          l,
          tmp,
          placeHolders,
          arr;
      if (b64.length % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4');
      }
      var len = b64.length;
      placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;
      arr = new Arr(b64.length * 3 / 4 - placeHolders);
      l = placeHolders > 0 ? b64.length - 4 : b64.length;
      var L = 0;
      function push(v) {
        arr[L++] = v;
      }
      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3));
        push((tmp & 0xFF0000) >> 16);
        push((tmp & 0xFF00) >> 8);
        push(tmp & 0xFF);
      }
      if (placeHolders === 2) {
        tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4);
        push(tmp & 0xFF);
      } else if (placeHolders === 1) {
        tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2);
        push((tmp >> 8) & 0xFF);
        push(tmp & 0xFF);
      }
      return arr;
    }
    function uint8ToBase64(uint8) {
      var i,
          extraBytes = uint8.length % 3,
          output = "",
          temp,
          length;
      function encode(num) {
        return lookup.charAt(num);
      }
      function tripletToBase64(num) {
        return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
      }
      for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
        temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output += tripletToBase64(temp);
      }
      switch (extraBytes) {
        case 1:
          temp = uint8[uint8.length - 1];
          output += encode(temp >> 2);
          output += encode((temp << 4) & 0x3F);
          output += '==';
          break;
        case 2:
          temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
          output += encode(temp >> 10);
          output += encode((temp >> 4) & 0x3F);
          output += encode((temp << 2) & 0x3F);
          output += '=';
          break;
      }
      return output;
    }
    exports.toByteArray = b64ToByteArray;
    exports.fromByteArray = uint8ToBase64;
  }(typeof exports === 'undefined' ? (this.base64js = {}) : exports));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:base64-js@0.0.8", ["npm:base64-js@0.0.8/lib/b64"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:base64-js@0.0.8/lib/b64');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:ieee754@1.1.6/index", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e,
        m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity);
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e,
        m,
        c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
    buffer[offset + i - d] |= s * 128;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:ieee754@1.1.6", ["npm:ieee754@1.1.6/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:ieee754@1.1.6/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:isarray@1.0.0/index", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString;
  module.exports = Array.isArray || function(arr) {
    return toString.call(arr) == '[object Array]';
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:isarray@1.0.0", ["npm:isarray@1.0.0/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:isarray@1.0.0/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:buffer@3.6.0/index", ["npm:base64-js@0.0.8", "npm:ieee754@1.1.6", "npm:isarray@1.0.0"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var base64 = $__require('npm:base64-js@0.0.8');
  var ieee754 = $__require('npm:ieee754@1.1.6');
  var isArray = $__require('npm:isarray@1.0.0');
  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  Buffer.poolSize = 8192;
  var rootParent = {};
  Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
  function typedArraySupport() {
    function Bar() {}
    try {
      var arr = new Uint8Array(1);
      arr.foo = function() {
        return 42;
      };
      arr.constructor = Bar;
      return arr.foo() === 42 && arr.constructor === Bar && typeof arr.subarray === 'function' && arr.subarray(1, 1).byteLength === 0;
    } catch (e) {
      return false;
    }
  }
  function kMaxLength() {
    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
  }
  function Buffer(arg) {
    if (!(this instanceof Buffer)) {
      if (arguments.length > 1)
        return new Buffer(arg, arguments[1]);
      return new Buffer(arg);
    }
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      this.length = 0;
      this.parent = undefined;
    }
    if (typeof arg === 'number') {
      return fromNumber(this, arg);
    }
    if (typeof arg === 'string') {
      return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8');
    }
    return fromObject(this, arg);
  }
  function fromNumber(that, length) {
    that = allocate(that, length < 0 ? 0 : checked(length) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < length; i++) {
        that[i] = 0;
      }
    }
    return that;
  }
  function fromString(that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '')
      encoding = 'utf8';
    var length = byteLength(string, encoding) | 0;
    that = allocate(that, length);
    that.write(string, encoding);
    return that;
  }
  function fromObject(that, object) {
    if (Buffer.isBuffer(object))
      return fromBuffer(that, object);
    if (isArray(object))
      return fromArray(that, object);
    if (object == null) {
      throw new TypeError('must start with number, buffer, array or string');
    }
    if (typeof ArrayBuffer !== 'undefined') {
      if (object.buffer instanceof ArrayBuffer) {
        return fromTypedArray(that, object);
      }
      if (object instanceof ArrayBuffer) {
        return fromArrayBuffer(that, object);
      }
    }
    if (object.length)
      return fromArrayLike(that, object);
    return fromJsonObject(that, object);
  }
  function fromBuffer(that, buffer) {
    var length = checked(buffer.length) | 0;
    that = allocate(that, length);
    buffer.copy(that, 0, 0, length);
    return that;
  }
  function fromArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromTypedArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromArrayBuffer(that, array) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      array.byteLength;
      that = Buffer._augment(new Uint8Array(array));
    } else {
      that = fromTypedArray(that, new Uint8Array(array));
    }
    return that;
  }
  function fromArrayLike(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromJsonObject(that, object) {
    var array;
    var length = 0;
    if (object.type === 'Buffer' && isArray(object.data)) {
      array = object.data;
      length = checked(array.length) | 0;
    }
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
  } else {
    Buffer.prototype.length = undefined;
    Buffer.prototype.parent = undefined;
  }
  function allocate(that, length) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      that = Buffer._augment(new Uint8Array(length));
      that.__proto__ = Buffer.prototype;
    } else {
      that.length = length;
      that._isBuffer = true;
    }
    var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
    if (fromPool)
      that.parent = rootParent;
    return that;
  }
  function checked(length) {
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
    }
    return length | 0;
  }
  function SlowBuffer(subject, encoding) {
    if (!(this instanceof SlowBuffer))
      return new SlowBuffer(subject, encoding);
    var buf = new Buffer(subject, encoding);
    delete buf.parent;
    return buf;
  }
  Buffer.isBuffer = function isBuffer(b) {
    return !!(b != null && b._isBuffer);
  };
  Buffer.compare = function compare(a, b) {
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('Arguments must be Buffers');
    }
    if (a === b)
      return 0;
    var x = a.length;
    var y = b.length;
    var i = 0;
    var len = Math.min(x, y);
    while (i < len) {
      if (a[i] !== b[i])
        break;
      ++i;
    }
    if (i !== len) {
      x = a[i];
      y = b[i];
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'binary':
      case 'base64':
      case 'raw':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;
      default:
        return false;
    }
  };
  Buffer.concat = function concat(list, length) {
    if (!isArray(list))
      throw new TypeError('list argument must be an Array of Buffers.');
    if (list.length === 0) {
      return new Buffer(0);
    }
    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; i++) {
        length += list[i].length;
      }
    }
    var buf = new Buffer(length);
    var pos = 0;
    for (i = 0; i < list.length; i++) {
      var item = list[i];
      item.copy(buf, pos);
      pos += item.length;
    }
    return buf;
  };
  function byteLength(string, encoding) {
    if (typeof string !== 'string')
      string = '' + string;
    var len = string.length;
    if (len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case 'ascii':
        case 'binary':
        case 'raw':
        case 'raws':
          return len;
        case 'utf8':
        case 'utf-8':
          return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;
        case 'hex':
          return len >>> 1;
        case 'base64':
          return base64ToBytes(string).length;
        default:
          if (loweredCase)
            return utf8ToBytes(string).length;
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    start = start | 0;
    end = end === undefined || end === Infinity ? this.length : end | 0;
    if (!encoding)
      encoding = 'utf8';
    if (start < 0)
      start = 0;
    if (end > this.length)
      end = this.length;
    if (end <= start)
      return '';
    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);
        case 'ascii':
          return asciiSlice(this, start, end);
        case 'binary':
          return binarySlice(this, start, end);
        case 'base64':
          return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.prototype.toString = function toString() {
    var length = this.length | 0;
    if (length === 0)
      return '';
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b))
      throw new TypeError('Argument must be a Buffer');
    if (this === b)
      return true;
    return Buffer.compare(this, b) === 0;
  };
  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max)
        str += ' ... ';
    }
    return '<Buffer ' + str + '>';
  };
  Buffer.prototype.compare = function compare(b) {
    if (!Buffer.isBuffer(b))
      throw new TypeError('Argument must be a Buffer');
    if (this === b)
      return 0;
    return Buffer.compare(this, b);
  };
  Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
    if (byteOffset > 0x7fffffff)
      byteOffset = 0x7fffffff;
    else if (byteOffset < -0x80000000)
      byteOffset = -0x80000000;
    byteOffset >>= 0;
    if (this.length === 0)
      return -1;
    if (byteOffset >= this.length)
      return -1;
    if (byteOffset < 0)
      byteOffset = Math.max(this.length + byteOffset, 0);
    if (typeof val === 'string') {
      if (val.length === 0)
        return -1;
      return String.prototype.indexOf.call(this, val, byteOffset);
    }
    if (Buffer.isBuffer(val)) {
      return arrayIndexOf(this, val, byteOffset);
    }
    if (typeof val === 'number') {
      if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
        return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
      }
      return arrayIndexOf(this, [val], byteOffset);
    }
    function arrayIndexOf(arr, val, byteOffset) {
      var foundIndex = -1;
      for (var i = 0; byteOffset + i < arr.length; i++) {
        if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === val.length)
            return byteOffset + foundIndex;
        } else {
          foundIndex = -1;
        }
      }
      return -1;
    }
    throw new TypeError('val must be string, number or Buffer');
  };
  Buffer.prototype.get = function get(offset) {
    console.log('.get() is deprecated. Access using array indexes instead.');
    return this.readUInt8(offset);
  };
  Buffer.prototype.set = function set(v, offset) {
    console.log('.set() is deprecated. Access using array indexes instead.');
    return this.writeUInt8(v, offset);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0)
      throw new Error('Invalid hex string');
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; i++) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed))
        throw new Error('Invalid hex string');
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function binaryWrite(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined)
          encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    } else {
      var swap = encoding;
      encoding = offset;
      offset = length | 0;
      length = swap;
    }
    var remaining = this.length - offset;
    if (length === undefined || length > remaining)
      length = remaining;
    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('attempt to write outside buffer bounds');
    }
    if (!encoding)
      encoding = 'utf8';
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);
        case 'ascii':
          return asciiWrite(this, string, offset, length);
        case 'binary':
          return binaryWrite(this, string, offset, length);
        case 'base64':
          return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = (firstByte > 0xEF) ? 4 : (firstByte > 0xDF) ? 3 : (firstByte > 0xBF) ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        var secondByte,
            thirdByte,
            fourthByte,
            tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 0x1000;
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret;
  }
  function binarySlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = '';
    for (var i = start; i < end; i++) {
      out += toHex(buf[i]);
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = Buffer._augment(this.subarray(start, end));
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; i++) {
        newBuf[i] = this[i + start];
      }
    }
    if (newBuf.length)
      newBuf.parent = this.parent || this;
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0)
      throw new RangeError('offset is not uint');
    if (offset + ext > length)
      throw new RangeError('Trying to access beyond buffer length');
  }
  Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }
    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }
    return val;
  };
  Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8);
  };
  Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1];
  };
  Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ((this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + (this[offset + 3] * 0x1000000);
  };
  Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] * 0x1000000) + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]);
  };
  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80))
      return (this[offset]);
    return ((0xff - this[offset] + 1) * -1);
  };
  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24);
  };
  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | (this[offset + 3]);
  };
  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf))
      throw new TypeError('buffer must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError('index out of range');
  }
  Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    this[offset] = (value & 0xff);
    return offset + 1;
  };
  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 0xffff + value + 1;
    for (var i = 0,
        j = Math.min(buf.length - offset, 2); i < j; i++) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }
  Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 0xffffffff + value + 1;
    for (var i = 0,
        j = Math.min(buf.length - offset, 4); i < j; i++) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }
  Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    if (value < 0)
      value = 0xff + value + 1;
    this[offset] = (value & 0xff);
    return offset + 1;
  };
  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0)
      value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (value > max || value < min)
      throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError('index out of range');
    if (offset < 0)
      throw new RangeError('index out of range');
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }
    if (start < 0 || start >= this.length)
      throw new RangeError('sourceStart out of bounds');
    if (end < 0)
      throw new RangeError('sourceEnd out of bounds');
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len = end - start;
    var i;
    if (this === target && start < targetStart && targetStart < end) {
      for (i = len - 1; i >= 0; i--) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      for (i = 0; i < len; i++) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      target._set(this.subarray(start, start + len), targetStart);
    }
    return len;
  };
  Buffer.prototype.fill = function fill(value, start, end) {
    if (!value)
      value = 0;
    if (!start)
      start = 0;
    if (!end)
      end = this.length;
    if (end < start)
      throw new RangeError('end < start');
    if (end === start)
      return;
    if (this.length === 0)
      return;
    if (start < 0 || start >= this.length)
      throw new RangeError('start out of bounds');
    if (end < 0 || end > this.length)
      throw new RangeError('end out of bounds');
    var i;
    if (typeof value === 'number') {
      for (i = start; i < end; i++) {
        this[i] = value;
      }
    } else {
      var bytes = utf8ToBytes(value.toString());
      var len = bytes.length;
      for (i = start; i < end; i++) {
        this[i] = bytes[i % len];
      }
    }
    return this;
  };
  Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
    if (typeof Uint8Array !== 'undefined') {
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        return (new Buffer(this)).buffer;
      } else {
        var buf = new Uint8Array(this.length);
        for (var i = 0,
            len = buf.length; i < len; i += 1) {
          buf[i] = this[i];
        }
        return buf.buffer;
      }
    } else {
      throw new TypeError('Buffer.toArrayBuffer not supported in this browser');
    }
  };
  var BP = Buffer.prototype;
  Buffer._augment = function _augment(arr) {
    arr.constructor = Buffer;
    arr._isBuffer = true;
    arr._set = arr.set;
    arr.get = BP.get;
    arr.set = BP.set;
    arr.write = BP.write;
    arr.toString = BP.toString;
    arr.toLocaleString = BP.toString;
    arr.toJSON = BP.toJSON;
    arr.equals = BP.equals;
    arr.compare = BP.compare;
    arr.indexOf = BP.indexOf;
    arr.copy = BP.copy;
    arr.slice = BP.slice;
    arr.readUIntLE = BP.readUIntLE;
    arr.readUIntBE = BP.readUIntBE;
    arr.readUInt8 = BP.readUInt8;
    arr.readUInt16LE = BP.readUInt16LE;
    arr.readUInt16BE = BP.readUInt16BE;
    arr.readUInt32LE = BP.readUInt32LE;
    arr.readUInt32BE = BP.readUInt32BE;
    arr.readIntLE = BP.readIntLE;
    arr.readIntBE = BP.readIntBE;
    arr.readInt8 = BP.readInt8;
    arr.readInt16LE = BP.readInt16LE;
    arr.readInt16BE = BP.readInt16BE;
    arr.readInt32LE = BP.readInt32LE;
    arr.readInt32BE = BP.readInt32BE;
    arr.readFloatLE = BP.readFloatLE;
    arr.readFloatBE = BP.readFloatBE;
    arr.readDoubleLE = BP.readDoubleLE;
    arr.readDoubleBE = BP.readDoubleBE;
    arr.writeUInt8 = BP.writeUInt8;
    arr.writeUIntLE = BP.writeUIntLE;
    arr.writeUIntBE = BP.writeUIntBE;
    arr.writeUInt16LE = BP.writeUInt16LE;
    arr.writeUInt16BE = BP.writeUInt16BE;
    arr.writeUInt32LE = BP.writeUInt32LE;
    arr.writeUInt32BE = BP.writeUInt32BE;
    arr.writeIntLE = BP.writeIntLE;
    arr.writeIntBE = BP.writeIntBE;
    arr.writeInt8 = BP.writeInt8;
    arr.writeInt16LE = BP.writeInt16LE;
    arr.writeInt16BE = BP.writeInt16BE;
    arr.writeInt32LE = BP.writeInt32LE;
    arr.writeInt32BE = BP.writeInt32BE;
    arr.writeFloatLE = BP.writeFloatLE;
    arr.writeFloatBE = BP.writeFloatBE;
    arr.writeDoubleLE = BP.writeDoubleLE;
    arr.writeDoubleBE = BP.writeDoubleBE;
    arr.fill = BP.fill;
    arr.inspect = BP.inspect;
    arr.toArrayBuffer = BP.toArrayBuffer;
    return arr;
  };
  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    if (str.length < 2)
      return '';
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str;
  }
  function stringtrim(str) {
    if (str.trim)
      return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
  }
  function toHex(n) {
    if (n < 16)
      return '0' + n.toString(16);
    return n.toString(16);
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length; i++) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        if (!leadSurrogate) {
          if (codePoint > 0xDBFF) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1)
            bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(0xEF, 0xBF, 0xBD);
      }
      leadSurrogate = null;
      if (codePoint < 0x80) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c,
        hi,
        lo;
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; i++) {
      if ((i + offset >= dst.length) || (i >= src.length))
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:buffer@3.6.0", ["npm:buffer@3.6.0/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:buffer@3.6.0/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-buffer@0.1.0/index", ["npm:buffer@3.6.0"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('buffer') : $__require('npm:buffer@3.6.0');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-buffer@0.1.0", ["github:jspm/nodelibs-buffer@0.1.0/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:jspm/nodelibs-buffer@0.1.0/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:three.js@0.73.0/build/three", ["github:jspm/nodelibs-buffer@0.1.0", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(Buffer, process) {
    var THREE = {REVISION: '73'};
    if (typeof define === 'function' && define.amd) {
      define('three', THREE);
    } else if ('undefined' !== typeof exports && 'undefined' !== typeof module) {
      module.exports = THREE;
    }
    if (self.requestAnimationFrame === undefined || self.cancelAnimationFrame === undefined) {
      (function() {
        var lastTime = 0;
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        for (var x = 0; x < vendors.length && !self.requestAnimationFrame; ++x) {
          self.requestAnimationFrame = self[vendors[x] + 'RequestAnimationFrame'];
          self.cancelAnimationFrame = self[vendors[x] + 'CancelAnimationFrame'] || self[vendors[x] + 'CancelRequestAnimationFrame'];
        }
        if (self.requestAnimationFrame === undefined && self.setTimeout !== undefined) {
          self.requestAnimationFrame = function(callback) {
            var currTime = Date.now(),
                timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = self.setTimeout(function() {
              callback(currTime + timeToCall);
            }, timeToCall);
            lastTime = currTime + timeToCall;
            return id;
          };
        }
        if (self.cancelAnimationFrame === undefined && self.clearTimeout !== undefined) {
          self.cancelAnimationFrame = function(id) {
            self.clearTimeout(id);
          };
        }
      })();
    }
    if (self.performance === undefined) {
      self.performance = {};
    }
    if (self.performance.now === undefined) {
      (function() {
        var start = Date.now();
        self.performance.now = function() {
          return Date.now() - start;
        };
      })();
    }
    if (Number.EPSILON === undefined) {
      Number.EPSILON = Math.pow(2, -52);
    }
    if (Math.sign === undefined) {
      Math.sign = function(x) {
        return (x < 0) ? -1 : (x > 0) ? 1 : +x;
      };
    }
    if (Function.prototype.name === undefined && Object.defineProperty !== undefined) {
      Object.defineProperty(Function.prototype, 'name', {get: function() {
          return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];
        }});
    }
    THREE.MOUSE = {
      LEFT: 0,
      MIDDLE: 1,
      RIGHT: 2
    };
    THREE.CullFaceNone = 0;
    THREE.CullFaceBack = 1;
    THREE.CullFaceFront = 2;
    THREE.CullFaceFrontBack = 3;
    THREE.FrontFaceDirectionCW = 0;
    THREE.FrontFaceDirectionCCW = 1;
    THREE.BasicShadowMap = 0;
    THREE.PCFShadowMap = 1;
    THREE.PCFSoftShadowMap = 2;
    THREE.FrontSide = 0;
    THREE.BackSide = 1;
    THREE.DoubleSide = 2;
    THREE.FlatShading = 1;
    THREE.SmoothShading = 2;
    THREE.NoColors = 0;
    THREE.FaceColors = 1;
    THREE.VertexColors = 2;
    THREE.NoBlending = 0;
    THREE.NormalBlending = 1;
    THREE.AdditiveBlending = 2;
    THREE.SubtractiveBlending = 3;
    THREE.MultiplyBlending = 4;
    THREE.CustomBlending = 5;
    THREE.AddEquation = 100;
    THREE.SubtractEquation = 101;
    THREE.ReverseSubtractEquation = 102;
    THREE.MinEquation = 103;
    THREE.MaxEquation = 104;
    THREE.ZeroFactor = 200;
    THREE.OneFactor = 201;
    THREE.SrcColorFactor = 202;
    THREE.OneMinusSrcColorFactor = 203;
    THREE.SrcAlphaFactor = 204;
    THREE.OneMinusSrcAlphaFactor = 205;
    THREE.DstAlphaFactor = 206;
    THREE.OneMinusDstAlphaFactor = 207;
    THREE.DstColorFactor = 208;
    THREE.OneMinusDstColorFactor = 209;
    THREE.SrcAlphaSaturateFactor = 210;
    THREE.NeverDepth = 0;
    THREE.AlwaysDepth = 1;
    THREE.LessDepth = 2;
    THREE.LessEqualDepth = 3;
    THREE.EqualDepth = 4;
    THREE.GreaterEqualDepth = 5;
    THREE.GreaterDepth = 6;
    THREE.NotEqualDepth = 7;
    THREE.MultiplyOperation = 0;
    THREE.MixOperation = 1;
    THREE.AddOperation = 2;
    THREE.UVMapping = 300;
    THREE.CubeReflectionMapping = 301;
    THREE.CubeRefractionMapping = 302;
    THREE.EquirectangularReflectionMapping = 303;
    THREE.EquirectangularRefractionMapping = 304;
    THREE.SphericalReflectionMapping = 305;
    THREE.RepeatWrapping = 1000;
    THREE.ClampToEdgeWrapping = 1001;
    THREE.MirroredRepeatWrapping = 1002;
    THREE.NearestFilter = 1003;
    THREE.NearestMipMapNearestFilter = 1004;
    THREE.NearestMipMapLinearFilter = 1005;
    THREE.LinearFilter = 1006;
    THREE.LinearMipMapNearestFilter = 1007;
    THREE.LinearMipMapLinearFilter = 1008;
    THREE.UnsignedByteType = 1009;
    THREE.ByteType = 1010;
    THREE.ShortType = 1011;
    THREE.UnsignedShortType = 1012;
    THREE.IntType = 1013;
    THREE.UnsignedIntType = 1014;
    THREE.FloatType = 1015;
    THREE.HalfFloatType = 1025;
    THREE.UnsignedShort4444Type = 1016;
    THREE.UnsignedShort5551Type = 1017;
    THREE.UnsignedShort565Type = 1018;
    THREE.AlphaFormat = 1019;
    THREE.RGBFormat = 1020;
    THREE.RGBAFormat = 1021;
    THREE.LuminanceFormat = 1022;
    THREE.LuminanceAlphaFormat = 1023;
    THREE.RGBEFormat = THREE.RGBAFormat;
    THREE.RGB_S3TC_DXT1_Format = 2001;
    THREE.RGBA_S3TC_DXT1_Format = 2002;
    THREE.RGBA_S3TC_DXT3_Format = 2003;
    THREE.RGBA_S3TC_DXT5_Format = 2004;
    THREE.RGB_PVRTC_4BPPV1_Format = 2100;
    THREE.RGB_PVRTC_2BPPV1_Format = 2101;
    THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
    THREE.RGBA_PVRTC_2BPPV1_Format = 2103;
    THREE.LoopOnce = 2200;
    THREE.LoopRepeat = 2201;
    THREE.LoopPingPong = 2202;
    THREE.Projector = function() {
      console.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.');
      this.projectVector = function(vector, camera) {
        console.warn('THREE.Projector: .projectVector() is now vector.project().');
        vector.project(camera);
      };
      this.unprojectVector = function(vector, camera) {
        console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');
        vector.unproject(camera);
      };
      this.pickingRay = function(vector, camera) {
        console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');
      };
    };
    THREE.CanvasRenderer = function() {
      console.error('THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js');
      this.domElement = document.createElement('canvas');
      this.clear = function() {};
      this.render = function() {};
      this.setClearColor = function() {};
      this.setSize = function() {};
    };
    THREE.Color = function(color) {
      if (arguments.length === 3) {
        return this.fromArray(arguments);
      }
      return this.set(color);
    };
    THREE.Color.prototype = {
      constructor: THREE.Color,
      r: 1,
      g: 1,
      b: 1,
      set: function(value) {
        if (value instanceof THREE.Color) {
          this.copy(value);
        } else if (typeof value === 'number') {
          this.setHex(value);
        } else if (typeof value === 'string') {
          this.setStyle(value);
        }
        return this;
      },
      setHex: function(hex) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        return this;
      },
      setRGB: function(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
        return this;
      },
      setHSL: function() {
        function hue2rgb(p, q, t) {
          if (t < 0)
            t += 1;
          if (t > 1)
            t -= 1;
          if (t < 1 / 6)
            return p + (q - p) * 6 * t;
          if (t < 1 / 2)
            return q;
          if (t < 2 / 3)
            return p + (q - p) * 6 * (2 / 3 - t);
          return p;
        }
        return function(h, s, l) {
          h = THREE.Math.euclideanModulo(h, 1);
          s = THREE.Math.clamp(s, 0, 1);
          l = THREE.Math.clamp(l, 0, 1);
          if (s === 0) {
            this.r = this.g = this.b = l;
          } else {
            var p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
            var q = (2 * l) - p;
            this.r = hue2rgb(q, p, h + 1 / 3);
            this.g = hue2rgb(q, p, h);
            this.b = hue2rgb(q, p, h - 1 / 3);
          }
          return this;
        };
      }(),
      setStyle: function(style) {
        function handleAlpha(string) {
          if (string === undefined)
            return;
          if (parseFloat(string) < 1) {
            console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
          }
        }
        var m;
        if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
          var color;
          var name = m[1];
          var components = m[2];
          switch (name) {
            case 'rgb':
            case 'rgba':
              if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                handleAlpha(color[5]);
                return this;
              }
              if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                handleAlpha(color[5]);
                return this;
              }
              break;
            case 'hsl':
            case 'hsla':
              if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                var h = parseFloat(color[1]) / 360;
                var s = parseInt(color[2], 10) / 100;
                var l = parseInt(color[3], 10) / 100;
                handleAlpha(color[5]);
                return this.setHSL(h, s, l);
              }
              break;
          }
        } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
          var hex = m[1];
          var size = hex.length;
          if (size === 3) {
            this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
            this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
            this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
            return this;
          } else if (size === 6) {
            this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
            this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
            this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
            return this;
          }
        }
        if (style && style.length > 0) {
          var hex = THREE.ColorKeywords[style];
          if (hex !== undefined) {
            this.setHex(hex);
          } else {
            console.warn('THREE.Color: Unknown color ' + style);
          }
        }
        return this;
      },
      clone: function() {
        return new this.constructor(this.r, this.g, this.b);
      },
      copy: function(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
      },
      copyGammaToLinear: function(color, gammaFactor) {
        if (gammaFactor === undefined)
          gammaFactor = 2.0;
        this.r = Math.pow(color.r, gammaFactor);
        this.g = Math.pow(color.g, gammaFactor);
        this.b = Math.pow(color.b, gammaFactor);
        return this;
      },
      copyLinearToGamma: function(color, gammaFactor) {
        if (gammaFactor === undefined)
          gammaFactor = 2.0;
        var safeInverse = (gammaFactor > 0) ? (1.0 / gammaFactor) : 1.0;
        this.r = Math.pow(color.r, safeInverse);
        this.g = Math.pow(color.g, safeInverse);
        this.b = Math.pow(color.b, safeInverse);
        return this;
      },
      convertGammaToLinear: function() {
        var r = this.r,
            g = this.g,
            b = this.b;
        this.r = r * r;
        this.g = g * g;
        this.b = b * b;
        return this;
      },
      convertLinearToGamma: function() {
        this.r = Math.sqrt(this.r);
        this.g = Math.sqrt(this.g);
        this.b = Math.sqrt(this.b);
        return this;
      },
      getHex: function() {
        return (this.r * 255) << 16 ^ (this.g * 255) << 8 ^ (this.b * 255) << 0;
      },
      getHexString: function() {
        return ('000000' + this.getHex().toString(16)).slice(-6);
      },
      getHSL: function(optionalTarget) {
        var hsl = optionalTarget || {
          h: 0,
          s: 0,
          l: 0
        };
        var r = this.r,
            g = this.g,
            b = this.b;
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var hue,
            saturation;
        var lightness = (min + max) / 2.0;
        if (min === max) {
          hue = 0;
          saturation = 0;
        } else {
          var delta = max - min;
          saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
          switch (max) {
            case r:
              hue = (g - b) / delta + (g < b ? 6 : 0);
              break;
            case g:
              hue = (b - r) / delta + 2;
              break;
            case b:
              hue = (r - g) / delta + 4;
              break;
          }
          hue /= 6;
        }
        hsl.h = hue;
        hsl.s = saturation;
        hsl.l = lightness;
        return hsl;
      },
      getStyle: function() {
        return 'rgb(' + ((this.r * 255) | 0) + ',' + ((this.g * 255) | 0) + ',' + ((this.b * 255) | 0) + ')';
      },
      offsetHSL: function(h, s, l) {
        var hsl = this.getHSL();
        hsl.h += h;
        hsl.s += s;
        hsl.l += l;
        this.setHSL(hsl.h, hsl.s, hsl.l);
        return this;
      },
      add: function(color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        return this;
      },
      addColors: function(color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
      },
      addScalar: function(s) {
        this.r += s;
        this.g += s;
        this.b += s;
        return this;
      },
      multiply: function(color) {
        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;
        return this;
      },
      multiplyScalar: function(s) {
        this.r *= s;
        this.g *= s;
        this.b *= s;
        return this;
      },
      lerp: function(color, alpha) {
        this.r += (color.r - this.r) * alpha;
        this.g += (color.g - this.g) * alpha;
        this.b += (color.b - this.b) * alpha;
        return this;
      },
      equals: function(c) {
        return (c.r === this.r) && (c.g === this.g) && (c.b === this.b);
      },
      fromArray: function(array, offset) {
        if (offset === undefined)
          offset = 0;
        this.r = array[offset];
        this.g = array[offset + 1];
        this.b = array[offset + 2];
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        return array;
      }
    };
    THREE.ColorKeywords = {
      'aliceblue': 0xF0F8FF,
      'antiquewhite': 0xFAEBD7,
      'aqua': 0x00FFFF,
      'aquamarine': 0x7FFFD4,
      'azure': 0xF0FFFF,
      'beige': 0xF5F5DC,
      'bisque': 0xFFE4C4,
      'black': 0x000000,
      'blanchedalmond': 0xFFEBCD,
      'blue': 0x0000FF,
      'blueviolet': 0x8A2BE2,
      'brown': 0xA52A2A,
      'burlywood': 0xDEB887,
      'cadetblue': 0x5F9EA0,
      'chartreuse': 0x7FFF00,
      'chocolate': 0xD2691E,
      'coral': 0xFF7F50,
      'cornflowerblue': 0x6495ED,
      'cornsilk': 0xFFF8DC,
      'crimson': 0xDC143C,
      'cyan': 0x00FFFF,
      'darkblue': 0x00008B,
      'darkcyan': 0x008B8B,
      'darkgoldenrod': 0xB8860B,
      'darkgray': 0xA9A9A9,
      'darkgreen': 0x006400,
      'darkgrey': 0xA9A9A9,
      'darkkhaki': 0xBDB76B,
      'darkmagenta': 0x8B008B,
      'darkolivegreen': 0x556B2F,
      'darkorange': 0xFF8C00,
      'darkorchid': 0x9932CC,
      'darkred': 0x8B0000,
      'darksalmon': 0xE9967A,
      'darkseagreen': 0x8FBC8F,
      'darkslateblue': 0x483D8B,
      'darkslategray': 0x2F4F4F,
      'darkslategrey': 0x2F4F4F,
      'darkturquoise': 0x00CED1,
      'darkviolet': 0x9400D3,
      'deeppink': 0xFF1493,
      'deepskyblue': 0x00BFFF,
      'dimgray': 0x696969,
      'dimgrey': 0x696969,
      'dodgerblue': 0x1E90FF,
      'firebrick': 0xB22222,
      'floralwhite': 0xFFFAF0,
      'forestgreen': 0x228B22,
      'fuchsia': 0xFF00FF,
      'gainsboro': 0xDCDCDC,
      'ghostwhite': 0xF8F8FF,
      'gold': 0xFFD700,
      'goldenrod': 0xDAA520,
      'gray': 0x808080,
      'green': 0x008000,
      'greenyellow': 0xADFF2F,
      'grey': 0x808080,
      'honeydew': 0xF0FFF0,
      'hotpink': 0xFF69B4,
      'indianred': 0xCD5C5C,
      'indigo': 0x4B0082,
      'ivory': 0xFFFFF0,
      'khaki': 0xF0E68C,
      'lavender': 0xE6E6FA,
      'lavenderblush': 0xFFF0F5,
      'lawngreen': 0x7CFC00,
      'lemonchiffon': 0xFFFACD,
      'lightblue': 0xADD8E6,
      'lightcoral': 0xF08080,
      'lightcyan': 0xE0FFFF,
      'lightgoldenrodyellow': 0xFAFAD2,
      'lightgray': 0xD3D3D3,
      'lightgreen': 0x90EE90,
      'lightgrey': 0xD3D3D3,
      'lightpink': 0xFFB6C1,
      'lightsalmon': 0xFFA07A,
      'lightseagreen': 0x20B2AA,
      'lightskyblue': 0x87CEFA,
      'lightslategray': 0x778899,
      'lightslategrey': 0x778899,
      'lightsteelblue': 0xB0C4DE,
      'lightyellow': 0xFFFFE0,
      'lime': 0x00FF00,
      'limegreen': 0x32CD32,
      'linen': 0xFAF0E6,
      'magenta': 0xFF00FF,
      'maroon': 0x800000,
      'mediumaquamarine': 0x66CDAA,
      'mediumblue': 0x0000CD,
      'mediumorchid': 0xBA55D3,
      'mediumpurple': 0x9370DB,
      'mediumseagreen': 0x3CB371,
      'mediumslateblue': 0x7B68EE,
      'mediumspringgreen': 0x00FA9A,
      'mediumturquoise': 0x48D1CC,
      'mediumvioletred': 0xC71585,
      'midnightblue': 0x191970,
      'mintcream': 0xF5FFFA,
      'mistyrose': 0xFFE4E1,
      'moccasin': 0xFFE4B5,
      'navajowhite': 0xFFDEAD,
      'navy': 0x000080,
      'oldlace': 0xFDF5E6,
      'olive': 0x808000,
      'olivedrab': 0x6B8E23,
      'orange': 0xFFA500,
      'orangered': 0xFF4500,
      'orchid': 0xDA70D6,
      'palegoldenrod': 0xEEE8AA,
      'palegreen': 0x98FB98,
      'paleturquoise': 0xAFEEEE,
      'palevioletred': 0xDB7093,
      'papayawhip': 0xFFEFD5,
      'peachpuff': 0xFFDAB9,
      'peru': 0xCD853F,
      'pink': 0xFFC0CB,
      'plum': 0xDDA0DD,
      'powderblue': 0xB0E0E6,
      'purple': 0x800080,
      'red': 0xFF0000,
      'rosybrown': 0xBC8F8F,
      'royalblue': 0x4169E1,
      'saddlebrown': 0x8B4513,
      'salmon': 0xFA8072,
      'sandybrown': 0xF4A460,
      'seagreen': 0x2E8B57,
      'seashell': 0xFFF5EE,
      'sienna': 0xA0522D,
      'silver': 0xC0C0C0,
      'skyblue': 0x87CEEB,
      'slateblue': 0x6A5ACD,
      'slategray': 0x708090,
      'slategrey': 0x708090,
      'snow': 0xFFFAFA,
      'springgreen': 0x00FF7F,
      'steelblue': 0x4682B4,
      'tan': 0xD2B48C,
      'teal': 0x008080,
      'thistle': 0xD8BFD8,
      'tomato': 0xFF6347,
      'turquoise': 0x40E0D0,
      'violet': 0xEE82EE,
      'wheat': 0xF5DEB3,
      'white': 0xFFFFFF,
      'whitesmoke': 0xF5F5F5,
      'yellow': 0xFFFF00,
      'yellowgreen': 0x9ACD32
    };
    THREE.Quaternion = function(x, y, z, w) {
      this._x = x || 0;
      this._y = y || 0;
      this._z = z || 0;
      this._w = (w !== undefined) ? w : 1;
    };
    THREE.Quaternion.prototype = {
      constructor: THREE.Quaternion,
      get x() {
        return this._x;
      },
      set x(value) {
        this._x = value;
        this.onChangeCallback();
      },
      get y() {
        return this._y;
      },
      set y(value) {
        this._y = value;
        this.onChangeCallback();
      },
      get z() {
        return this._z;
      },
      set z(value) {
        this._z = value;
        this.onChangeCallback();
      },
      get w() {
        return this._w;
      },
      set w(value) {
        this._w = value;
        this.onChangeCallback();
      },
      set: function(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this.onChangeCallback();
        return this;
      },
      clone: function() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      },
      copy: function(quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this.onChangeCallback();
        return this;
      },
      setFromEuler: function(euler, update) {
        if (euler instanceof THREE.Euler === false) {
          throw new Error('THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
        }
        var c1 = Math.cos(euler._x / 2);
        var c2 = Math.cos(euler._y / 2);
        var c3 = Math.cos(euler._z / 2);
        var s1 = Math.sin(euler._x / 2);
        var s2 = Math.sin(euler._y / 2);
        var s3 = Math.sin(euler._z / 2);
        var order = euler.order;
        if (order === 'XYZ') {
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === 'YXZ') {
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (order === 'ZXY') {
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === 'ZYX') {
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (order === 'YZX') {
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === 'XZY') {
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
        }
        if (update !== false)
          this.onChangeCallback();
        return this;
      },
      setFromAxisAngle: function(axis, angle) {
        var halfAngle = angle / 2,
            s = Math.sin(halfAngle);
        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos(halfAngle);
        this.onChangeCallback();
        return this;
      },
      setFromRotationMatrix: function(m) {
        var te = m.elements,
            m11 = te[0],
            m12 = te[4],
            m13 = te[8],
            m21 = te[1],
            m22 = te[5],
            m23 = te[9],
            m31 = te[2],
            m32 = te[6],
            m33 = te[10],
            trace = m11 + m22 + m33,
            s;
        if (trace > 0) {
          s = 0.5 / Math.sqrt(trace + 1.0);
          this._w = 0.25 / s;
          this._x = (m32 - m23) * s;
          this._y = (m13 - m31) * s;
          this._z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
          s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
          this._w = (m32 - m23) / s;
          this._x = 0.25 * s;
          this._y = (m12 + m21) / s;
          this._z = (m13 + m31) / s;
        } else if (m22 > m33) {
          s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
          this._w = (m13 - m31) / s;
          this._x = (m12 + m21) / s;
          this._y = 0.25 * s;
          this._z = (m23 + m32) / s;
        } else {
          s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
          this._w = (m21 - m12) / s;
          this._x = (m13 + m31) / s;
          this._y = (m23 + m32) / s;
          this._z = 0.25 * s;
        }
        this.onChangeCallback();
        return this;
      },
      setFromUnitVectors: function() {
        var v1,
            r;
        var EPS = 0.000001;
        return function(vFrom, vTo) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          r = vFrom.dot(vTo) + 1;
          if (r < EPS) {
            r = 0;
            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
              v1.set(-vFrom.y, vFrom.x, 0);
            } else {
              v1.set(0, -vFrom.z, vFrom.y);
            }
          } else {
            v1.crossVectors(vFrom, vTo);
          }
          this._x = v1.x;
          this._y = v1.y;
          this._z = v1.z;
          this._w = r;
          this.normalize();
          return this;
        };
      }(),
      inverse: function() {
        this.conjugate().normalize();
        return this;
      },
      conjugate: function() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this.onChangeCallback();
        return this;
      },
      dot: function(v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
      },
      lengthSq: function() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
      },
      length: function() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
      },
      normalize: function() {
        var l = this.length();
        if (l === 0) {
          this._x = 0;
          this._y = 0;
          this._z = 0;
          this._w = 1;
        } else {
          l = 1 / l;
          this._x = this._x * l;
          this._y = this._y * l;
          this._z = this._z * l;
          this._w = this._w * l;
        }
        this.onChangeCallback();
        return this;
      },
      multiply: function(q, p) {
        if (p !== undefined) {
          console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
          return this.multiplyQuaternions(q, p);
        }
        return this.multiplyQuaternions(this, q);
      },
      multiplyQuaternions: function(a, b) {
        var qax = a._x,
            qay = a._y,
            qaz = a._z,
            qaw = a._w;
        var qbx = b._x,
            qby = b._y,
            qbz = b._z,
            qbw = b._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this.onChangeCallback();
        return this;
      },
      multiplyVector3: function(vector) {
        console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
        return vector.applyQuaternion(this);
      },
      slerp: function(qb, t) {
        if (t === 0)
          return this;
        if (t === 1)
          return this.copy(qb);
        var x = this._x,
            y = this._y,
            z = this._z,
            w = this._w;
        var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
        if (cosHalfTheta < 0) {
          this._w = -qb._w;
          this._x = -qb._x;
          this._y = -qb._y;
          this._z = -qb._z;
          cosHalfTheta = -cosHalfTheta;
        } else {
          this.copy(qb);
        }
        if (cosHalfTheta >= 1.0) {
          this._w = w;
          this._x = x;
          this._y = y;
          this._z = z;
          return this;
        }
        var halfTheta = Math.acos(cosHalfTheta);
        var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);
        if (Math.abs(sinHalfTheta) < 0.001) {
          this._w = 0.5 * (w + this._w);
          this._x = 0.5 * (x + this._x);
          this._y = 0.5 * (y + this._y);
          this._z = 0.5 * (z + this._z);
          return this;
        }
        var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
            ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this._w = (w * ratioA + this._w * ratioB);
        this._x = (x * ratioA + this._x * ratioB);
        this._y = (y * ratioA + this._y * ratioB);
        this._z = (z * ratioA + this._z * ratioB);
        this.onChangeCallback();
        return this;
      },
      equals: function(quaternion) {
        return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w);
      },
      fromArray: function(array, offset) {
        if (offset === undefined)
          offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this.onChangeCallback();
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._w;
        return array;
      },
      onChange: function(callback) {
        this.onChangeCallback = callback;
        return this;
      },
      onChangeCallback: function() {}
    };
    THREE.Quaternion.slerp = function(qa, qb, qm, t) {
      return qm.copy(qa).slerp(qb, t);
    };
    THREE.Vector2 = function(x, y) {
      this.x = x || 0;
      this.y = y || 0;
    };
    THREE.Vector2.prototype = {
      constructor: THREE.Vector2,
      get width() {
        return this.x;
      },
      set width(value) {
        this.x = value;
      },
      get height() {
        return this.y;
      },
      set height(value) {
        this.y = value;
      },
      set: function(x, y) {
        this.x = x;
        this.y = y;
        return this;
      },
      setX: function(x) {
        this.x = x;
        return this;
      },
      setY: function(y) {
        this.y = y;
        return this;
      },
      setComponent: function(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      getComponent: function(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      clone: function() {
        return new this.constructor(this.x, this.y);
      },
      copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
      },
      add: function(v, w) {
        if (w !== undefined) {
          console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        return this;
      },
      addScalar: function(s) {
        this.x += s;
        this.y += s;
        return this;
      },
      addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
      },
      addScaledVector: function(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
      },
      sub: function(v, w) {
        if (w !== undefined) {
          console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        return this;
      },
      subScalar: function(s) {
        this.x -= s;
        this.y -= s;
        return this;
      },
      subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
      },
      multiply: function(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
      },
      multiplyScalar: function(scalar) {
        if (isFinite(scalar)) {
          this.x *= scalar;
          this.y *= scalar;
        } else {
          this.x = 0;
          this.y = 0;
        }
        return this;
      },
      divide: function(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
      },
      divideScalar: function(scalar) {
        return this.multiplyScalar(1 / scalar);
      },
      min: function(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        return this;
      },
      max: function(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        return this;
      },
      clamp: function(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        return this;
      },
      clampScalar: function() {
        var min,
            max;
        return function clampScalar(minVal, maxVal) {
          if (min === undefined) {
            min = new THREE.Vector2();
            max = new THREE.Vector2();
          }
          min.set(minVal, minVal);
          max.set(maxVal, maxVal);
          return this.clamp(min, max);
        };
      }(),
      clampLength: function(min, max) {
        var length = this.length();
        this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
        return this;
      },
      floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
      },
      ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
      },
      round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
      },
      roundToZero: function() {
        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
      },
      negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
      },
      dot: function(v) {
        return this.x * v.x + this.y * v.y;
      },
      lengthSq: function() {
        return this.x * this.x + this.y * this.y;
      },
      length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      },
      lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y);
      },
      normalize: function() {
        return this.divideScalar(this.length());
      },
      distanceTo: function(v) {
        return Math.sqrt(this.distanceToSquared(v));
      },
      distanceToSquared: function(v) {
        var dx = this.x - v.x,
            dy = this.y - v.y;
        return dx * dx + dy * dy;
      },
      setLength: function(length) {
        return this.multiplyScalar(length / this.length());
      },
      lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
      },
      lerpVectors: function(v1, v2, alpha) {
        this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        return this;
      },
      equals: function(v) {
        return ((v.x === this.x) && (v.y === this.y));
      },
      fromArray: function(array, offset) {
        if (offset === undefined)
          offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
      },
      fromAttribute: function(attribute, index, offset) {
        if (offset === undefined)
          offset = 0;
        index = index * attribute.itemSize + offset;
        this.x = attribute.array[index];
        this.y = attribute.array[index + 1];
        return this;
      },
      rotateAround: function(center, angle) {
        var c = Math.cos(angle),
            s = Math.sin(angle);
        var x = this.x - center.x;
        var y = this.y - center.y;
        this.x = x * c - y * s + center.x;
        this.y = x * s + y * c + center.y;
        return this;
      }
    };
    THREE.Vector3 = function(x, y, z) {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
    };
    THREE.Vector3.prototype = {
      constructor: THREE.Vector3,
      set: function(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
      },
      setX: function(x) {
        this.x = x;
        return this;
      },
      setY: function(y) {
        this.y = y;
        return this;
      },
      setZ: function(z) {
        this.z = z;
        return this;
      },
      setComponent: function(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      getComponent: function(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      clone: function() {
        return new this.constructor(this.x, this.y, this.z);
      },
      copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
      },
      add: function(v, w) {
        if (w !== undefined) {
          console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
      },
      addScalar: function(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
      },
      addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;
      },
      addScaledVector: function(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        return this;
      },
      sub: function(v, w) {
        if (w !== undefined) {
          console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
      },
      subScalar: function(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        return this;
      },
      subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
      },
      multiply: function(v, w) {
        if (w !== undefined) {
          console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
          return this.multiplyVectors(v, w);
        }
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;
      },
      multiplyScalar: function(scalar) {
        if (isFinite(scalar)) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
        } else {
          this.x = 0;
          this.y = 0;
          this.z = 0;
        }
        return this;
      },
      multiplyVectors: function(a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this;
      },
      applyEuler: function() {
        var quaternion;
        return function applyEuler(euler) {
          if (euler instanceof THREE.Euler === false) {
            console.error('THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.');
          }
          if (quaternion === undefined)
            quaternion = new THREE.Quaternion();
          this.applyQuaternion(quaternion.setFromEuler(euler));
          return this;
        };
      }(),
      applyAxisAngle: function() {
        var quaternion;
        return function applyAxisAngle(axis, angle) {
          if (quaternion === undefined)
            quaternion = new THREE.Quaternion();
          this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
          return this;
        };
      }(),
      applyMatrix3: function(m) {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6] * z;
        this.y = e[1] * x + e[4] * y + e[7] * z;
        this.z = e[2] * x + e[5] * y + e[8] * z;
        return this;
      },
      applyMatrix4: function(m) {
        var x = this.x,
            y = this.y,
            z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
        return this;
      },
      applyProjection: function(m) {
        var x = this.x,
            y = this.y,
            z = this.z;
        var e = m.elements;
        var d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d;
        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d;
        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d;
        return this;
      },
      applyQuaternion: function(q) {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var qx = q.x;
        var qy = q.y;
        var qz = q.z;
        var qw = q.w;
        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return this;
      },
      project: function() {
        var matrix;
        return function project(camera) {
          if (matrix === undefined)
            matrix = new THREE.Matrix4();
          matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
          return this.applyProjection(matrix);
        };
      }(),
      unproject: function() {
        var matrix;
        return function unproject(camera) {
          if (matrix === undefined)
            matrix = new THREE.Matrix4();
          matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
          return this.applyProjection(matrix);
        };
      }(),
      transformDirection: function(m) {
        var x = this.x,
            y = this.y,
            z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z;
        this.y = e[1] * x + e[5] * y + e[9] * z;
        this.z = e[2] * x + e[6] * y + e[10] * z;
        this.normalize();
        return this;
      },
      divide: function(v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        return this;
      },
      divideScalar: function(scalar) {
        return this.multiplyScalar(1 / scalar);
      },
      min: function(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        return this;
      },
      max: function(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        return this;
      },
      clamp: function(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        return this;
      },
      clampScalar: function() {
        var min,
            max;
        return function clampScalar(minVal, maxVal) {
          if (min === undefined) {
            min = new THREE.Vector3();
            max = new THREE.Vector3();
          }
          min.set(minVal, minVal, minVal);
          max.set(maxVal, maxVal, maxVal);
          return this.clamp(min, max);
        };
      }(),
      clampLength: function(min, max) {
        var length = this.length();
        this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
        return this;
      },
      floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
      },
      ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
      },
      round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
      },
      roundToZero: function() {
        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
        return this;
      },
      negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
      },
      dot: function(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
      },
      lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      },
      length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      },
      lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      },
      normalize: function() {
        return this.divideScalar(this.length());
      },
      setLength: function(length) {
        return this.multiplyScalar(length / this.length());
      },
      lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        return this;
      },
      lerpVectors: function(v1, v2, alpha) {
        this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        return this;
      },
      cross: function(v, w) {
        if (w !== undefined) {
          console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
          return this.crossVectors(v, w);
        }
        var x = this.x,
            y = this.y,
            z = this.z;
        this.x = y * v.z - z * v.y;
        this.y = z * v.x - x * v.z;
        this.z = x * v.y - y * v.x;
        return this;
      },
      crossVectors: function(a, b) {
        var ax = a.x,
            ay = a.y,
            az = a.z;
        var bx = b.x,
            by = b.y,
            bz = b.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
      },
      projectOnVector: function() {
        var v1,
            dot;
        return function projectOnVector(vector) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          v1.copy(vector).normalize();
          dot = this.dot(v1);
          return this.copy(v1).multiplyScalar(dot);
        };
      }(),
      projectOnPlane: function() {
        var v1;
        return function projectOnPlane(planeNormal) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          v1.copy(this).projectOnVector(planeNormal);
          return this.sub(v1);
        };
      }(),
      reflect: function() {
        var v1;
        return function reflect(normal) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
        };
      }(),
      angleTo: function(v) {
        var theta = this.dot(v) / (this.length() * v.length());
        return Math.acos(THREE.Math.clamp(theta, -1, 1));
      },
      distanceTo: function(v) {
        return Math.sqrt(this.distanceToSquared(v));
      },
      distanceToSquared: function(v) {
        var dx = this.x - v.x;
        var dy = this.y - v.y;
        var dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
      },
      setEulerFromRotationMatrix: function(m, order) {
        console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
      },
      setEulerFromQuaternion: function(q, order) {
        console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
      },
      getPositionFromMatrix: function(m) {
        console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
        return this.setFromMatrixPosition(m);
      },
      getScaleFromMatrix: function(m) {
        console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
        return this.setFromMatrixScale(m);
      },
      getColumnFromMatrix: function(index, matrix) {
        console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
        return this.setFromMatrixColumn(index, matrix);
      },
      setFromMatrixPosition: function(m) {
        this.x = m.elements[12];
        this.y = m.elements[13];
        this.z = m.elements[14];
        return this;
      },
      setFromMatrixScale: function(m) {
        var sx = this.set(m.elements[0], m.elements[1], m.elements[2]).length();
        var sy = this.set(m.elements[4], m.elements[5], m.elements[6]).length();
        var sz = this.set(m.elements[8], m.elements[9], m.elements[10]).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
      },
      setFromMatrixColumn: function(index, matrix) {
        var offset = index * 4;
        var me = matrix.elements;
        this.x = me[offset];
        this.y = me[offset + 1];
        this.z = me[offset + 2];
        return this;
      },
      equals: function(v) {
        return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z));
      },
      fromArray: function(array, offset) {
        if (offset === undefined)
          offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        return array;
      },
      fromAttribute: function(attribute, index, offset) {
        if (offset === undefined)
          offset = 0;
        index = index * attribute.itemSize + offset;
        this.x = attribute.array[index];
        this.y = attribute.array[index + 1];
        this.z = attribute.array[index + 2];
        return this;
      }
    };
    THREE.Vector4 = function(x, y, z, w) {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
      this.w = (w !== undefined) ? w : 1;
    };
    THREE.Vector4.prototype = {
      constructor: THREE.Vector4,
      set: function(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
      },
      setX: function(x) {
        this.x = x;
        return this;
      },
      setY: function(y) {
        this.y = y;
        return this;
      },
      setZ: function(z) {
        this.z = z;
        return this;
      },
      setW: function(w) {
        this.w = w;
        return this;
      },
      setComponent: function(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
          case 3:
            this.w = value;
            break;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      getComponent: function(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      clone: function() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      },
      copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = (v.w !== undefined) ? v.w : 1;
        return this;
      },
      add: function(v, w) {
        if (w !== undefined) {
          console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
      },
      addScalar: function(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;
        return this;
      },
      addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this;
      },
      addScaledVector: function(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        this.w += v.w * s;
        return this;
      },
      sub: function(v, w) {
        if (w !== undefined) {
          console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
      },
      subScalar: function(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;
        return this;
      },
      subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this;
      },
      multiplyScalar: function(scalar) {
        if (isFinite(scalar)) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          this.w *= scalar;
        } else {
          this.x = 0;
          this.y = 0;
          this.z = 0;
          this.w = 0;
        }
        return this;
      },
      applyMatrix4: function(m) {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var w = this.w;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
        return this;
      },
      divideScalar: function(scalar) {
        return this.multiplyScalar(1 / scalar);
      },
      setAxisAngleFromQuaternion: function(q) {
        this.w = 2 * Math.acos(q.w);
        var s = Math.sqrt(1 - q.w * q.w);
        if (s < 0.0001) {
          this.x = 1;
          this.y = 0;
          this.z = 0;
        } else {
          this.x = q.x / s;
          this.y = q.y / s;
          this.z = q.z / s;
        }
        return this;
      },
      setAxisAngleFromRotationMatrix: function(m) {
        var angle,
            x,
            y,
            z,
            epsilon = 0.01,
            epsilon2 = 0.1,
            te = m.elements,
            m11 = te[0],
            m12 = te[4],
            m13 = te[8],
            m21 = te[1],
            m22 = te[5],
            m23 = te[9],
            m31 = te[2],
            m32 = te[6],
            m33 = te[10];
        if ((Math.abs(m12 - m21) < epsilon) && (Math.abs(m13 - m31) < epsilon) && (Math.abs(m23 - m32) < epsilon)) {
          if ((Math.abs(m12 + m21) < epsilon2) && (Math.abs(m13 + m31) < epsilon2) && (Math.abs(m23 + m32) < epsilon2) && (Math.abs(m11 + m22 + m33 - 3) < epsilon2)) {
            this.set(1, 0, 0, 0);
            return this;
          }
          angle = Math.PI;
          var xx = (m11 + 1) / 2;
          var yy = (m22 + 1) / 2;
          var zz = (m33 + 1) / 2;
          var xy = (m12 + m21) / 4;
          var xz = (m13 + m31) / 4;
          var yz = (m23 + m32) / 4;
          if ((xx > yy) && (xx > zz)) {
            if (xx < epsilon) {
              x = 0;
              y = 0.707106781;
              z = 0.707106781;
            } else {
              x = Math.sqrt(xx);
              y = xy / x;
              z = xz / x;
            }
          } else if (yy > zz) {
            if (yy < epsilon) {
              x = 0.707106781;
              y = 0;
              z = 0.707106781;
            } else {
              y = Math.sqrt(yy);
              x = xy / y;
              z = yz / y;
            }
          } else {
            if (zz < epsilon) {
              x = 0.707106781;
              y = 0.707106781;
              z = 0;
            } else {
              z = Math.sqrt(zz);
              x = xz / z;
              y = yz / z;
            }
          }
          this.set(x, y, z, angle);
          return this;
        }
        var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
        if (Math.abs(s) < 0.001)
          s = 1;
        this.x = (m32 - m23) / s;
        this.y = (m13 - m31) / s;
        this.z = (m21 - m12) / s;
        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
        return this;
      },
      min: function(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        this.w = Math.min(this.w, v.w);
        return this;
      },
      max: function(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        this.w = Math.max(this.w, v.w);
        return this;
      },
      clamp: function(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        this.w = Math.max(min.w, Math.min(max.w, this.w));
        return this;
      },
      clampScalar: function() {
        var min,
            max;
        return function clampScalar(minVal, maxVal) {
          if (min === undefined) {
            min = new THREE.Vector4();
            max = new THREE.Vector4();
          }
          min.set(minVal, minVal, minVal, minVal);
          max.set(maxVal, maxVal, maxVal, maxVal);
          return this.clamp(min, max);
        };
      }(),
      floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
      },
      ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
      },
      round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
      },
      roundToZero: function() {
        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = (this.w < 0) ? Math.ceil(this.w) : Math.floor(this.w);
        return this;
      },
      negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
      },
      dot: function(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
      },
      lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      },
      length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      },
      lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
      },
      normalize: function() {
        return this.divideScalar(this.length());
      },
      setLength: function(length) {
        return this.multiplyScalar(length / this.length());
      },
      lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
      },
      lerpVectors: function(v1, v2, alpha) {
        this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        return this;
      },
      equals: function(v) {
        return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z) && (v.w === this.w));
      },
      fromArray: function(array, offset) {
        if (offset === undefined)
          offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
      },
      fromAttribute: function(attribute, index, offset) {
        if (offset === undefined)
          offset = 0;
        index = index * attribute.itemSize + offset;
        this.x = attribute.array[index];
        this.y = attribute.array[index + 1];
        this.z = attribute.array[index + 2];
        this.w = attribute.array[index + 3];
        return this;
      }
    };
    THREE.Euler = function(x, y, z, order) {
      this._x = x || 0;
      this._y = y || 0;
      this._z = z || 0;
      this._order = order || THREE.Euler.DefaultOrder;
    };
    THREE.Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
    THREE.Euler.DefaultOrder = 'XYZ';
    THREE.Euler.prototype = {
      constructor: THREE.Euler,
      get x() {
        return this._x;
      },
      set x(value) {
        this._x = value;
        this.onChangeCallback();
      },
      get y() {
        return this._y;
      },
      set y(value) {
        this._y = value;
        this.onChangeCallback();
      },
      get z() {
        return this._z;
      },
      set z(value) {
        this._z = value;
        this.onChangeCallback();
      },
      get order() {
        return this._order;
      },
      set order(value) {
        this._order = value;
        this.onChangeCallback();
      },
      set: function(x, y, z, order) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order || this._order;
        this.onChangeCallback();
        return this;
      },
      clone: function() {
        return new this.constructor(this._x, this._y, this._z, this._order);
      },
      copy: function(euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this.onChangeCallback();
        return this;
      },
      setFromRotationMatrix: function(m, order, update) {
        var clamp = THREE.Math.clamp;
        var te = m.elements;
        var m11 = te[0],
            m12 = te[4],
            m13 = te[8];
        var m21 = te[1],
            m22 = te[5],
            m23 = te[9];
        var m31 = te[2],
            m32 = te[6],
            m33 = te[10];
        order = order || this._order;
        if (order === 'XYZ') {
          this._y = Math.asin(clamp(m13, -1, 1));
          if (Math.abs(m13) < 0.99999) {
            this._x = Math.atan2(-m23, m33);
            this._z = Math.atan2(-m12, m11);
          } else {
            this._x = Math.atan2(m32, m22);
            this._z = 0;
          }
        } else if (order === 'YXZ') {
          this._x = Math.asin(-clamp(m23, -1, 1));
          if (Math.abs(m23) < 0.99999) {
            this._y = Math.atan2(m13, m33);
            this._z = Math.atan2(m21, m22);
          } else {
            this._y = Math.atan2(-m31, m11);
            this._z = 0;
          }
        } else if (order === 'ZXY') {
          this._x = Math.asin(clamp(m32, -1, 1));
          if (Math.abs(m32) < 0.99999) {
            this._y = Math.atan2(-m31, m33);
            this._z = Math.atan2(-m12, m22);
          } else {
            this._y = 0;
            this._z = Math.atan2(m21, m11);
          }
        } else if (order === 'ZYX') {
          this._y = Math.asin(-clamp(m31, -1, 1));
          if (Math.abs(m31) < 0.99999) {
            this._x = Math.atan2(m32, m33);
            this._z = Math.atan2(m21, m11);
          } else {
            this._x = 0;
            this._z = Math.atan2(-m12, m22);
          }
        } else if (order === 'YZX') {
          this._z = Math.asin(clamp(m21, -1, 1));
          if (Math.abs(m21) < 0.99999) {
            this._x = Math.atan2(-m23, m22);
            this._y = Math.atan2(-m31, m11);
          } else {
            this._x = 0;
            this._y = Math.atan2(m13, m33);
          }
        } else if (order === 'XZY') {
          this._z = Math.asin(-clamp(m12, -1, 1));
          if (Math.abs(m12) < 0.99999) {
            this._x = Math.atan2(m32, m22);
            this._y = Math.atan2(m13, m11);
          } else {
            this._x = Math.atan2(-m23, m33);
            this._y = 0;
          }
        } else {
          console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);
        }
        this._order = order;
        if (update !== false)
          this.onChangeCallback();
        return this;
      },
      setFromQuaternion: function() {
        var matrix;
        return function(q, order, update) {
          if (matrix === undefined)
            matrix = new THREE.Matrix4();
          matrix.makeRotationFromQuaternion(q);
          this.setFromRotationMatrix(matrix, order, update);
          return this;
        };
      }(),
      setFromVector3: function(v, order) {
        return this.set(v.x, v.y, v.z, order || this._order);
      },
      reorder: function() {
        var q = new THREE.Quaternion();
        return function(newOrder) {
          q.setFromEuler(this);
          this.setFromQuaternion(q, newOrder);
        };
      }(),
      equals: function(euler) {
        return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order);
      },
      fromArray: function(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== undefined)
          this._order = array[3];
        this.onChangeCallback();
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
      },
      toVector3: function(optionalResult) {
        if (optionalResult) {
          return optionalResult.set(this._x, this._y, this._z);
        } else {
          return new THREE.Vector3(this._x, this._y, this._z);
        }
      },
      onChange: function(callback) {
        this.onChangeCallback = callback;
        return this;
      },
      onChangeCallback: function() {}
    };
    THREE.Line3 = function(start, end) {
      this.start = (start !== undefined) ? start : new THREE.Vector3();
      this.end = (end !== undefined) ? end : new THREE.Vector3();
    };
    THREE.Line3.prototype = {
      constructor: THREE.Line3,
      set: function(start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
      },
      center: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors(this.start, this.end).multiplyScalar(0.5);
      },
      delta: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.subVectors(this.end, this.start);
      },
      distanceSq: function() {
        return this.start.distanceToSquared(this.end);
      },
      distance: function() {
        return this.start.distanceTo(this.end);
      },
      at: function(t, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return this.delta(result).multiplyScalar(t).add(this.start);
      },
      closestPointToPointParameter: function() {
        var startP = new THREE.Vector3();
        var startEnd = new THREE.Vector3();
        return function(point, clampToLine) {
          startP.subVectors(point, this.start);
          startEnd.subVectors(this.end, this.start);
          var startEnd2 = startEnd.dot(startEnd);
          var startEnd_startP = startEnd.dot(startP);
          var t = startEnd_startP / startEnd2;
          if (clampToLine) {
            t = THREE.Math.clamp(t, 0, 1);
          }
          return t;
        };
      }(),
      closestPointToPoint: function(point, clampToLine, optionalTarget) {
        var t = this.closestPointToPointParameter(point, clampToLine);
        var result = optionalTarget || new THREE.Vector3();
        return this.delta(result).multiplyScalar(t).add(this.start);
      },
      applyMatrix4: function(matrix) {
        this.start.applyMatrix4(matrix);
        this.end.applyMatrix4(matrix);
        return this;
      },
      equals: function(line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
      }
    };
    THREE.Box2 = function(min, max) {
      this.min = (min !== undefined) ? min : new THREE.Vector2(Infinity, Infinity);
      this.max = (max !== undefined) ? max : new THREE.Vector2(-Infinity, -Infinity);
    };
    THREE.Box2.prototype = {
      constructor: THREE.Box2,
      set: function(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
      },
      setFromPoints: function(points) {
        this.makeEmpty();
        for (var i = 0,
            il = points.length; i < il; i++) {
          this.expandByPoint(points[i]);
        }
        return this;
      },
      setFromCenterAndSize: function() {
        var v1 = new THREE.Vector2();
        return function(center, size) {
          var halfSize = v1.copy(size).multiplyScalar(0.5);
          this.min.copy(center).sub(halfSize);
          this.max.copy(center).add(halfSize);
          return this;
        };
      }(),
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
      },
      makeEmpty: function() {
        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;
        return this;
      },
      empty: function() {
        return (this.max.x < this.min.x) || (this.max.y < this.min.y);
      },
      center: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector2();
        return result.addVectors(this.min, this.max).multiplyScalar(0.5);
      },
      size: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector2();
        return result.subVectors(this.max, this.min);
      },
      expandByPoint: function(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
      },
      expandByVector: function(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
      },
      expandByScalar: function(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
      },
      containsPoint: function(point) {
        if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y) {
          return false;
        }
        return true;
      },
      containsBox: function(box) {
        if ((this.min.x <= box.min.x) && (box.max.x <= this.max.x) && (this.min.y <= box.min.y) && (box.max.y <= this.max.y)) {
          return true;
        }
        return false;
      },
      getParameter: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector2();
        return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
      },
      isIntersectionBox: function(box) {
        if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y) {
          return false;
        }
        return true;
      },
      clampPoint: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector2();
        return result.copy(point).clamp(this.min, this.max);
      },
      distanceToPoint: function() {
        var v1 = new THREE.Vector2();
        return function(point) {
          var clampedPoint = v1.copy(point).clamp(this.min, this.max);
          return clampedPoint.sub(point).length();
        };
      }(),
      intersect: function(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
      },
      union: function(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
      },
      translate: function(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
      },
      equals: function(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
      }
    };
    THREE.Box3 = function(min, max) {
      this.min = (min !== undefined) ? min : new THREE.Vector3(Infinity, Infinity, Infinity);
      this.max = (max !== undefined) ? max : new THREE.Vector3(-Infinity, -Infinity, -Infinity);
    };
    THREE.Box3.prototype = {
      constructor: THREE.Box3,
      set: function(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
      },
      setFromPoints: function(points) {
        this.makeEmpty();
        for (var i = 0,
            il = points.length; i < il; i++) {
          this.expandByPoint(points[i]);
        }
        return this;
      },
      setFromCenterAndSize: function() {
        var v1 = new THREE.Vector3();
        return function(center, size) {
          var halfSize = v1.copy(size).multiplyScalar(0.5);
          this.min.copy(center).sub(halfSize);
          this.max.copy(center).add(halfSize);
          return this;
        };
      }(),
      setFromObject: function() {
        var v1 = new THREE.Vector3();
        return function(object) {
          var scope = this;
          object.updateMatrixWorld(true);
          this.makeEmpty();
          object.traverse(function(node) {
            var geometry = node.geometry;
            if (geometry !== undefined) {
              if (geometry instanceof THREE.Geometry) {
                var vertices = geometry.vertices;
                for (var i = 0,
                    il = vertices.length; i < il; i++) {
                  v1.copy(vertices[i]);
                  v1.applyMatrix4(node.matrixWorld);
                  scope.expandByPoint(v1);
                }
              } else if (geometry instanceof THREE.BufferGeometry && geometry.attributes['position'] !== undefined) {
                var positions = geometry.attributes['position'].array;
                for (var i = 0,
                    il = positions.length; i < il; i += 3) {
                  v1.set(positions[i], positions[i + 1], positions[i + 2]);
                  v1.applyMatrix4(node.matrixWorld);
                  scope.expandByPoint(v1);
                }
              }
            }
          });
          return this;
        };
      }(),
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
      },
      makeEmpty: function() {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
      },
      empty: function() {
        return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z);
      },
      center: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors(this.min, this.max).multiplyScalar(0.5);
      },
      size: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.subVectors(this.max, this.min);
      },
      expandByPoint: function(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
      },
      expandByVector: function(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
      },
      expandByScalar: function(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
      },
      containsPoint: function(point) {
        if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z) {
          return false;
        }
        return true;
      },
      containsBox: function(box) {
        if ((this.min.x <= box.min.x) && (box.max.x <= this.max.x) && (this.min.y <= box.min.y) && (box.max.y <= this.max.y) && (this.min.z <= box.min.z) && (box.max.z <= this.max.z)) {
          return true;
        }
        return false;
      },
      getParameter: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
      },
      isIntersectionBox: function(box) {
        if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z) {
          return false;
        }
        return true;
      },
      clampPoint: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.copy(point).clamp(this.min, this.max);
      },
      distanceToPoint: function() {
        var v1 = new THREE.Vector3();
        return function(point) {
          var clampedPoint = v1.copy(point).clamp(this.min, this.max);
          return clampedPoint.sub(point).length();
        };
      }(),
      getBoundingSphere: function() {
        var v1 = new THREE.Vector3();
        return function(optionalTarget) {
          var result = optionalTarget || new THREE.Sphere();
          result.center = this.center();
          result.radius = this.size(v1).length() * 0.5;
          return result;
        };
      }(),
      intersect: function(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
      },
      union: function(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
      },
      applyMatrix4: function() {
        var points = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];
        return function(matrix) {
          points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
          points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
          points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
          points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
          points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
          points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
          points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
          points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
          this.makeEmpty();
          this.setFromPoints(points);
          return this;
        };
      }(),
      translate: function(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
      },
      equals: function(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
      }
    };
    THREE.Matrix3 = function() {
      this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
      if (arguments.length > 0) {
        console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
      }
    };
    THREE.Matrix3.prototype = {
      constructor: THREE.Matrix3,
      set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        var te = this.elements;
        te[0] = n11;
        te[3] = n12;
        te[6] = n13;
        te[1] = n21;
        te[4] = n22;
        te[7] = n23;
        te[2] = n31;
        te[5] = n32;
        te[8] = n33;
        return this;
      },
      identity: function() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
      },
      clone: function() {
        return new this.constructor().fromArray(this.elements);
      },
      copy: function(m) {
        var me = m.elements;
        this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);
        return this;
      },
      multiplyVector3: function(vector) {
        console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
        return vector.applyMatrix3(this);
      },
      multiplyVector3Array: function(a) {
        console.warn('THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
        return this.applyToVector3Array(a);
      },
      applyToVector3Array: function() {
        var v1;
        return function(array, offset, length) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          if (offset === undefined)
            offset = 0;
          if (length === undefined)
            length = array.length;
          for (var i = 0,
              j = offset; i < length; i += 3, j += 3) {
            v1.fromArray(array, j);
            v1.applyMatrix3(this);
            v1.toArray(array, j);
          }
          return array;
        };
      }(),
      applyToBuffer: function() {
        var v1;
        return function applyToBuffer(buffer, offset, length) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          if (offset === undefined)
            offset = 0;
          if (length === undefined)
            length = buffer.length / buffer.itemSize;
          for (var i = 0,
              j = offset; i < length; i++, j++) {
            v1.x = buffer.getX(j);
            v1.y = buffer.getY(j);
            v1.z = buffer.getZ(j);
            v1.applyMatrix3(this);
            buffer.setXYZ(v1.x, v1.y, v1.z);
          }
          return buffer;
        };
      }(),
      multiplyScalar: function(s) {
        var te = this.elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
      },
      determinant: function() {
        var te = this.elements;
        var a = te[0],
            b = te[1],
            c = te[2],
            d = te[3],
            e = te[4],
            f = te[5],
            g = te[6],
            h = te[7],
            i = te[8];
        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
      },
      getInverse: function(matrix, throwOnInvertible) {
        var me = matrix.elements;
        var te = this.elements;
        te[0] = me[10] * me[5] - me[6] * me[9];
        te[1] = -me[10] * me[1] + me[2] * me[9];
        te[2] = me[6] * me[1] - me[2] * me[5];
        te[3] = -me[10] * me[4] + me[6] * me[8];
        te[4] = me[10] * me[0] - me[2] * me[8];
        te[5] = -me[6] * me[0] + me[2] * me[4];
        te[6] = me[9] * me[4] - me[5] * me[8];
        te[7] = -me[9] * me[0] + me[1] * me[8];
        te[8] = me[5] * me[0] - me[1] * me[4];
        var det = me[0] * te[0] + me[1] * te[3] + me[2] * te[6];
        if (det === 0) {
          var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";
          if (throwOnInvertible || false) {
            throw new Error(msg);
          } else {
            console.warn(msg);
          }
          this.identity();
          return this;
        }
        this.multiplyScalar(1.0 / det);
        return this;
      },
      transpose: function() {
        var tmp,
            m = this.elements;
        tmp = m[1];
        m[1] = m[3];
        m[3] = tmp;
        tmp = m[2];
        m[2] = m[6];
        m[6] = tmp;
        tmp = m[5];
        m[5] = m[7];
        m[7] = tmp;
        return this;
      },
      flattenToArrayOffset: function(array, offset) {
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        return array;
      },
      getNormalMatrix: function(m) {
        this.getInverse(m).transpose();
        return this;
      },
      transposeIntoArray: function(r) {
        var m = this.elements;
        r[0] = m[0];
        r[1] = m[3];
        r[2] = m[6];
        r[3] = m[1];
        r[4] = m[4];
        r[5] = m[7];
        r[6] = m[2];
        r[7] = m[5];
        r[8] = m[8];
        return this;
      },
      fromArray: function(array) {
        this.elements.set(array);
        return this;
      },
      toArray: function() {
        var te = this.elements;
        return [te[0], te[1], te[2], te[3], te[4], te[5], te[6], te[7], te[8]];
      }
    };
    THREE.Matrix4 = function() {
      this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      if (arguments.length > 0) {
        console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
      }
    };
    THREE.Matrix4.prototype = {
      constructor: THREE.Matrix4,
      set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        var te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
      },
      identity: function() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      },
      clone: function() {
        return new THREE.Matrix4().fromArray(this.elements);
      },
      copy: function(m) {
        this.elements.set(m.elements);
        return this;
      },
      extractPosition: function(m) {
        console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
        return this.copyPosition(m);
      },
      copyPosition: function(m) {
        var te = this.elements;
        var me = m.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
      },
      extractBasis: function(xAxis, yAxis, zAxis) {
        var te = this.elements;
        xAxis.set(te[0], te[1], te[2]);
        yAxis.set(te[4], te[5], te[6]);
        zAxis.set(te[8], te[9], te[10]);
        return this;
      },
      makeBasis: function(xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
      },
      extractRotation: function() {
        var v1;
        return function(m) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          var te = this.elements;
          var me = m.elements;
          var scaleX = 1 / v1.set(me[0], me[1], me[2]).length();
          var scaleY = 1 / v1.set(me[4], me[5], me[6]).length();
          var scaleZ = 1 / v1.set(me[8], me[9], me[10]).length();
          te[0] = me[0] * scaleX;
          te[1] = me[1] * scaleX;
          te[2] = me[2] * scaleX;
          te[4] = me[4] * scaleY;
          te[5] = me[5] * scaleY;
          te[6] = me[6] * scaleY;
          te[8] = me[8] * scaleZ;
          te[9] = me[9] * scaleZ;
          te[10] = me[10] * scaleZ;
          return this;
        };
      }(),
      makeRotationFromEuler: function(euler) {
        if (euler instanceof THREE.Euler === false) {
          console.error('THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
        }
        var te = this.elements;
        var x = euler.x,
            y = euler.y,
            z = euler.z;
        var a = Math.cos(x),
            b = Math.sin(x);
        var c = Math.cos(y),
            d = Math.sin(y);
        var e = Math.cos(z),
            f = Math.sin(z);
        if (euler.order === 'XYZ') {
          var ae = a * e,
              af = a * f,
              be = b * e,
              bf = b * f;
          te[0] = c * e;
          te[4] = -c * f;
          te[8] = d;
          te[1] = af + be * d;
          te[5] = ae - bf * d;
          te[9] = -b * c;
          te[2] = bf - ae * d;
          te[6] = be + af * d;
          te[10] = a * c;
        } else if (euler.order === 'YXZ') {
          var ce = c * e,
              cf = c * f,
              de = d * e,
              df = d * f;
          te[0] = ce + df * b;
          te[4] = de * b - cf;
          te[8] = a * d;
          te[1] = a * f;
          te[5] = a * e;
          te[9] = -b;
          te[2] = cf * b - de;
          te[6] = df + ce * b;
          te[10] = a * c;
        } else if (euler.order === 'ZXY') {
          var ce = c * e,
              cf = c * f,
              de = d * e,
              df = d * f;
          te[0] = ce - df * b;
          te[4] = -a * f;
          te[8] = de + cf * b;
          te[1] = cf + de * b;
          te[5] = a * e;
          te[9] = df - ce * b;
          te[2] = -a * d;
          te[6] = b;
          te[10] = a * c;
        } else if (euler.order === 'ZYX') {
          var ae = a * e,
              af = a * f,
              be = b * e,
              bf = b * f;
          te[0] = c * e;
          te[4] = be * d - af;
          te[8] = ae * d + bf;
          te[1] = c * f;
          te[5] = bf * d + ae;
          te[9] = af * d - be;
          te[2] = -d;
          te[6] = b * c;
          te[10] = a * c;
        } else if (euler.order === 'YZX') {
          var ac = a * c,
              ad = a * d,
              bc = b * c,
              bd = b * d;
          te[0] = c * e;
          te[4] = bd - ac * f;
          te[8] = bc * f + ad;
          te[1] = f;
          te[5] = a * e;
          te[9] = -b * e;
          te[2] = -d * e;
          te[6] = ad * f + bc;
          te[10] = ac - bd * f;
        } else if (euler.order === 'XZY') {
          var ac = a * c,
              ad = a * d,
              bc = b * c,
              bd = b * d;
          te[0] = c * e;
          te[4] = -f;
          te[8] = d * e;
          te[1] = ac * f + bd;
          te[5] = a * e;
          te[9] = ad * f - bc;
          te[2] = bc * f - ad;
          te[6] = b * e;
          te[10] = bd * f + ac;
        }
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      },
      setRotationFromQuaternion: function(q) {
        console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
        return this.makeRotationFromQuaternion(q);
      },
      makeRotationFromQuaternion: function(q) {
        var te = this.elements;
        var x = q.x,
            y = q.y,
            z = q.z,
            w = q.w;
        var x2 = x + x,
            y2 = y + y,
            z2 = z + z;
        var xx = x * x2,
            xy = x * y2,
            xz = x * z2;
        var yy = y * y2,
            yz = y * z2,
            zz = z * z2;
        var wx = w * x2,
            wy = w * y2,
            wz = w * z2;
        te[0] = 1 - (yy + zz);
        te[4] = xy - wz;
        te[8] = xz + wy;
        te[1] = xy + wz;
        te[5] = 1 - (xx + zz);
        te[9] = yz - wx;
        te[2] = xz - wy;
        te[6] = yz + wx;
        te[10] = 1 - (xx + yy);
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      },
      lookAt: function() {
        var x,
            y,
            z;
        return function(eye, target, up) {
          if (x === undefined)
            x = new THREE.Vector3();
          if (y === undefined)
            y = new THREE.Vector3();
          if (z === undefined)
            z = new THREE.Vector3();
          var te = this.elements;
          z.subVectors(eye, target).normalize();
          if (z.lengthSq() === 0) {
            z.z = 1;
          }
          x.crossVectors(up, z).normalize();
          if (x.lengthSq() === 0) {
            z.x += 0.0001;
            x.crossVectors(up, z).normalize();
          }
          y.crossVectors(z, x);
          te[0] = x.x;
          te[4] = y.x;
          te[8] = z.x;
          te[1] = x.y;
          te[5] = y.y;
          te[9] = z.y;
          te[2] = x.z;
          te[6] = y.z;
          te[10] = z.z;
          return this;
        };
      }(),
      multiply: function(m, n) {
        if (n !== undefined) {
          console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
          return this.multiplyMatrices(m, n);
        }
        return this.multiplyMatrices(this, m);
      },
      multiplyMatrices: function(a, b) {
        var ae = a.elements;
        var be = b.elements;
        var te = this.elements;
        var a11 = ae[0],
            a12 = ae[4],
            a13 = ae[8],
            a14 = ae[12];
        var a21 = ae[1],
            a22 = ae[5],
            a23 = ae[9],
            a24 = ae[13];
        var a31 = ae[2],
            a32 = ae[6],
            a33 = ae[10],
            a34 = ae[14];
        var a41 = ae[3],
            a42 = ae[7],
            a43 = ae[11],
            a44 = ae[15];
        var b11 = be[0],
            b12 = be[4],
            b13 = be[8],
            b14 = be[12];
        var b21 = be[1],
            b22 = be[5],
            b23 = be[9],
            b24 = be[13];
        var b31 = be[2],
            b32 = be[6],
            b33 = be[10],
            b34 = be[14];
        var b41 = be[3],
            b42 = be[7],
            b43 = be[11],
            b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
      },
      multiplyToArray: function(a, b, r) {
        var te = this.elements;
        this.multiplyMatrices(a, b);
        r[0] = te[0];
        r[1] = te[1];
        r[2] = te[2];
        r[3] = te[3];
        r[4] = te[4];
        r[5] = te[5];
        r[6] = te[6];
        r[7] = te[7];
        r[8] = te[8];
        r[9] = te[9];
        r[10] = te[10];
        r[11] = te[11];
        r[12] = te[12];
        r[13] = te[13];
        r[14] = te[14];
        r[15] = te[15];
        return this;
      },
      multiplyScalar: function(s) {
        var te = this.elements;
        te[0] *= s;
        te[4] *= s;
        te[8] *= s;
        te[12] *= s;
        te[1] *= s;
        te[5] *= s;
        te[9] *= s;
        te[13] *= s;
        te[2] *= s;
        te[6] *= s;
        te[10] *= s;
        te[14] *= s;
        te[3] *= s;
        te[7] *= s;
        te[11] *= s;
        te[15] *= s;
        return this;
      },
      multiplyVector3: function(vector) {
        console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.');
        return vector.applyProjection(this);
      },
      multiplyVector4: function(vector) {
        console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
        return vector.applyMatrix4(this);
      },
      multiplyVector3Array: function(a) {
        console.warn('THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
        return this.applyToVector3Array(a);
      },
      applyToVector3Array: function() {
        var v1;
        return function(array, offset, length) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          if (offset === undefined)
            offset = 0;
          if (length === undefined)
            length = array.length;
          for (var i = 0,
              j = offset; i < length; i += 3, j += 3) {
            v1.fromArray(array, j);
            v1.applyMatrix4(this);
            v1.toArray(array, j);
          }
          return array;
        };
      }(),
      applyToBuffer: function() {
        var v1;
        return function applyToBuffer(buffer, offset, length) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          if (offset === undefined)
            offset = 0;
          if (length === undefined)
            length = buffer.length / buffer.itemSize;
          for (var i = 0,
              j = offset; i < length; i++, j++) {
            v1.x = buffer.getX(j);
            v1.y = buffer.getY(j);
            v1.z = buffer.getZ(j);
            v1.applyMatrix4(this);
            buffer.setXYZ(v1.x, v1.y, v1.z);
          }
          return buffer;
        };
      }(),
      rotateAxis: function(v) {
        console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
        v.transformDirection(this);
      },
      crossVector: function(vector) {
        console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
        return vector.applyMatrix4(this);
      },
      determinant: function() {
        var te = this.elements;
        var n11 = te[0],
            n12 = te[4],
            n13 = te[8],
            n14 = te[12];
        var n21 = te[1],
            n22 = te[5],
            n23 = te[9],
            n24 = te[13];
        var n31 = te[2],
            n32 = te[6],
            n33 = te[10],
            n34 = te[14];
        var n41 = te[3],
            n42 = te[7],
            n43 = te[11],
            n44 = te[15];
        return (n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31));
      },
      transpose: function() {
        var te = this.elements;
        var tmp;
        tmp = te[1];
        te[1] = te[4];
        te[4] = tmp;
        tmp = te[2];
        te[2] = te[8];
        te[8] = tmp;
        tmp = te[6];
        te[6] = te[9];
        te[9] = tmp;
        tmp = te[3];
        te[3] = te[12];
        te[12] = tmp;
        tmp = te[7];
        te[7] = te[13];
        te[13] = tmp;
        tmp = te[11];
        te[11] = te[14];
        te[14] = tmp;
        return this;
      },
      flattenToArrayOffset: function(array, offset) {
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
        return array;
      },
      getPosition: function() {
        var v1;
        return function() {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
          var te = this.elements;
          return v1.set(te[12], te[13], te[14]);
        };
      }(),
      setPosition: function(v) {
        var te = this.elements;
        te[12] = v.x;
        te[13] = v.y;
        te[14] = v.z;
        return this;
      },
      getInverse: function(m, throwOnInvertible) {
        var te = this.elements;
        var me = m.elements;
        var n11 = me[0],
            n12 = me[4],
            n13 = me[8],
            n14 = me[12];
        var n21 = me[1],
            n22 = me[5],
            n23 = me[9],
            n24 = me[13];
        var n31 = me[2],
            n32 = me[6],
            n33 = me[10],
            n34 = me[14];
        var n41 = me[3],
            n42 = me[7],
            n43 = me[11],
            n44 = me[15];
        te[0] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
        te[4] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
        te[8] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
        te[12] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        te[1] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
        te[5] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
        te[9] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
        te[13] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
        te[2] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
        te[6] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
        te[10] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
        te[14] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
        te[3] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
        te[7] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
        te[11] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
        te[15] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;
        var det = n11 * te[0] + n21 * te[4] + n31 * te[8] + n41 * te[12];
        if (det === 0) {
          var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
          if (throwOnInvertible || false) {
            throw new Error(msg);
          } else {
            console.warn(msg);
          }
          this.identity();
          return this;
        }
        this.multiplyScalar(1 / det);
        return this;
      },
      translate: function(v) {
        console.error('THREE.Matrix4: .translate() has been removed.');
      },
      rotateX: function(angle) {
        console.error('THREE.Matrix4: .rotateX() has been removed.');
      },
      rotateY: function(angle) {
        console.error('THREE.Matrix4: .rotateY() has been removed.');
      },
      rotateZ: function(angle) {
        console.error('THREE.Matrix4: .rotateZ() has been removed.');
      },
      rotateByAxis: function(axis, angle) {
        console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
      },
      scale: function(v) {
        var te = this.elements;
        var x = v.x,
            y = v.y,
            z = v.z;
        te[0] *= x;
        te[4] *= y;
        te[8] *= z;
        te[1] *= x;
        te[5] *= y;
        te[9] *= z;
        te[2] *= x;
        te[6] *= y;
        te[10] *= z;
        te[3] *= x;
        te[7] *= y;
        te[11] *= z;
        return this;
      },
      getMaxScaleOnAxis: function() {
        var te = this.elements;
        var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
      },
      makeTranslation: function(x, y, z) {
        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
        return this;
      },
      makeRotationX: function(theta) {
        var c = Math.cos(theta),
            s = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
        return this;
      },
      makeRotationY: function(theta) {
        var c = Math.cos(theta),
            s = Math.sin(theta);
        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
        return this;
      },
      makeRotationZ: function(theta) {
        var c = Math.cos(theta),
            s = Math.sin(theta);
        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      },
      makeRotationAxis: function(axis, angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var t = 1 - c;
        var x = axis.x,
            y = axis.y,
            z = axis.z;
        var tx = t * x,
            ty = t * y;
        this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
        return this;
      },
      makeScale: function(x, y, z) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        return this;
      },
      compose: function(position, quaternion, scale) {
        this.makeRotationFromQuaternion(quaternion);
        this.scale(scale);
        this.setPosition(position);
        return this;
      },
      decompose: function() {
        var vector,
            matrix;
        return function(position, quaternion, scale) {
          if (vector === undefined)
            vector = new THREE.Vector3();
          if (matrix === undefined)
            matrix = new THREE.Matrix4();
          var te = this.elements;
          var sx = vector.set(te[0], te[1], te[2]).length();
          var sy = vector.set(te[4], te[5], te[6]).length();
          var sz = vector.set(te[8], te[9], te[10]).length();
          var det = this.determinant();
          if (det < 0) {
            sx = -sx;
          }
          position.x = te[12];
          position.y = te[13];
          position.z = te[14];
          matrix.elements.set(this.elements);
          var invSX = 1 / sx;
          var invSY = 1 / sy;
          var invSZ = 1 / sz;
          matrix.elements[0] *= invSX;
          matrix.elements[1] *= invSX;
          matrix.elements[2] *= invSX;
          matrix.elements[4] *= invSY;
          matrix.elements[5] *= invSY;
          matrix.elements[6] *= invSY;
          matrix.elements[8] *= invSZ;
          matrix.elements[9] *= invSZ;
          matrix.elements[10] *= invSZ;
          quaternion.setFromRotationMatrix(matrix);
          scale.x = sx;
          scale.y = sy;
          scale.z = sz;
          return this;
        };
      }(),
      makeFrustum: function(left, right, bottom, top, near, far) {
        var te = this.elements;
        var x = 2 * near / (right - left);
        var y = 2 * near / (top - bottom);
        var a = (right + left) / (right - left);
        var b = (top + bottom) / (top - bottom);
        var c = -(far + near) / (far - near);
        var d = -2 * far * near / (far - near);
        te[0] = x;
        te[4] = 0;
        te[8] = a;
        te[12] = 0;
        te[1] = 0;
        te[5] = y;
        te[9] = b;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c;
        te[14] = d;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
      },
      makePerspective: function(fov, aspect, near, far) {
        var ymax = near * Math.tan(THREE.Math.degToRad(fov * 0.5));
        var ymin = -ymax;
        var xmin = ymin * aspect;
        var xmax = ymax * aspect;
        return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);
      },
      makeOrthographic: function(left, right, top, bottom, near, far) {
        var te = this.elements;
        var w = right - left;
        var h = top - bottom;
        var p = far - near;
        var x = (right + left) / w;
        var y = (top + bottom) / h;
        var z = (far + near) / p;
        te[0] = 2 / w;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x;
        te[1] = 0;
        te[5] = 2 / h;
        te[9] = 0;
        te[13] = -y;
        te[2] = 0;
        te[6] = 0;
        te[10] = -2 / p;
        te[14] = -z;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
      },
      equals: function(matrix) {
        var te = this.elements;
        var me = matrix.elements;
        for (var i = 0; i < 16; i++) {
          if (te[i] !== me[i])
            return false;
        }
        return true;
      },
      fromArray: function(array) {
        this.elements.set(array);
        return this;
      },
      toArray: function() {
        var te = this.elements;
        return [te[0], te[1], te[2], te[3], te[4], te[5], te[6], te[7], te[8], te[9], te[10], te[11], te[12], te[13], te[14], te[15]];
      }
    };
    THREE.Ray = function(origin, direction) {
      this.origin = (origin !== undefined) ? origin : new THREE.Vector3();
      this.direction = (direction !== undefined) ? direction : new THREE.Vector3();
    };
    THREE.Ray.prototype = {
      constructor: THREE.Ray,
      set: function(origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
      },
      at: function(t, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.copy(this.direction).multiplyScalar(t).add(this.origin);
      },
      recast: function() {
        var v1 = new THREE.Vector3();
        return function(t) {
          this.origin.copy(this.at(t, v1));
          return this;
        };
      }(),
      closestPointToPoint: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        result.subVectors(point, this.origin);
        var directionDistance = result.dot(this.direction);
        if (directionDistance < 0) {
          return result.copy(this.origin);
        }
        return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      },
      distanceToPoint: function(point) {
        return Math.sqrt(this.distanceSqToPoint(point));
      },
      distanceSqToPoint: function() {
        var v1 = new THREE.Vector3();
        return function(point) {
          var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
          if (directionDistance < 0) {
            return this.origin.distanceToSquared(point);
          }
          v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
          return v1.distanceToSquared(point);
        };
      }(),
      distanceSqToSegment: function() {
        var segCenter = new THREE.Vector3();
        var segDir = new THREE.Vector3();
        var diff = new THREE.Vector3();
        return function(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
          segCenter.copy(v0).add(v1).multiplyScalar(0.5);
          segDir.copy(v1).sub(v0).normalize();
          diff.copy(this.origin).sub(segCenter);
          var segExtent = v0.distanceTo(v1) * 0.5;
          var a01 = -this.direction.dot(segDir);
          var b0 = diff.dot(this.direction);
          var b1 = -diff.dot(segDir);
          var c = diff.lengthSq();
          var det = Math.abs(1 - a01 * a01);
          var s0,
              s1,
              sqrDist,
              extDet;
          if (det > 0) {
            s0 = a01 * b1 - b0;
            s1 = a01 * b0 - b1;
            extDet = segExtent * det;
            if (s0 >= 0) {
              if (s1 >= -extDet) {
                if (s1 <= extDet) {
                  var invDet = 1 / det;
                  s0 *= invDet;
                  s1 *= invDet;
                  sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                } else {
                  s1 = segExtent;
                  s0 = Math.max(0, -(a01 * s1 + b0));
                  sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
              } else {
                s1 = -segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            } else {
              if (s1 <= -extDet) {
                s0 = Math.max(0, -(-a01 * segExtent + b0));
                s1 = (s0 > 0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              } else if (s1 <= extDet) {
                s0 = 0;
                s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = s1 * (s1 + 2 * b1) + c;
              } else {
                s0 = Math.max(0, -(a01 * segExtent + b0));
                s1 = (s0 > 0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            }
          } else {
            s1 = (a01 > 0) ? -segExtent : segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
          if (optionalPointOnRay) {
            optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
          }
          if (optionalPointOnSegment) {
            optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
          }
          return sqrDist;
        };
      }(),
      isIntersectionSphere: function(sphere) {
        return this.distanceToPoint(sphere.center) <= sphere.radius;
      },
      intersectSphere: function() {
        var v1 = new THREE.Vector3();
        return function(sphere, optionalTarget) {
          v1.subVectors(sphere.center, this.origin);
          var tca = v1.dot(this.direction);
          var d2 = v1.dot(v1) - tca * tca;
          var radius2 = sphere.radius * sphere.radius;
          if (d2 > radius2)
            return null;
          var thc = Math.sqrt(radius2 - d2);
          var t0 = tca - thc;
          var t1 = tca + thc;
          if (t0 < 0 && t1 < 0)
            return null;
          if (t0 < 0)
            return this.at(t1, optionalTarget);
          return this.at(t0, optionalTarget);
        };
      }(),
      isIntersectionPlane: function(plane) {
        var distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) {
          return true;
        }
        var denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) {
          return true;
        }
        return false;
      },
      distanceToPlane: function(plane) {
        var denominator = plane.normal.dot(this.direction);
        if (denominator === 0) {
          if (plane.distanceToPoint(this.origin) === 0) {
            return 0;
          }
          return null;
        }
        var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        return t >= 0 ? t : null;
      },
      intersectPlane: function(plane, optionalTarget) {
        var t = this.distanceToPlane(plane);
        if (t === null) {
          return null;
        }
        return this.at(t, optionalTarget);
      },
      isIntersectionBox: function() {
        var v = new THREE.Vector3();
        return function(box) {
          return this.intersectBox(box, v) !== null;
        };
      }(),
      intersectBox: function(box, optionalTarget) {
        var tmin,
            tmax,
            tymin,
            tymax,
            tzmin,
            tzmax;
        var invdirx = 1 / this.direction.x,
            invdiry = 1 / this.direction.y,
            invdirz = 1 / this.direction.z;
        var origin = this.origin;
        if (invdirx >= 0) {
          tmin = (box.min.x - origin.x) * invdirx;
          tmax = (box.max.x - origin.x) * invdirx;
        } else {
          tmin = (box.max.x - origin.x) * invdirx;
          tmax = (box.min.x - origin.x) * invdirx;
        }
        if (invdiry >= 0) {
          tymin = (box.min.y - origin.y) * invdiry;
          tymax = (box.max.y - origin.y) * invdiry;
        } else {
          tymin = (box.max.y - origin.y) * invdiry;
          tymax = (box.min.y - origin.y) * invdiry;
        }
        if ((tmin > tymax) || (tymin > tmax))
          return null;
        if (tymin > tmin || tmin !== tmin)
          tmin = tymin;
        if (tymax < tmax || tmax !== tmax)
          tmax = tymax;
        if (invdirz >= 0) {
          tzmin = (box.min.z - origin.z) * invdirz;
          tzmax = (box.max.z - origin.z) * invdirz;
        } else {
          tzmin = (box.max.z - origin.z) * invdirz;
          tzmax = (box.min.z - origin.z) * invdirz;
        }
        if ((tmin > tzmax) || (tzmin > tmax))
          return null;
        if (tzmin > tmin || tmin !== tmin)
          tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax)
          tmax = tzmax;
        if (tmax < 0)
          return null;
        return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);
      },
      intersectTriangle: function() {
        var diff = new THREE.Vector3();
        var edge1 = new THREE.Vector3();
        var edge2 = new THREE.Vector3();
        var normal = new THREE.Vector3();
        return function(a, b, c, backfaceCulling, optionalTarget) {
          edge1.subVectors(b, a);
          edge2.subVectors(c, a);
          normal.crossVectors(edge1, edge2);
          var DdN = this.direction.dot(normal);
          var sign;
          if (DdN > 0) {
            if (backfaceCulling)
              return null;
            sign = 1;
          } else if (DdN < 0) {
            sign = -1;
            DdN = -DdN;
          } else {
            return null;
          }
          diff.subVectors(this.origin, a);
          var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
          if (DdQxE2 < 0) {
            return null;
          }
          var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
          if (DdE1xQ < 0) {
            return null;
          }
          if (DdQxE2 + DdE1xQ > DdN) {
            return null;
          }
          var QdN = -sign * diff.dot(normal);
          if (QdN < 0) {
            return null;
          }
          return this.at(QdN / DdN, optionalTarget);
        };
      }(),
      applyMatrix4: function(matrix4) {
        this.direction.add(this.origin).applyMatrix4(matrix4);
        this.origin.applyMatrix4(matrix4);
        this.direction.sub(this.origin);
        this.direction.normalize();
        return this;
      },
      equals: function(ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
      }
    };
    THREE.Sphere = function(center, radius) {
      this.center = (center !== undefined) ? center : new THREE.Vector3();
      this.radius = (radius !== undefined) ? radius : 0;
    };
    THREE.Sphere.prototype = {
      constructor: THREE.Sphere,
      set: function(center, radius) {
        this.center.copy(center);
        this.radius = radius;
        return this;
      },
      setFromPoints: function() {
        var box = new THREE.Box3();
        return function(points, optionalCenter) {
          var center = this.center;
          if (optionalCenter !== undefined) {
            center.copy(optionalCenter);
          } else {
            box.setFromPoints(points).center(center);
          }
          var maxRadiusSq = 0;
          for (var i = 0,
              il = points.length; i < il; i++) {
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
          }
          this.radius = Math.sqrt(maxRadiusSq);
          return this;
        };
      }(),
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
      },
      empty: function() {
        return (this.radius <= 0);
      },
      containsPoint: function(point) {
        return (point.distanceToSquared(this.center) <= (this.radius * this.radius));
      },
      distanceToPoint: function(point) {
        return (point.distanceTo(this.center) - this.radius);
      },
      intersectsSphere: function(sphere) {
        var radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);
      },
      clampPoint: function(point, optionalTarget) {
        var deltaLengthSq = this.center.distanceToSquared(point);
        var result = optionalTarget || new THREE.Vector3();
        result.copy(point);
        if (deltaLengthSq > (this.radius * this.radius)) {
          result.sub(this.center).normalize();
          result.multiplyScalar(this.radius).add(this.center);
        }
        return result;
      },
      getBoundingBox: function(optionalTarget) {
        var box = optionalTarget || new THREE.Box3();
        box.set(this.center, this.center);
        box.expandByScalar(this.radius);
        return box;
      },
      applyMatrix4: function(matrix) {
        this.center.applyMatrix4(matrix);
        this.radius = this.radius * matrix.getMaxScaleOnAxis();
        return this;
      },
      translate: function(offset) {
        this.center.add(offset);
        return this;
      },
      equals: function(sphere) {
        return sphere.center.equals(this.center) && (sphere.radius === this.radius);
      }
    };
    THREE.Frustum = function(p0, p1, p2, p3, p4, p5) {
      this.planes = [(p0 !== undefined) ? p0 : new THREE.Plane(), (p1 !== undefined) ? p1 : new THREE.Plane(), (p2 !== undefined) ? p2 : new THREE.Plane(), (p3 !== undefined) ? p3 : new THREE.Plane(), (p4 !== undefined) ? p4 : new THREE.Plane(), (p5 !== undefined) ? p5 : new THREE.Plane()];
    };
    THREE.Frustum.prototype = {
      constructor: THREE.Frustum,
      set: function(p0, p1, p2, p3, p4, p5) {
        var planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p2);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(frustum) {
        var planes = this.planes;
        for (var i = 0; i < 6; i++) {
          planes[i].copy(frustum.planes[i]);
        }
        return this;
      },
      setFromMatrix: function(m) {
        var planes = this.planes;
        var me = m.elements;
        var me0 = me[0],
            me1 = me[1],
            me2 = me[2],
            me3 = me[3];
        var me4 = me[4],
            me5 = me[5],
            me6 = me[6],
            me7 = me[7];
        var me8 = me[8],
            me9 = me[9],
            me10 = me[10],
            me11 = me[11];
        var me12 = me[12],
            me13 = me[13],
            me14 = me[14],
            me15 = me[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
        return this;
      },
      intersectsObject: function() {
        var sphere = new THREE.Sphere();
        return function(object) {
          var geometry = object.geometry;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          sphere.copy(geometry.boundingSphere);
          sphere.applyMatrix4(object.matrixWorld);
          return this.intersectsSphere(sphere);
        };
      }(),
      intersectsSphere: function(sphere) {
        var planes = this.planes;
        var center = sphere.center;
        var negRadius = -sphere.radius;
        for (var i = 0; i < 6; i++) {
          var distance = planes[i].distanceToPoint(center);
          if (distance < negRadius) {
            return false;
          }
        }
        return true;
      },
      intersectsBox: function() {
        var p1 = new THREE.Vector3(),
            p2 = new THREE.Vector3();
        return function(box) {
          var planes = this.planes;
          for (var i = 0; i < 6; i++) {
            var plane = planes[i];
            p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
            p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
            p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
            p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
            p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
            p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
            var d1 = plane.distanceToPoint(p1);
            var d2 = plane.distanceToPoint(p2);
            if (d1 < 0 && d2 < 0) {
              return false;
            }
          }
          return true;
        };
      }(),
      containsPoint: function(point) {
        var planes = this.planes;
        for (var i = 0; i < 6; i++) {
          if (planes[i].distanceToPoint(point) < 0) {
            return false;
          }
        }
        return true;
      }
    };
    THREE.Plane = function(normal, constant) {
      this.normal = (normal !== undefined) ? normal : new THREE.Vector3(1, 0, 0);
      this.constant = (constant !== undefined) ? constant : 0;
    };
    THREE.Plane.prototype = {
      constructor: THREE.Plane,
      set: function(normal, constant) {
        this.normal.copy(normal);
        this.constant = constant;
        return this;
      },
      setComponents: function(x, y, z, w) {
        this.normal.set(x, y, z);
        this.constant = w;
        return this;
      },
      setFromNormalAndCoplanarPoint: function(normal, point) {
        this.normal.copy(normal);
        this.constant = -point.dot(this.normal);
        return this;
      },
      setFromCoplanarPoints: function() {
        var v1 = new THREE.Vector3();
        var v2 = new THREE.Vector3();
        return function(a, b, c) {
          var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
          this.setFromNormalAndCoplanarPoint(normal, a);
          return this;
        };
      }(),
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
      },
      normalize: function() {
        var inverseNormalLength = 1.0 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
      },
      negate: function() {
        this.constant *= -1;
        this.normal.negate();
        return this;
      },
      distanceToPoint: function(point) {
        return this.normal.dot(point) + this.constant;
      },
      distanceToSphere: function(sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
      },
      projectPoint: function(point, optionalTarget) {
        return this.orthoPoint(point, optionalTarget).sub(point).negate();
      },
      orthoPoint: function(point, optionalTarget) {
        var perpendicularMagnitude = this.distanceToPoint(point);
        var result = optionalTarget || new THREE.Vector3();
        return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);
      },
      isIntersectionLine: function(line) {
        var startSign = this.distanceToPoint(line.start);
        var endSign = this.distanceToPoint(line.end);
        return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);
      },
      intersectLine: function() {
        var v1 = new THREE.Vector3();
        return function(line, optionalTarget) {
          var result = optionalTarget || new THREE.Vector3();
          var direction = line.delta(v1);
          var denominator = this.normal.dot(direction);
          if (denominator === 0) {
            if (this.distanceToPoint(line.start) === 0) {
              return result.copy(line.start);
            }
            return undefined;
          }
          var t = -(line.start.dot(this.normal) + this.constant) / denominator;
          if (t < 0 || t > 1) {
            return undefined;
          }
          return result.copy(direction).multiplyScalar(t).add(line.start);
        };
      }(),
      coplanarPoint: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.copy(this.normal).multiplyScalar(-this.constant);
      },
      applyMatrix4: function() {
        var v1 = new THREE.Vector3();
        var v2 = new THREE.Vector3();
        var m1 = new THREE.Matrix3();
        return function(matrix, optionalNormalMatrix) {
          var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
          var newNormal = v1.copy(this.normal).applyMatrix3(normalMatrix);
          var newCoplanarPoint = this.coplanarPoint(v2);
          newCoplanarPoint.applyMatrix4(matrix);
          this.setFromNormalAndCoplanarPoint(newNormal, newCoplanarPoint);
          return this;
        };
      }(),
      translate: function(offset) {
        this.constant = this.constant - offset.dot(this.normal);
        return this;
      },
      equals: function(plane) {
        return plane.normal.equals(this.normal) && (plane.constant === this.constant);
      }
    };
    THREE.Math = {
      generateUUID: function() {
        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
        var uuid = new Array(36);
        var rnd = 0,
            r;
        return function() {
          for (var i = 0; i < 36; i++) {
            if (i === 8 || i === 13 || i === 18 || i === 23) {
              uuid[i] = '-';
            } else if (i === 14) {
              uuid[i] = '4';
            } else {
              if (rnd <= 0x02)
                rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;
              r = rnd & 0xf;
              rnd = rnd >> 4;
              uuid[i] = chars[(i === 19) ? (r & 0x3) | 0x8 : r];
            }
          }
          return uuid.join('');
        };
      }(),
      clamp: function(value, min, max) {
        return Math.max(min, Math.min(max, value));
      },
      euclideanModulo: function(n, m) {
        return ((n % m) + m) % m;
      },
      mapLinear: function(x, a1, a2, b1, b2) {
        return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
      },
      smoothstep: function(x, min, max) {
        if (x <= min)
          return 0;
        if (x >= max)
          return 1;
        x = (x - min) / (max - min);
        return x * x * (3 - 2 * x);
      },
      smootherstep: function(x, min, max) {
        if (x <= min)
          return 0;
        if (x >= max)
          return 1;
        x = (x - min) / (max - min);
        return x * x * x * (x * (x * 6 - 15) + 10);
      },
      random16: function() {
        return (65280 * Math.random() + 255 * Math.random()) / 65535;
      },
      randInt: function(low, high) {
        return low + Math.floor(Math.random() * (high - low + 1));
      },
      randFloat: function(low, high) {
        return low + Math.random() * (high - low);
      },
      randFloatSpread: function(range) {
        return range * (0.5 - Math.random());
      },
      degToRad: function() {
        var degreeToRadiansFactor = Math.PI / 180;
        return function(degrees) {
          return degrees * degreeToRadiansFactor;
        };
      }(),
      radToDeg: function() {
        var radianToDegreesFactor = 180 / Math.PI;
        return function(radians) {
          return radians * radianToDegreesFactor;
        };
      }(),
      isPowerOfTwo: function(value) {
        return (value & (value - 1)) === 0 && value !== 0;
      },
      nearestPowerOfTwo: function(value) {
        return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
      },
      nextPowerOfTwo: function(value) {
        value--;
        value |= value >> 1;
        value |= value >> 2;
        value |= value >> 4;
        value |= value >> 8;
        value |= value >> 16;
        value++;
        return value;
      }
    };
    THREE.Spline = function(points) {
      this.points = points;
      var c = [],
          v3 = {
            x: 0,
            y: 0,
            z: 0
          },
          point,
          intPoint,
          weight,
          w2,
          w3,
          pa,
          pb,
          pc,
          pd;
      this.initFromArray = function(a) {
        this.points = [];
        for (var i = 0; i < a.length; i++) {
          this.points[i] = {
            x: a[i][0],
            y: a[i][1],
            z: a[i][2]
          };
        }
      };
      this.getPoint = function(k) {
        point = (this.points.length - 1) * k;
        intPoint = Math.floor(point);
        weight = point - intPoint;
        c[0] = intPoint === 0 ? intPoint : intPoint - 1;
        c[1] = intPoint;
        c[2] = intPoint > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
        c[3] = intPoint > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;
        pa = this.points[c[0]];
        pb = this.points[c[1]];
        pc = this.points[c[2]];
        pd = this.points[c[3]];
        w2 = weight * weight;
        w3 = weight * w2;
        v3.x = interpolate(pa.x, pb.x, pc.x, pd.x, weight, w2, w3);
        v3.y = interpolate(pa.y, pb.y, pc.y, pd.y, weight, w2, w3);
        v3.z = interpolate(pa.z, pb.z, pc.z, pd.z, weight, w2, w3);
        return v3;
      };
      this.getControlPointsArray = function() {
        var i,
            p,
            l = this.points.length,
            coords = [];
        for (i = 0; i < l; i++) {
          p = this.points[i];
          coords[i] = [p.x, p.y, p.z];
        }
        return coords;
      };
      this.getLength = function(nSubDivisions) {
        var i,
            index,
            nSamples,
            position,
            point = 0,
            intPoint = 0,
            oldIntPoint = 0,
            oldPosition = new THREE.Vector3(),
            tmpVec = new THREE.Vector3(),
            chunkLengths = [],
            totalLength = 0;
        chunkLengths[0] = 0;
        if (!nSubDivisions)
          nSubDivisions = 100;
        nSamples = this.points.length * nSubDivisions;
        oldPosition.copy(this.points[0]);
        for (i = 1; i < nSamples; i++) {
          index = i / nSamples;
          position = this.getPoint(index);
          tmpVec.copy(position);
          totalLength += tmpVec.distanceTo(oldPosition);
          oldPosition.copy(position);
          point = (this.points.length - 1) * index;
          intPoint = Math.floor(point);
          if (intPoint !== oldIntPoint) {
            chunkLengths[intPoint] = totalLength;
            oldIntPoint = intPoint;
          }
        }
        chunkLengths[chunkLengths.length] = totalLength;
        return {
          chunks: chunkLengths,
          total: totalLength
        };
      };
      this.reparametrizeByArcLength = function(samplingCoef) {
        var i,
            j,
            index,
            indexCurrent,
            indexNext,
            realDistance,
            sampling,
            position,
            newpoints = [],
            tmpVec = new THREE.Vector3(),
            sl = this.getLength();
        newpoints.push(tmpVec.copy(this.points[0]).clone());
        for (i = 1; i < this.points.length; i++) {
          realDistance = sl.chunks[i] - sl.chunks[i - 1];
          sampling = Math.ceil(samplingCoef * realDistance / sl.total);
          indexCurrent = (i - 1) / (this.points.length - 1);
          indexNext = i / (this.points.length - 1);
          for (j = 1; j < sampling - 1; j++) {
            index = indexCurrent + j * (1 / sampling) * (indexNext - indexCurrent);
            position = this.getPoint(index);
            newpoints.push(tmpVec.copy(position).clone());
          }
          newpoints.push(tmpVec.copy(this.points[i]).clone());
        }
        this.points = newpoints;
      };
      function interpolate(p0, p1, p2, p3, t, t2, t3) {
        var v0 = (p2 - p0) * 0.5,
            v1 = (p3 - p1) * 0.5;
        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
      }
    };
    THREE.Triangle = function(a, b, c) {
      this.a = (a !== undefined) ? a : new THREE.Vector3();
      this.b = (b !== undefined) ? b : new THREE.Vector3();
      this.c = (c !== undefined) ? c : new THREE.Vector3();
    };
    THREE.Triangle.normal = function() {
      var v0 = new THREE.Vector3();
      return function(a, b, c, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        result.subVectors(c, b);
        v0.subVectors(a, b);
        result.cross(v0);
        var resultLengthSq = result.lengthSq();
        if (resultLengthSq > 0) {
          return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));
        }
        return result.set(0, 0, 0);
      };
    }();
    THREE.Triangle.barycoordFromPoint = function() {
      var v0 = new THREE.Vector3();
      var v1 = new THREE.Vector3();
      var v2 = new THREE.Vector3();
      return function(point, a, b, c, optionalTarget) {
        v0.subVectors(c, a);
        v1.subVectors(b, a);
        v2.subVectors(point, a);
        var dot00 = v0.dot(v0);
        var dot01 = v0.dot(v1);
        var dot02 = v0.dot(v2);
        var dot11 = v1.dot(v1);
        var dot12 = v1.dot(v2);
        var denom = (dot00 * dot11 - dot01 * dot01);
        var result = optionalTarget || new THREE.Vector3();
        if (denom === 0) {
          return result.set(-2, -1, -1);
        }
        var invDenom = 1 / denom;
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return result.set(1 - u - v, v, u);
      };
    }();
    THREE.Triangle.containsPoint = function() {
      var v1 = new THREE.Vector3();
      return function(point, a, b, c) {
        var result = THREE.Triangle.barycoordFromPoint(point, a, b, c, v1);
        return (result.x >= 0) && (result.y >= 0) && ((result.x + result.y) <= 1);
      };
    }();
    THREE.Triangle.prototype = {
      constructor: THREE.Triangle,
      set: function(a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this;
      },
      setFromPointsAndIndices: function(points, i0, i1, i2) {
        this.a.copy(points[i0]);
        this.b.copy(points[i1]);
        this.c.copy(points[i2]);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
      },
      area: function() {
        var v0 = new THREE.Vector3();
        var v1 = new THREE.Vector3();
        return function() {
          v0.subVectors(this.c, this.b);
          v1.subVectors(this.a, this.b);
          return v0.cross(v1).length() * 0.5;
        };
      }(),
      midpoint: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
      },
      normal: function(optionalTarget) {
        return THREE.Triangle.normal(this.a, this.b, this.c, optionalTarget);
      },
      plane: function(optionalTarget) {
        var result = optionalTarget || new THREE.Plane();
        return result.setFromCoplanarPoints(this.a, this.b, this.c);
      },
      barycoordFromPoint: function(point, optionalTarget) {
        return THREE.Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);
      },
      containsPoint: function(point) {
        return THREE.Triangle.containsPoint(point, this.a, this.b, this.c);
      },
      equals: function(triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
      }
    };
    THREE.Channels = function() {
      this.mask = 1;
    };
    THREE.Channels.prototype = {
      constructor: THREE.Channels,
      set: function(channel) {
        this.mask = 1 << channel;
      },
      enable: function(channel) {
        this.mask |= 1 << channel;
      },
      toggle: function(channel) {
        this.mask ^= 1 << channel;
      },
      disable: function(channel) {
        this.mask &= ~(1 << channel);
      }
    };
    THREE.Clock = function(autoStart) {
      this.autoStart = (autoStart !== undefined) ? autoStart : true;
      this.startTime = 0;
      this.oldTime = 0;
      this.elapsedTime = 0;
      this.running = false;
    };
    THREE.Clock.prototype = {
      constructor: THREE.Clock,
      start: function() {
        this.startTime = self.performance.now();
        this.oldTime = this.startTime;
        this.running = true;
      },
      stop: function() {
        this.getElapsedTime();
        this.running = false;
      },
      getElapsedTime: function() {
        this.getDelta();
        return this.elapsedTime;
      },
      getDelta: function() {
        var diff = 0;
        if (this.autoStart && !this.running) {
          this.start();
        }
        if (this.running) {
          var newTime = self.performance.now();
          diff = 0.001 * (newTime - this.oldTime);
          this.oldTime = newTime;
          this.elapsedTime += diff;
        }
        return diff;
      }
    };
    THREE.EventDispatcher = function() {};
    THREE.EventDispatcher.prototype = {
      constructor: THREE.EventDispatcher,
      apply: function(object) {
        object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
        object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
        object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
        object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;
      },
      addEventListener: function(type, listener) {
        if (this._listeners === undefined)
          this._listeners = {};
        var listeners = this._listeners;
        if (listeners[type] === undefined) {
          listeners[type] = [];
        }
        if (listeners[type].indexOf(listener) === -1) {
          listeners[type].push(listener);
        }
      },
      hasEventListener: function(type, listener) {
        if (this._listeners === undefined)
          return false;
        var listeners = this._listeners;
        if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {
          return true;
        }
        return false;
      },
      removeEventListener: function(type, listener) {
        if (this._listeners === undefined)
          return;
        var listeners = this._listeners;
        var listenerArray = listeners[type];
        if (listenerArray !== undefined) {
          var index = listenerArray.indexOf(listener);
          if (index !== -1) {
            listenerArray.splice(index, 1);
          }
        }
      },
      dispatchEvent: function(event) {
        if (this._listeners === undefined)
          return;
        var listeners = this._listeners;
        var listenerArray = listeners[event.type];
        if (listenerArray !== undefined) {
          event.target = this;
          var array = [];
          var length = listenerArray.length;
          for (var i = 0; i < length; i++) {
            array[i] = listenerArray[i];
          }
          for (var i = 0; i < length; i++) {
            array[i].call(this, event);
          }
        }
      }
    };
    (function(THREE) {
      THREE.Raycaster = function(origin, direction, near, far) {
        this.ray = new THREE.Ray(origin, direction);
        this.near = near || 0;
        this.far = far || Infinity;
        this.params = {
          Mesh: {},
          Line: {},
          LOD: {},
          Points: {threshold: 1},
          Sprite: {}
        };
        Object.defineProperties(this.params, {PointCloud: {get: function() {
              console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
              return this.Points;
            }}});
      };
      function descSort(a, b) {
        return a.distance - b.distance;
      }
      function intersectObject(object, raycaster, intersects, recursive) {
        if (object.visible === false)
          return;
        object.raycast(raycaster, intersects);
        if (recursive === true) {
          var children = object.children;
          for (var i = 0,
              l = children.length; i < l; i++) {
            intersectObject(children[i], raycaster, intersects, true);
          }
        }
      }
      THREE.Raycaster.prototype = {
        constructor: THREE.Raycaster,
        linePrecision: 1,
        set: function(origin, direction) {
          this.ray.set(origin, direction);
        },
        setFromCamera: function(coords, camera) {
          if (camera instanceof THREE.PerspectiveCamera) {
            this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
          } else if (camera instanceof THREE.OrthographicCamera) {
            this.ray.origin.set(coords.x, coords.y, -1).unproject(camera);
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
          } else {
            console.error('THREE.Raycaster: Unsupported camera type.');
          }
        },
        intersectObject: function(object, recursive) {
          var intersects = [];
          intersectObject(object, this, intersects, recursive);
          intersects.sort(descSort);
          return intersects;
        },
        intersectObjects: function(objects, recursive) {
          var intersects = [];
          if (Array.isArray(objects) === false) {
            console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
            return intersects;
          }
          for (var i = 0,
              l = objects.length; i < l; i++) {
            intersectObject(objects[i], this, intersects, recursive);
          }
          intersects.sort(descSort);
          return intersects;
        }
      };
    }(THREE));
    THREE.Object3D = function() {
      Object.defineProperty(this, 'id', {value: THREE.Object3DIdCount++});
      this.uuid = THREE.Math.generateUUID();
      this.name = '';
      this.type = 'Object3D';
      this.parent = null;
      this.channels = new THREE.Channels();
      this.children = [];
      this.up = THREE.Object3D.DefaultUp.clone();
      var position = new THREE.Vector3();
      var rotation = new THREE.Euler();
      var quaternion = new THREE.Quaternion();
      var scale = new THREE.Vector3(1, 1, 1);
      function onRotationChange() {
        quaternion.setFromEuler(rotation, false);
      }
      function onQuaternionChange() {
        rotation.setFromQuaternion(quaternion, undefined, false);
      }
      rotation.onChange(onRotationChange);
      quaternion.onChange(onQuaternionChange);
      Object.defineProperties(this, {
        position: {
          enumerable: true,
          value: position
        },
        rotation: {
          enumerable: true,
          value: rotation
        },
        quaternion: {
          enumerable: true,
          value: quaternion
        },
        scale: {
          enumerable: true,
          value: scale
        },
        modelViewMatrix: {value: new THREE.Matrix4()},
        normalMatrix: {value: new THREE.Matrix3()}
      });
      this.rotationAutoUpdate = true;
      this.matrix = new THREE.Matrix4();
      this.matrixWorld = new THREE.Matrix4();
      this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
      this.matrixWorldNeedsUpdate = false;
      this.visible = true;
      this.castShadow = false;
      this.receiveShadow = false;
      this.frustumCulled = true;
      this.renderOrder = 0;
      this.userData = {};
    };
    THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0);
    THREE.Object3D.DefaultMatrixAutoUpdate = true;
    THREE.Object3D.prototype = {
      constructor: THREE.Object3D,
      get eulerOrder() {
        console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
        return this.rotation.order;
      },
      set eulerOrder(value) {
        console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
        this.rotation.order = value;
      },
      get useQuaternion() {
        console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
      },
      set useQuaternion(value) {
        console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
      },
      set renderDepth(value) {
        console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
      },
      applyMatrix: function(matrix) {
        this.matrix.multiplyMatrices(matrix, this.matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
      },
      setRotationFromAxisAngle: function(axis, angle) {
        this.quaternion.setFromAxisAngle(axis, angle);
      },
      setRotationFromEuler: function(euler) {
        this.quaternion.setFromEuler(euler, true);
      },
      setRotationFromMatrix: function(m) {
        this.quaternion.setFromRotationMatrix(m);
      },
      setRotationFromQuaternion: function(q) {
        this.quaternion.copy(q);
      },
      rotateOnAxis: function() {
        var q1 = new THREE.Quaternion();
        return function(axis, angle) {
          q1.setFromAxisAngle(axis, angle);
          this.quaternion.multiply(q1);
          return this;
        };
      }(),
      rotateX: function() {
        var v1 = new THREE.Vector3(1, 0, 0);
        return function(angle) {
          return this.rotateOnAxis(v1, angle);
        };
      }(),
      rotateY: function() {
        var v1 = new THREE.Vector3(0, 1, 0);
        return function(angle) {
          return this.rotateOnAxis(v1, angle);
        };
      }(),
      rotateZ: function() {
        var v1 = new THREE.Vector3(0, 0, 1);
        return function(angle) {
          return this.rotateOnAxis(v1, angle);
        };
      }(),
      translateOnAxis: function() {
        var v1 = new THREE.Vector3();
        return function(axis, distance) {
          v1.copy(axis).applyQuaternion(this.quaternion);
          this.position.add(v1.multiplyScalar(distance));
          return this;
        };
      }(),
      translate: function(distance, axis) {
        console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
        return this.translateOnAxis(axis, distance);
      },
      translateX: function() {
        var v1 = new THREE.Vector3(1, 0, 0);
        return function(distance) {
          return this.translateOnAxis(v1, distance);
        };
      }(),
      translateY: function() {
        var v1 = new THREE.Vector3(0, 1, 0);
        return function(distance) {
          return this.translateOnAxis(v1, distance);
        };
      }(),
      translateZ: function() {
        var v1 = new THREE.Vector3(0, 0, 1);
        return function(distance) {
          return this.translateOnAxis(v1, distance);
        };
      }(),
      localToWorld: function(vector) {
        return vector.applyMatrix4(this.matrixWorld);
      },
      worldToLocal: function() {
        var m1 = new THREE.Matrix4();
        return function(vector) {
          return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
        };
      }(),
      lookAt: function() {
        var m1 = new THREE.Matrix4();
        return function(vector) {
          m1.lookAt(vector, this.position, this.up);
          this.quaternion.setFromRotationMatrix(m1);
        };
      }(),
      add: function(object) {
        if (arguments.length > 1) {
          for (var i = 0; i < arguments.length; i++) {
            this.add(arguments[i]);
          }
          return this;
        }
        if (object === this) {
          console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
          return this;
        }
        if (object instanceof THREE.Object3D) {
          if (object.parent !== null) {
            object.parent.remove(object);
          }
          object.parent = this;
          object.dispatchEvent({type: 'added'});
          this.children.push(object);
        } else {
          console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
        }
        return this;
      },
      remove: function(object) {
        if (arguments.length > 1) {
          for (var i = 0; i < arguments.length; i++) {
            this.remove(arguments[i]);
          }
        }
        var index = this.children.indexOf(object);
        if (index !== -1) {
          object.parent = null;
          object.dispatchEvent({type: 'removed'});
          this.children.splice(index, 1);
        }
      },
      getChildByName: function(name) {
        console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
        return this.getObjectByName(name);
      },
      getObjectById: function(id) {
        return this.getObjectByProperty('id', id);
      },
      getObjectByName: function(name) {
        return this.getObjectByProperty('name', name);
      },
      getObjectByProperty: function(name, value) {
        if (this[name] === value)
          return this;
        for (var i = 0,
            l = this.children.length; i < l; i++) {
          var child = this.children[i];
          var object = child.getObjectByProperty(name, value);
          if (object !== undefined) {
            return object;
          }
        }
        return undefined;
      },
      getWorldPosition: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        this.updateMatrixWorld(true);
        return result.setFromMatrixPosition(this.matrixWorld);
      },
      getWorldQuaternion: function() {
        var position = new THREE.Vector3();
        var scale = new THREE.Vector3();
        return function(optionalTarget) {
          var result = optionalTarget || new THREE.Quaternion();
          this.updateMatrixWorld(true);
          this.matrixWorld.decompose(position, result, scale);
          return result;
        };
      }(),
      getWorldRotation: function() {
        var quaternion = new THREE.Quaternion();
        return function(optionalTarget) {
          var result = optionalTarget || new THREE.Euler();
          this.getWorldQuaternion(quaternion);
          return result.setFromQuaternion(quaternion, this.rotation.order, false);
        };
      }(),
      getWorldScale: function() {
        var position = new THREE.Vector3();
        var quaternion = new THREE.Quaternion();
        return function(optionalTarget) {
          var result = optionalTarget || new THREE.Vector3();
          this.updateMatrixWorld(true);
          this.matrixWorld.decompose(position, quaternion, result);
          return result;
        };
      }(),
      getWorldDirection: function() {
        var quaternion = new THREE.Quaternion();
        return function(optionalTarget) {
          var result = optionalTarget || new THREE.Vector3();
          this.getWorldQuaternion(quaternion);
          return result.set(0, 0, 1).applyQuaternion(quaternion);
        };
      }(),
      raycast: function() {},
      traverse: function(callback) {
        callback(this);
        var children = this.children;
        for (var i = 0,
            l = children.length; i < l; i++) {
          children[i].traverse(callback);
        }
      },
      traverseVisible: function(callback) {
        if (this.visible === false)
          return;
        callback(this);
        var children = this.children;
        for (var i = 0,
            l = children.length; i < l; i++) {
          children[i].traverseVisible(callback);
        }
      },
      traverseAncestors: function(callback) {
        var parent = this.parent;
        if (parent !== null) {
          callback(parent);
          parent.traverseAncestors(callback);
        }
      },
      updateMatrix: function() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
      },
      updateMatrixWorld: function(force) {
        if (this.matrixAutoUpdate === true)
          this.updateMatrix();
        if (this.matrixWorldNeedsUpdate === true || force === true) {
          if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }
          this.matrixWorldNeedsUpdate = false;
          force = true;
        }
        for (var i = 0,
            l = this.children.length; i < l; i++) {
          this.children[i].updateMatrixWorld(force);
        }
      },
      toJSON: function(meta) {
        var isRootObject = (meta === undefined);
        var output = {};
        if (isRootObject) {
          meta = {
            geometries: {},
            materials: {},
            textures: {},
            images: {}
          };
          output.metadata = {
            version: 4.4,
            type: 'Object',
            generator: 'Object3D.toJSON'
          };
        }
        var object = {};
        object.uuid = this.uuid;
        object.type = this.type;
        if (this.name !== '')
          object.name = this.name;
        if (JSON.stringify(this.userData) !== '{}')
          object.userData = this.userData;
        if (this.castShadow === true)
          object.castShadow = true;
        if (this.receiveShadow === true)
          object.receiveShadow = true;
        if (this.visible === false)
          object.visible = false;
        object.matrix = this.matrix.toArray();
        if (this.geometry !== undefined) {
          if (meta.geometries[this.geometry.uuid] === undefined) {
            meta.geometries[this.geometry.uuid] = this.geometry.toJSON(meta);
          }
          object.geometry = this.geometry.uuid;
        }
        if (this.material !== undefined) {
          if (meta.materials[this.material.uuid] === undefined) {
            meta.materials[this.material.uuid] = this.material.toJSON(meta);
          }
          object.material = this.material.uuid;
        }
        if (this.children.length > 0) {
          object.children = [];
          for (var i = 0; i < this.children.length; i++) {
            object.children.push(this.children[i].toJSON(meta).object);
          }
        }
        if (isRootObject) {
          var geometries = extractFromCache(meta.geometries);
          var materials = extractFromCache(meta.materials);
          var textures = extractFromCache(meta.textures);
          var images = extractFromCache(meta.images);
          if (geometries.length > 0)
            output.geometries = geometries;
          if (materials.length > 0)
            output.materials = materials;
          if (textures.length > 0)
            output.textures = textures;
          if (images.length > 0)
            output.images = images;
        }
        output.object = object;
        return output;
        function extractFromCache(cache) {
          var values = [];
          for (var key in cache) {
            var data = cache[key];
            delete data.metadata;
            values.push(data);
          }
          return values;
        }
      },
      clone: function(recursive) {
        return new this.constructor().copy(this, recursive);
      },
      copy: function(source, recursive) {
        if (recursive === undefined)
          recursive = true;
        this.name = source.name;
        this.up.copy(source.up);
        this.position.copy(source.position);
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.rotationAutoUpdate = source.rotationAutoUpdate;
        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
        this.visible = source.visible;
        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;
        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        if (recursive === true) {
          for (var i = 0; i < source.children.length; i++) {
            var child = source.children[i];
            this.add(child.clone());
          }
        }
        return this;
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);
    THREE.Object3DIdCount = 0;
    THREE.Face3 = function(a, b, c, normal, color, materialIndex) {
      this.a = a;
      this.b = b;
      this.c = c;
      this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
      this.vertexNormals = Array.isArray(normal) ? normal : [];
      this.color = color instanceof THREE.Color ? color : new THREE.Color();
      this.vertexColors = Array.isArray(color) ? color : [];
      this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
    };
    THREE.Face3.prototype = {
      constructor: THREE.Face3,
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(source) {
        this.a = source.a;
        this.b = source.b;
        this.c = source.c;
        this.normal.copy(source.normal);
        this.color.copy(source.color);
        this.materialIndex = source.materialIndex;
        for (var i = 0,
            il = source.vertexNormals.length; i < il; i++) {
          this.vertexNormals[i] = source.vertexNormals[i].clone();
        }
        for (var i = 0,
            il = source.vertexColors.length; i < il; i++) {
          this.vertexColors[i] = source.vertexColors[i].clone();
        }
        return this;
      }
    };
    THREE.Face4 = function(a, b, c, d, normal, color, materialIndex) {
      console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
      return new THREE.Face3(a, b, c, normal, color, materialIndex);
    };
    THREE.BufferAttribute = function(array, itemSize) {
      this.uuid = THREE.Math.generateUUID();
      this.array = array;
      this.itemSize = itemSize;
      this.dynamic = false;
      this.updateRange = {
        offset: 0,
        count: -1
      };
      this.version = 0;
    };
    THREE.BufferAttribute.prototype = {
      constructor: THREE.BufferAttribute,
      get length() {
        console.warn('THREE.BufferAttribute: .length has been deprecated. Please use .count.');
        return this.array.length;
      },
      get count() {
        return this.array.length / this.itemSize;
      },
      set needsUpdate(value) {
        if (value === true)
          this.version++;
      },
      setDynamic: function(value) {
        this.dynamic = value;
        return this;
      },
      copy: function(source) {
        this.array = new source.array.constructor(source.array);
        this.itemSize = source.itemSize;
        this.dynamic = source.dynamic;
        return this;
      },
      copyAt: function(index1, attribute, index2) {
        index1 *= this.itemSize;
        index2 *= attribute.itemSize;
        for (var i = 0,
            l = this.itemSize; i < l; i++) {
          this.array[index1 + i] = attribute.array[index2 + i];
        }
        return this;
      },
      copyArray: function(array) {
        this.array.set(array);
        return this;
      },
      copyColorsArray: function(colors) {
        var array = this.array,
            offset = 0;
        for (var i = 0,
            l = colors.length; i < l; i++) {
          var color = colors[i];
          if (color === undefined) {
            console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
            color = new THREE.Color();
          }
          array[offset++] = color.r;
          array[offset++] = color.g;
          array[offset++] = color.b;
        }
        return this;
      },
      copyIndicesArray: function(indices) {
        var array = this.array,
            offset = 0;
        for (var i = 0,
            l = indices.length; i < l; i++) {
          var index = indices[i];
          array[offset++] = index.a;
          array[offset++] = index.b;
          array[offset++] = index.c;
        }
        return this;
      },
      copyVector2sArray: function(vectors) {
        var array = this.array,
            offset = 0;
        for (var i = 0,
            l = vectors.length; i < l; i++) {
          var vector = vectors[i];
          if (vector === undefined) {
            console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
            vector = new THREE.Vector2();
          }
          array[offset++] = vector.x;
          array[offset++] = vector.y;
        }
        return this;
      },
      copyVector3sArray: function(vectors) {
        var array = this.array,
            offset = 0;
        for (var i = 0,
            l = vectors.length; i < l; i++) {
          var vector = vectors[i];
          if (vector === undefined) {
            console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
            vector = new THREE.Vector3();
          }
          array[offset++] = vector.x;
          array[offset++] = vector.y;
          array[offset++] = vector.z;
        }
        return this;
      },
      copyVector4sArray: function(vectors) {
        var array = this.array,
            offset = 0;
        for (var i = 0,
            l = vectors.length; i < l; i++) {
          var vector = vectors[i];
          if (vector === undefined) {
            console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
            vector = new THREE.Vector4();
          }
          array[offset++] = vector.x;
          array[offset++] = vector.y;
          array[offset++] = vector.z;
          array[offset++] = vector.w;
        }
        return this;
      },
      set: function(value, offset) {
        if (offset === undefined)
          offset = 0;
        this.array.set(value, offset);
        return this;
      },
      getX: function(index) {
        return this.array[index * this.itemSize];
      },
      setX: function(index, x) {
        this.array[index * this.itemSize] = x;
        return this;
      },
      getY: function(index) {
        return this.array[index * this.itemSize + 1];
      },
      setY: function(index, y) {
        this.array[index * this.itemSize + 1] = y;
        return this;
      },
      getZ: function(index) {
        return this.array[index * this.itemSize + 2];
      },
      setZ: function(index, z) {
        this.array[index * this.itemSize + 2] = z;
        return this;
      },
      getW: function(index) {
        return this.array[index * this.itemSize + 3];
      },
      setW: function(index, w) {
        this.array[index * this.itemSize + 3] = w;
        return this;
      },
      setXY: function(index, x, y) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        return this;
      },
      setXYZ: function(index, x, y, z) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        return this;
      },
      setXYZW: function(index, x, y, z, w) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        this.array[index + 3] = w;
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      }
    };
    THREE.Int8Attribute = function(array, itemSize) {
      return new THREE.BufferAttribute(new Int8Array(array), itemSize);
    };
    THREE.Uint8Attribute = function(array, itemSize) {
      return new THREE.BufferAttribute(new Uint8Array(array), itemSize);
    };
    THREE.Uint8ClampedAttribute = function(array, itemSize) {
      return new THREE.BufferAttribute(new Uint8ClampedArray(array), itemSize);
    };
    THREE.Int16Attribute = function(array, itemSize) {
      return new THREE.BufferAttribute(new Int16Array(array), itemSize);
    };
    THREE.Uint16Attribute = function(array, itemSize) {
      return new THREE.BufferAttribute(new Uint16Array(array), itemSize);
    };
    THREE.Int32Attribute = function(array, itemSize) {
      return new THREE.BufferAttribute(new Int32Array(array), itemSize);
    };
    THREE.Uint32Attribute = function(array, itemSize) {
      return new THREE.BufferAttribute(new Uint32Array(array), itemSize);
    };
    THREE.Float32Attribute = function(array, itemSize) {
      return new THREE.BufferAttribute(new Float32Array(array), itemSize);
    };
    THREE.Float64Attribute = function(array, itemSize) {
      return new THREE.BufferAttribute(new Float64Array(array), itemSize);
    };
    THREE.DynamicBufferAttribute = function(array, itemSize) {
      console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.');
      return new THREE.BufferAttribute(array, itemSize).setDynamic(true);
    };
    THREE.InstancedBufferAttribute = function(array, itemSize, meshPerAttribute) {
      THREE.BufferAttribute.call(this, array, itemSize);
      this.meshPerAttribute = meshPerAttribute || 1;
    };
    THREE.InstancedBufferAttribute.prototype = Object.create(THREE.BufferAttribute.prototype);
    THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;
    THREE.InstancedBufferAttribute.prototype.copy = function(source) {
      THREE.BufferAttribute.prototype.copy.call(this, source);
      this.meshPerAttribute = source.meshPerAttribute;
      return this;
    };
    THREE.InterleavedBuffer = function(array, stride) {
      this.uuid = THREE.Math.generateUUID();
      this.array = array;
      this.stride = stride;
      this.dynamic = false;
      this.updateRange = {
        offset: 0,
        count: -1
      };
      this.version = 0;
    };
    THREE.InterleavedBuffer.prototype = {
      constructor: THREE.InterleavedBuffer,
      get length() {
        return this.array.length;
      },
      get count() {
        return this.array.length / this.stride;
      },
      set needsUpdate(value) {
        if (value === true)
          this.version++;
      },
      setDynamic: function(value) {
        this.dynamic = value;
        return this;
      },
      copy: function(source) {
        this.array = new source.array.constructor(source.array);
        this.stride = source.stride;
        this.dynamic = source.dynamic;
      },
      copyAt: function(index1, attribute, index2) {
        index1 *= this.stride;
        index2 *= attribute.stride;
        for (var i = 0,
            l = this.stride; i < l; i++) {
          this.array[index1 + i] = attribute.array[index2 + i];
        }
        return this;
      },
      set: function(value, offset) {
        if (offset === undefined)
          offset = 0;
        this.array.set(value, offset);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      }
    };
    THREE.InstancedInterleavedBuffer = function(array, stride, meshPerAttribute) {
      THREE.InterleavedBuffer.call(this, array, stride);
      this.meshPerAttribute = meshPerAttribute || 1;
    };
    THREE.InstancedInterleavedBuffer.prototype = Object.create(THREE.InterleavedBuffer.prototype);
    THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;
    THREE.InstancedInterleavedBuffer.prototype.copy = function(source) {
      THREE.InterleavedBuffer.prototype.copy.call(this, source);
      this.meshPerAttribute = source.meshPerAttribute;
      return this;
    };
    THREE.InterleavedBufferAttribute = function(interleavedBuffer, itemSize, offset) {
      this.uuid = THREE.Math.generateUUID();
      this.data = interleavedBuffer;
      this.itemSize = itemSize;
      this.offset = offset;
    };
    THREE.InterleavedBufferAttribute.prototype = {
      constructor: THREE.InterleavedBufferAttribute,
      get length() {
        console.warn('THREE.BufferAttribute: .length has been deprecated. Please use .count.');
        return this.array.length;
      },
      get count() {
        return this.data.array.length / this.data.stride;
      },
      setX: function(index, x) {
        this.data.array[index * this.data.stride + this.offset] = x;
        return this;
      },
      setY: function(index, y) {
        this.data.array[index * this.data.stride + this.offset + 1] = y;
        return this;
      },
      setZ: function(index, z) {
        this.data.array[index * this.data.stride + this.offset + 2] = z;
        return this;
      },
      setW: function(index, w) {
        this.data.array[index * this.data.stride + this.offset + 3] = w;
        return this;
      },
      getX: function(index) {
        return this.data.array[index * this.data.stride + this.offset];
      },
      getY: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 1];
      },
      getZ: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 2];
      },
      getW: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 3];
      },
      setXY: function(index, x, y) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        return this;
      },
      setXYZ: function(index, x, y, z) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        return this;
      },
      setXYZW: function(index, x, y, z, w) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        this.data.array[index + 3] = w;
        return this;
      }
    };
    THREE.Geometry = function() {
      Object.defineProperty(this, 'id', {value: THREE.GeometryIdCount++});
      this.uuid = THREE.Math.generateUUID();
      this.name = '';
      this.type = 'Geometry';
      this.vertices = [];
      this.colors = [];
      this.faces = [];
      this.faceVertexUvs = [[]];
      this.morphTargets = [];
      this.morphNormals = [];
      this.skinWeights = [];
      this.skinIndices = [];
      this.lineDistances = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.verticesNeedUpdate = false;
      this.elementsNeedUpdate = false;
      this.uvsNeedUpdate = false;
      this.normalsNeedUpdate = false;
      this.colorsNeedUpdate = false;
      this.lineDistancesNeedUpdate = false;
      this.groupsNeedUpdate = false;
    };
    THREE.Geometry.prototype = {
      constructor: THREE.Geometry,
      applyMatrix: function(matrix) {
        var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
        for (var i = 0,
            il = this.vertices.length; i < il; i++) {
          var vertex = this.vertices[i];
          vertex.applyMatrix4(matrix);
        }
        for (var i = 0,
            il = this.faces.length; i < il; i++) {
          var face = this.faces[i];
          face.normal.applyMatrix3(normalMatrix).normalize();
          for (var j = 0,
              jl = face.vertexNormals.length; j < jl; j++) {
            face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
          }
        }
        if (this.boundingBox !== null) {
          this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
          this.computeBoundingSphere();
        }
        this.verticesNeedUpdate = true;
        this.normalsNeedUpdate = true;
      },
      rotateX: function() {
        var m1;
        return function rotateX(angle) {
          if (m1 === undefined)
            m1 = new THREE.Matrix4();
          m1.makeRotationX(angle);
          this.applyMatrix(m1);
          return this;
        };
      }(),
      rotateY: function() {
        var m1;
        return function rotateY(angle) {
          if (m1 === undefined)
            m1 = new THREE.Matrix4();
          m1.makeRotationY(angle);
          this.applyMatrix(m1);
          return this;
        };
      }(),
      rotateZ: function() {
        var m1;
        return function rotateZ(angle) {
          if (m1 === undefined)
            m1 = new THREE.Matrix4();
          m1.makeRotationZ(angle);
          this.applyMatrix(m1);
          return this;
        };
      }(),
      translate: function() {
        var m1;
        return function translate(x, y, z) {
          if (m1 === undefined)
            m1 = new THREE.Matrix4();
          m1.makeTranslation(x, y, z);
          this.applyMatrix(m1);
          return this;
        };
      }(),
      scale: function() {
        var m1;
        return function scale(x, y, z) {
          if (m1 === undefined)
            m1 = new THREE.Matrix4();
          m1.makeScale(x, y, z);
          this.applyMatrix(m1);
          return this;
        };
      }(),
      lookAt: function() {
        var obj;
        return function lookAt(vector) {
          if (obj === undefined)
            obj = new THREE.Object3D();
          obj.lookAt(vector);
          obj.updateMatrix();
          this.applyMatrix(obj.matrix);
        };
      }(),
      fromBufferGeometry: function(geometry) {
        var scope = this;
        var indices = geometry.index !== null ? geometry.index.array : undefined;
        var attributes = geometry.attributes;
        var vertices = attributes.position.array;
        var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
        var colors = attributes.color !== undefined ? attributes.color.array : undefined;
        var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
        var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
        if (uvs2 !== undefined)
          this.faceVertexUvs[1] = [];
        var tempNormals = [];
        var tempUVs = [];
        var tempUVs2 = [];
        for (var i = 0,
            j = 0,
            k = 0; i < vertices.length; i += 3, j += 2, k += 4) {
          scope.vertices.push(new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]));
          if (normals !== undefined) {
            tempNormals.push(new THREE.Vector3(normals[i], normals[i + 1], normals[i + 2]));
          }
          if (colors !== undefined) {
            scope.colors.push(new THREE.Color(colors[i], colors[i + 1], colors[i + 2]));
          }
          if (uvs !== undefined) {
            tempUVs.push(new THREE.Vector2(uvs[j], uvs[j + 1]));
          }
          if (uvs2 !== undefined) {
            tempUVs2.push(new THREE.Vector2(uvs2[j], uvs2[j + 1]));
          }
        }
        function addFace(a, b, c) {
          var vertexNormals = normals !== undefined ? [tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone()] : [];
          var vertexColors = colors !== undefined ? [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()] : [];
          var face = new THREE.Face3(a, b, c, vertexNormals, vertexColors);
          scope.faces.push(face);
          if (uvs !== undefined) {
            scope.faceVertexUvs[0].push([tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone()]);
          }
          if (uvs2 !== undefined) {
            scope.faceVertexUvs[1].push([tempUVs2[a].clone(), tempUVs2[b].clone(), tempUVs2[c].clone()]);
          }
        }
        ;
        if (indices !== undefined) {
          var groups = geometry.groups;
          if (groups.length > 0) {
            for (var i = 0; i < groups.length; i++) {
              var group = groups[i];
              var start = group.start;
              var count = group.count;
              for (var j = start,
                  jl = start + count; j < jl; j += 3) {
                addFace(indices[j], indices[j + 1], indices[j + 2]);
              }
            }
          } else {
            for (var i = 0; i < indices.length; i += 3) {
              addFace(indices[i], indices[i + 1], indices[i + 2]);
            }
          }
        } else {
          for (var i = 0; i < vertices.length / 3; i += 3) {
            addFace(i, i + 1, i + 2);
          }
        }
        this.computeFaceNormals();
        if (geometry.boundingBox !== null) {
          this.boundingBox = geometry.boundingBox.clone();
        }
        if (geometry.boundingSphere !== null) {
          this.boundingSphere = geometry.boundingSphere.clone();
        }
        return this;
      },
      center: function() {
        this.computeBoundingBox();
        var offset = this.boundingBox.center().negate();
        this.translate(offset.x, offset.y, offset.z);
        return offset;
      },
      normalize: function() {
        this.computeBoundingSphere();
        var center = this.boundingSphere.center;
        var radius = this.boundingSphere.radius;
        var s = radius === 0 ? 1 : 1.0 / radius;
        var matrix = new THREE.Matrix4();
        matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
        this.applyMatrix(matrix);
        return this;
      },
      computeFaceNormals: function() {
        var cb = new THREE.Vector3(),
            ab = new THREE.Vector3();
        for (var f = 0,
            fl = this.faces.length; f < fl; f++) {
          var face = this.faces[f];
          var vA = this.vertices[face.a];
          var vB = this.vertices[face.b];
          var vC = this.vertices[face.c];
          cb.subVectors(vC, vB);
          ab.subVectors(vA, vB);
          cb.cross(ab);
          cb.normalize();
          face.normal.copy(cb);
        }
      },
      computeVertexNormals: function(areaWeighted) {
        var v,
            vl,
            f,
            fl,
            face,
            vertices;
        vertices = new Array(this.vertices.length);
        for (v = 0, vl = this.vertices.length; v < vl; v++) {
          vertices[v] = new THREE.Vector3();
        }
        if (areaWeighted) {
          var vA,
              vB,
              vC;
          var cb = new THREE.Vector3(),
              ab = new THREE.Vector3();
          for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            vA = this.vertices[face.a];
            vB = this.vertices[face.b];
            vC = this.vertices[face.c];
            cb.subVectors(vC, vB);
            ab.subVectors(vA, vB);
            cb.cross(ab);
            vertices[face.a].add(cb);
            vertices[face.b].add(cb);
            vertices[face.c].add(cb);
          }
        } else {
          for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            vertices[face.a].add(face.normal);
            vertices[face.b].add(face.normal);
            vertices[face.c].add(face.normal);
          }
        }
        for (v = 0, vl = this.vertices.length; v < vl; v++) {
          vertices[v].normalize();
        }
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          var vertexNormals = face.vertexNormals;
          if (vertexNormals.length === 3) {
            vertexNormals[0].copy(vertices[face.a]);
            vertexNormals[1].copy(vertices[face.b]);
            vertexNormals[2].copy(vertices[face.c]);
          } else {
            vertexNormals[0] = vertices[face.a].clone();
            vertexNormals[1] = vertices[face.b].clone();
            vertexNormals[2] = vertices[face.c].clone();
          }
        }
      },
      computeMorphNormals: function() {
        var i,
            il,
            f,
            fl,
            face;
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          if (!face.__originalFaceNormal) {
            face.__originalFaceNormal = face.normal.clone();
          } else {
            face.__originalFaceNormal.copy(face.normal);
          }
          if (!face.__originalVertexNormals)
            face.__originalVertexNormals = [];
          for (i = 0, il = face.vertexNormals.length; i < il; i++) {
            if (!face.__originalVertexNormals[i]) {
              face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
            } else {
              face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
            }
          }
        }
        var tmpGeo = new THREE.Geometry();
        tmpGeo.faces = this.faces;
        for (i = 0, il = this.morphTargets.length; i < il; i++) {
          if (!this.morphNormals[i]) {
            this.morphNormals[i] = {};
            this.morphNormals[i].faceNormals = [];
            this.morphNormals[i].vertexNormals = [];
            var dstNormalsFace = this.morphNormals[i].faceNormals;
            var dstNormalsVertex = this.morphNormals[i].vertexNormals;
            var faceNormal,
                vertexNormals;
            for (f = 0, fl = this.faces.length; f < fl; f++) {
              faceNormal = new THREE.Vector3();
              vertexNormals = {
                a: new THREE.Vector3(),
                b: new THREE.Vector3(),
                c: new THREE.Vector3()
              };
              dstNormalsFace.push(faceNormal);
              dstNormalsVertex.push(vertexNormals);
            }
          }
          var morphNormals = this.morphNormals[i];
          tmpGeo.vertices = this.morphTargets[i].vertices;
          tmpGeo.computeFaceNormals();
          tmpGeo.computeVertexNormals();
          var faceNormal,
              vertexNormals;
          for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            faceNormal = morphNormals.faceNormals[f];
            vertexNormals = morphNormals.vertexNormals[f];
            faceNormal.copy(face.normal);
            vertexNormals.a.copy(face.vertexNormals[0]);
            vertexNormals.b.copy(face.vertexNormals[1]);
            vertexNormals.c.copy(face.vertexNormals[2]);
          }
        }
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          face.normal = face.__originalFaceNormal;
          face.vertexNormals = face.__originalVertexNormals;
        }
      },
      computeTangents: function() {
        console.warn('THREE.Geometry: .computeTangents() has been removed.');
      },
      computeLineDistances: function() {
        var d = 0;
        var vertices = this.vertices;
        for (var i = 0,
            il = vertices.length; i < il; i++) {
          if (i > 0) {
            d += vertices[i].distanceTo(vertices[i - 1]);
          }
          this.lineDistances[i] = d;
        }
      },
      computeBoundingBox: function() {
        if (this.boundingBox === null) {
          this.boundingBox = new THREE.Box3();
        }
        this.boundingBox.setFromPoints(this.vertices);
      },
      computeBoundingSphere: function() {
        if (this.boundingSphere === null) {
          this.boundingSphere = new THREE.Sphere();
        }
        this.boundingSphere.setFromPoints(this.vertices);
      },
      merge: function(geometry, matrix, materialIndexOffset) {
        if (geometry instanceof THREE.Geometry === false) {
          console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
          return;
        }
        var normalMatrix,
            vertexOffset = this.vertices.length,
            vertices1 = this.vertices,
            vertices2 = geometry.vertices,
            faces1 = this.faces,
            faces2 = geometry.faces,
            uvs1 = this.faceVertexUvs[0],
            uvs2 = geometry.faceVertexUvs[0];
        if (materialIndexOffset === undefined)
          materialIndexOffset = 0;
        if (matrix !== undefined) {
          normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
        }
        for (var i = 0,
            il = vertices2.length; i < il; i++) {
          var vertex = vertices2[i];
          var vertexCopy = vertex.clone();
          if (matrix !== undefined)
            vertexCopy.applyMatrix4(matrix);
          vertices1.push(vertexCopy);
        }
        for (i = 0, il = faces2.length; i < il; i++) {
          var face = faces2[i],
              faceCopy,
              normal,
              color,
              faceVertexNormals = face.vertexNormals,
              faceVertexColors = face.vertexColors;
          faceCopy = new THREE.Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
          faceCopy.normal.copy(face.normal);
          if (normalMatrix !== undefined) {
            faceCopy.normal.applyMatrix3(normalMatrix).normalize();
          }
          for (var j = 0,
              jl = faceVertexNormals.length; j < jl; j++) {
            normal = faceVertexNormals[j].clone();
            if (normalMatrix !== undefined) {
              normal.applyMatrix3(normalMatrix).normalize();
            }
            faceCopy.vertexNormals.push(normal);
          }
          faceCopy.color.copy(face.color);
          for (var j = 0,
              jl = faceVertexColors.length; j < jl; j++) {
            color = faceVertexColors[j];
            faceCopy.vertexColors.push(color.clone());
          }
          faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
          faces1.push(faceCopy);
        }
        for (i = 0, il = uvs2.length; i < il; i++) {
          var uv = uvs2[i],
              uvCopy = [];
          if (uv === undefined) {
            continue;
          }
          for (var j = 0,
              jl = uv.length; j < jl; j++) {
            uvCopy.push(uv[j].clone());
          }
          uvs1.push(uvCopy);
        }
      },
      mergeMesh: function(mesh) {
        if (mesh instanceof THREE.Mesh === false) {
          console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
          return;
        }
        mesh.matrixAutoUpdate && mesh.updateMatrix();
        this.merge(mesh.geometry, mesh.matrix);
      },
      mergeVertices: function() {
        var verticesMap = {};
        var unique = [],
            changes = [];
        var v,
            key;
        var precisionPoints = 4;
        var precision = Math.pow(10, precisionPoints);
        var i,
            il,
            face;
        var indices,
            j,
            jl;
        for (i = 0, il = this.vertices.length; i < il; i++) {
          v = this.vertices[i];
          key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);
          if (verticesMap[key] === undefined) {
            verticesMap[key] = i;
            unique.push(this.vertices[i]);
            changes[i] = unique.length - 1;
          } else {
            changes[i] = changes[verticesMap[key]];
          }
        }
        var faceIndicesToRemove = [];
        for (i = 0, il = this.faces.length; i < il; i++) {
          face = this.faces[i];
          face.a = changes[face.a];
          face.b = changes[face.b];
          face.c = changes[face.c];
          indices = [face.a, face.b, face.c];
          var dupIndex = -1;
          for (var n = 0; n < 3; n++) {
            if (indices[n] === indices[(n + 1) % 3]) {
              dupIndex = n;
              faceIndicesToRemove.push(i);
              break;
            }
          }
        }
        for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
          var idx = faceIndicesToRemove[i];
          this.faces.splice(idx, 1);
          for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
            this.faceVertexUvs[j].splice(idx, 1);
          }
        }
        var diff = this.vertices.length - unique.length;
        this.vertices = unique;
        return diff;
      },
      sortFacesByMaterialIndex: function() {
        var faces = this.faces;
        var length = faces.length;
        for (var i = 0; i < length; i++) {
          faces[i]._id = i;
        }
        function materialIndexSort(a, b) {
          return a.materialIndex - b.materialIndex;
        }
        faces.sort(materialIndexSort);
        var uvs1 = this.faceVertexUvs[0];
        var uvs2 = this.faceVertexUvs[1];
        var newUvs1,
            newUvs2;
        if (uvs1 && uvs1.length === length)
          newUvs1 = [];
        if (uvs2 && uvs2.length === length)
          newUvs2 = [];
        for (var i = 0; i < length; i++) {
          var id = faces[i]._id;
          if (newUvs1)
            newUvs1.push(uvs1[id]);
          if (newUvs2)
            newUvs2.push(uvs2[id]);
        }
        if (newUvs1)
          this.faceVertexUvs[0] = newUvs1;
        if (newUvs2)
          this.faceVertexUvs[1] = newUvs2;
      },
      toJSON: function() {
        var data = {metadata: {
            version: 4.4,
            type: 'Geometry',
            generator: 'Geometry.toJSON'
          }};
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '')
          data.name = this.name;
        if (this.parameters !== undefined) {
          var parameters = this.parameters;
          for (var key in parameters) {
            if (parameters[key] !== undefined)
              data[key] = parameters[key];
          }
          return data;
        }
        var vertices = [];
        for (var i = 0; i < this.vertices.length; i++) {
          var vertex = this.vertices[i];
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
        var faces = [];
        var normals = [];
        var normalsHash = {};
        var colors = [];
        var colorsHash = {};
        var uvs = [];
        var uvsHash = {};
        for (var i = 0; i < this.faces.length; i++) {
          var face = this.faces[i];
          var hasMaterial = false;
          var hasFaceUv = false;
          var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
          var hasFaceNormal = face.normal.length() > 0;
          var hasFaceVertexNormal = face.vertexNormals.length > 0;
          var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
          var hasFaceVertexColor = face.vertexColors.length > 0;
          var faceType = 0;
          faceType = setBit(faceType, 0, 0);
          faceType = setBit(faceType, 1, hasMaterial);
          faceType = setBit(faceType, 2, hasFaceUv);
          faceType = setBit(faceType, 3, hasFaceVertexUv);
          faceType = setBit(faceType, 4, hasFaceNormal);
          faceType = setBit(faceType, 5, hasFaceVertexNormal);
          faceType = setBit(faceType, 6, hasFaceColor);
          faceType = setBit(faceType, 7, hasFaceVertexColor);
          faces.push(faceType);
          faces.push(face.a, face.b, face.c);
          if (hasFaceVertexUv) {
            var faceVertexUvs = this.faceVertexUvs[0][i];
            faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
          }
          if (hasFaceNormal) {
            faces.push(getNormalIndex(face.normal));
          }
          if (hasFaceVertexNormal) {
            var vertexNormals = face.vertexNormals;
            faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
          }
          if (hasFaceColor) {
            faces.push(getColorIndex(face.color));
          }
          if (hasFaceVertexColor) {
            var vertexColors = face.vertexColors;
            faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
          }
        }
        function setBit(value, position, enabled) {
          return enabled ? value | (1 << position) : value & (~(1 << position));
        }
        function getNormalIndex(normal) {
          var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
          if (normalsHash[hash] !== undefined) {
            return normalsHash[hash];
          }
          normalsHash[hash] = normals.length / 3;
          normals.push(normal.x, normal.y, normal.z);
          return normalsHash[hash];
        }
        function getColorIndex(color) {
          var hash = color.r.toString() + color.g.toString() + color.b.toString();
          if (colorsHash[hash] !== undefined) {
            return colorsHash[hash];
          }
          colorsHash[hash] = colors.length;
          colors.push(color.getHex());
          return colorsHash[hash];
        }
        function getUvIndex(uv) {
          var hash = uv.x.toString() + uv.y.toString();
          if (uvsHash[hash] !== undefined) {
            return uvsHash[hash];
          }
          uvsHash[hash] = uvs.length / 2;
          uvs.push(uv.x, uv.y);
          return uvsHash[hash];
        }
        data.data = {};
        data.data.vertices = vertices;
        data.data.normals = normals;
        if (colors.length > 0)
          data.data.colors = colors;
        if (uvs.length > 0)
          data.data.uvs = [uvs];
        data.data.faces = faces;
        return data;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(source) {
        this.vertices = [];
        this.faces = [];
        this.faceVertexUvs = [[]];
        var vertices = source.vertices;
        for (var i = 0,
            il = vertices.length; i < il; i++) {
          this.vertices.push(vertices[i].clone());
        }
        var faces = source.faces;
        for (var i = 0,
            il = faces.length; i < il; i++) {
          this.faces.push(faces[i].clone());
        }
        for (var i = 0,
            il = source.faceVertexUvs.length; i < il; i++) {
          var faceVertexUvs = source.faceVertexUvs[i];
          if (this.faceVertexUvs[i] === undefined) {
            this.faceVertexUvs[i] = [];
          }
          for (var j = 0,
              jl = faceVertexUvs.length; j < jl; j++) {
            var uvs = faceVertexUvs[j],
                uvsCopy = [];
            for (var k = 0,
                kl = uvs.length; k < kl; k++) {
              var uv = uvs[k];
              uvsCopy.push(uv.clone());
            }
            this.faceVertexUvs[i].push(uvsCopy);
          }
        }
        return this;
      },
      dispose: function() {
        this.dispatchEvent({type: 'dispose'});
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);
    THREE.GeometryIdCount = 0;
    THREE.DirectGeometry = function() {
      Object.defineProperty(this, 'id', {value: THREE.GeometryIdCount++});
      this.uuid = THREE.Math.generateUUID();
      this.name = '';
      this.type = 'DirectGeometry';
      this.indices = [];
      this.vertices = [];
      this.normals = [];
      this.colors = [];
      this.uvs = [];
      this.uvs2 = [];
      this.groups = [];
      this.morphTargets = {};
      this.skinWeights = [];
      this.skinIndices = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.verticesNeedUpdate = false;
      this.normalsNeedUpdate = false;
      this.colorsNeedUpdate = false;
      this.uvsNeedUpdate = false;
      this.groupsNeedUpdate = false;
    };
    THREE.DirectGeometry.prototype = {
      constructor: THREE.DirectGeometry,
      computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
      computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,
      computeFaceNormals: function() {
        console.warn('THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.');
      },
      computeVertexNormals: function() {
        console.warn('THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.');
      },
      computeGroups: function(geometry) {
        var group;
        var groups = [];
        var materialIndex;
        var faces = geometry.faces;
        for (var i = 0; i < faces.length; i++) {
          var face = faces[i];
          if (face.materialIndex !== materialIndex) {
            materialIndex = face.materialIndex;
            if (group !== undefined) {
              group.count = (i * 3) - group.start;
              groups.push(group);
            }
            group = {
              start: i * 3,
              materialIndex: materialIndex
            };
          }
        }
        if (group !== undefined) {
          group.count = (i * 3) - group.start;
          groups.push(group);
        }
        this.groups = groups;
      },
      fromGeometry: function(geometry) {
        var faces = geometry.faces;
        var vertices = geometry.vertices;
        var faceVertexUvs = geometry.faceVertexUvs;
        var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
        var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
        var morphTargets = geometry.morphTargets;
        var morphTargetsLength = morphTargets.length;
        if (morphTargetsLength > 0) {
          var morphTargetsPosition = [];
          for (var i = 0; i < morphTargetsLength; i++) {
            morphTargetsPosition[i] = [];
          }
          this.morphTargets.position = morphTargetsPosition;
        }
        var morphNormals = geometry.morphNormals;
        var morphNormalsLength = morphNormals.length;
        if (morphNormalsLength > 0) {
          var morphTargetsNormal = [];
          for (var i = 0; i < morphNormalsLength; i++) {
            morphTargetsNormal[i] = [];
          }
          this.morphTargets.normal = morphTargetsNormal;
        }
        var skinIndices = geometry.skinIndices;
        var skinWeights = geometry.skinWeights;
        var hasSkinIndices = skinIndices.length === vertices.length;
        var hasSkinWeights = skinWeights.length === vertices.length;
        for (var i = 0; i < faces.length; i++) {
          var face = faces[i];
          this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
          var vertexNormals = face.vertexNormals;
          if (vertexNormals.length === 3) {
            this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
          } else {
            var normal = face.normal;
            this.normals.push(normal, normal, normal);
          }
          var vertexColors = face.vertexColors;
          if (vertexColors.length === 3) {
            this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
          } else {
            var color = face.color;
            this.colors.push(color, color, color);
          }
          if (hasFaceVertexUv === true) {
            var vertexUvs = faceVertexUvs[0][i];
            if (vertexUvs !== undefined) {
              this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
            } else {
              console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);
              this.uvs.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2());
            }
          }
          if (hasFaceVertexUv2 === true) {
            var vertexUvs = faceVertexUvs[1][i];
            if (vertexUvs !== undefined) {
              this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
            } else {
              console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);
              this.uvs2.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2());
            }
          }
          for (var j = 0; j < morphTargetsLength; j++) {
            var morphTarget = morphTargets[j].vertices;
            morphTargetsPosition[j].push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
          }
          for (var j = 0; j < morphNormalsLength; j++) {
            var morphNormal = morphNormals[j].vertexNormals[i];
            morphTargetsNormal[j].push(morphNormal.a, morphNormal.b, morphNormal.c);
          }
          if (hasSkinIndices) {
            this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
          }
          if (hasSkinWeights) {
            this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
          }
        }
        this.computeGroups(geometry);
        this.verticesNeedUpdate = geometry.verticesNeedUpdate;
        this.normalsNeedUpdate = geometry.normalsNeedUpdate;
        this.colorsNeedUpdate = geometry.colorsNeedUpdate;
        this.uvsNeedUpdate = geometry.uvsNeedUpdate;
        this.groupsNeedUpdate = geometry.groupsNeedUpdate;
        return this;
      },
      dispose: function() {
        this.dispatchEvent({type: 'dispose'});
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.DirectGeometry.prototype);
    THREE.BufferGeometry = function() {
      Object.defineProperty(this, 'id', {value: THREE.GeometryIdCount++});
      this.uuid = THREE.Math.generateUUID();
      this.name = '';
      this.type = 'BufferGeometry';
      this.index = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.drawRange = {
        start: 0,
        count: Infinity
      };
    };
    THREE.BufferGeometry.prototype = {
      constructor: THREE.BufferGeometry,
      addIndex: function(index) {
        console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
        this.setIndex(index);
      },
      getIndex: function() {
        return this.index;
      },
      setIndex: function(index) {
        this.index = index;
      },
      addAttribute: function(name, attribute) {
        if (attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false) {
          console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
          this.addAttribute(name, new THREE.BufferAttribute(arguments[1], arguments[2]));
          return;
        }
        if (name === 'index') {
          console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
          this.setIndex(attribute);
          return;
        }
        this.attributes[name] = attribute;
      },
      getAttribute: function(name) {
        return this.attributes[name];
      },
      removeAttribute: function(name) {
        delete this.attributes[name];
      },
      get drawcalls() {
        console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
        return this.groups;
      },
      get offsets() {
        console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
        return this.groups;
      },
      addDrawCall: function(start, count, indexOffset) {
        if (indexOffset !== undefined) {
          console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
        }
        console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
        this.addGroup(start, count);
      },
      clearDrawCalls: function() {
        console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
        this.clearGroups();
      },
      addGroup: function(start, count, materialIndex) {
        this.groups.push({
          start: start,
          count: count,
          materialIndex: materialIndex !== undefined ? materialIndex : 0
        });
      },
      clearGroups: function() {
        this.groups = [];
      },
      setDrawRange: function(start, count) {
        this.drawRange.start = start;
        this.drawRange.count = count;
      },
      applyMatrix: function(matrix) {
        var position = this.attributes.position;
        if (position !== undefined) {
          matrix.applyToVector3Array(position.array);
          position.needsUpdate = true;
        }
        var normal = this.attributes.normal;
        if (normal !== undefined) {
          var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
          normalMatrix.applyToVector3Array(normal.array);
          normal.needsUpdate = true;
        }
        if (this.boundingBox !== null) {
          this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
          this.computeBoundingSphere();
        }
      },
      rotateX: function() {
        var m1;
        return function rotateX(angle) {
          if (m1 === undefined)
            m1 = new THREE.Matrix4();
          m1.makeRotationX(angle);
          this.applyMatrix(m1);
          return this;
        };
      }(),
      rotateY: function() {
        var m1;
        return function rotateY(angle) {
          if (m1 === undefined)
            m1 = new THREE.Matrix4();
          m1.makeRotationY(angle);
          this.applyMatrix(m1);
          return this;
        };
      }(),
      rotateZ: function() {
        var m1;
        return function rotateZ(angle) {
          if (m1 === undefined)
            m1 = new THREE.Matrix4();
          m1.makeRotationZ(angle);
          this.applyMatrix(m1);
          return this;
        };
      }(),
      translate: function() {
        var m1;
        return function translate(x, y, z) {
          if (m1 === undefined)
            m1 = new THREE.Matrix4();
          m1.makeTranslation(x, y, z);
          this.applyMatrix(m1);
          return this;
        };
      }(),
      scale: function() {
        var m1;
        return function scale(x, y, z) {
          if (m1 === undefined)
            m1 = new THREE.Matrix4();
          m1.makeScale(x, y, z);
          this.applyMatrix(m1);
          return this;
        };
      }(),
      lookAt: function() {
        var obj;
        return function lookAt(vector) {
          if (obj === undefined)
            obj = new THREE.Object3D();
          obj.lookAt(vector);
          obj.updateMatrix();
          this.applyMatrix(obj.matrix);
        };
      }(),
      center: function() {
        this.computeBoundingBox();
        var offset = this.boundingBox.center().negate();
        this.translate(offset.x, offset.y, offset.z);
        return offset;
      },
      setFromObject: function(object) {
        var geometry = object.geometry;
        if (object instanceof THREE.Points || object instanceof THREE.Line) {
          var positions = new THREE.Float32Attribute(geometry.vertices.length * 3, 3);
          var colors = new THREE.Float32Attribute(geometry.colors.length * 3, 3);
          this.addAttribute('position', positions.copyVector3sArray(geometry.vertices));
          this.addAttribute('color', colors.copyColorsArray(geometry.colors));
          if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
            var lineDistances = new THREE.Float32Attribute(geometry.lineDistances.length, 1);
            this.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
          }
          if (geometry.boundingSphere !== null) {
            this.boundingSphere = geometry.boundingSphere.clone();
          }
          if (geometry.boundingBox !== null) {
            this.boundingBox = geometry.boundingBox.clone();
          }
        } else if (object instanceof THREE.Mesh) {
          if (geometry instanceof THREE.Geometry) {
            this.fromGeometry(geometry);
          }
        }
        return this;
      },
      updateFromObject: function(object) {
        var geometry = object.geometry;
        if (object instanceof THREE.Mesh) {
          var direct = geometry.__directGeometry;
          if (direct === undefined) {
            return this.fromGeometry(geometry);
          }
          direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
          direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
          direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
          direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
          direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
          geometry.verticesNeedUpdate = false;
          geometry.normalsNeedUpdate = false;
          geometry.colorsNeedUpdate = false;
          geometry.uvsNeedUpdate = false;
          geometry.groupsNeedUpdate = false;
          geometry = direct;
        }
        if (geometry.verticesNeedUpdate === true) {
          var attribute = this.attributes.position;
          if (attribute !== undefined) {
            attribute.copyVector3sArray(geometry.vertices);
            attribute.needsUpdate = true;
          }
          geometry.verticesNeedUpdate = false;
        }
        if (geometry.normalsNeedUpdate === true) {
          var attribute = this.attributes.normal;
          if (attribute !== undefined) {
            attribute.copyVector3sArray(geometry.normals);
            attribute.needsUpdate = true;
          }
          geometry.normalsNeedUpdate = false;
        }
        if (geometry.colorsNeedUpdate === true) {
          var attribute = this.attributes.color;
          if (attribute !== undefined) {
            attribute.copyColorsArray(geometry.colors);
            attribute.needsUpdate = true;
          }
          geometry.colorsNeedUpdate = false;
        }
        if (geometry.uvsNeedUpdate) {
          var attribute = this.attributes.uv;
          if (attribute !== undefined) {
            attribute.copyVector2sArray(geometry.uvs);
            attribute.needsUpdate = true;
          }
          geometry.uvsNeedUpdate = false;
        }
        if (geometry.lineDistancesNeedUpdate) {
          var attribute = this.attributes.lineDistance;
          if (attribute !== undefined) {
            attribute.copyArray(geometry.lineDistances);
            attribute.needsUpdate = true;
          }
          geometry.lineDistancesNeedUpdate = false;
        }
        if (geometry.groupsNeedUpdate) {
          geometry.computeGroups(object.geometry);
          this.groups = geometry.groups;
          geometry.groupsNeedUpdate = false;
        }
        return this;
      },
      fromGeometry: function(geometry) {
        geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry(geometry);
        return this.fromDirectGeometry(geometry.__directGeometry);
      },
      fromDirectGeometry: function(geometry) {
        var positions = new Float32Array(geometry.vertices.length * 3);
        this.addAttribute('position', new THREE.BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
        if (geometry.normals.length > 0) {
          var normals = new Float32Array(geometry.normals.length * 3);
          this.addAttribute('normal', new THREE.BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
        }
        if (geometry.colors.length > 0) {
          var colors = new Float32Array(geometry.colors.length * 3);
          this.addAttribute('color', new THREE.BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
        }
        if (geometry.uvs.length > 0) {
          var uvs = new Float32Array(geometry.uvs.length * 2);
          this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
        }
        if (geometry.uvs2.length > 0) {
          var uvs2 = new Float32Array(geometry.uvs2.length * 2);
          this.addAttribute('uv2', new THREE.BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
        }
        if (geometry.indices.length > 0) {
          var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
          var indices = new TypeArray(geometry.indices.length * 3);
          this.setIndex(new THREE.BufferAttribute(indices, 1).copyIndicesArray(geometry.indices));
        }
        this.groups = geometry.groups;
        for (var name in geometry.morphTargets) {
          var array = [];
          var morphTargets = geometry.morphTargets[name];
          for (var i = 0,
              l = morphTargets.length; i < l; i++) {
            var morphTarget = morphTargets[i];
            var attribute = new THREE.Float32Attribute(morphTarget.length * 3, 3);
            array.push(attribute.copyVector3sArray(morphTarget));
          }
          this.morphAttributes[name] = array;
        }
        if (geometry.skinIndices.length > 0) {
          var skinIndices = new THREE.Float32Attribute(geometry.skinIndices.length * 4, 4);
          this.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
        }
        if (geometry.skinWeights.length > 0) {
          var skinWeights = new THREE.Float32Attribute(geometry.skinWeights.length * 4, 4);
          this.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
        }
        if (geometry.boundingSphere !== null) {
          this.boundingSphere = geometry.boundingSphere.clone();
        }
        if (geometry.boundingBox !== null) {
          this.boundingBox = geometry.boundingBox.clone();
        }
        return this;
      },
      computeBoundingBox: function() {
        var vector = new THREE.Vector3();
        return function() {
          if (this.boundingBox === null) {
            this.boundingBox = new THREE.Box3();
          }
          var positions = this.attributes.position.array;
          if (positions) {
            var bb = this.boundingBox;
            bb.makeEmpty();
            for (var i = 0,
                il = positions.length; i < il; i += 3) {
              vector.fromArray(positions, i);
              bb.expandByPoint(vector);
            }
          }
          if (positions === undefined || positions.length === 0) {
            this.boundingBox.min.set(0, 0, 0);
            this.boundingBox.max.set(0, 0, 0);
          }
          if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
            console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
          }
        };
      }(),
      computeBoundingSphere: function() {
        var box = new THREE.Box3();
        var vector = new THREE.Vector3();
        return function() {
          if (this.boundingSphere === null) {
            this.boundingSphere = new THREE.Sphere();
          }
          var positions = this.attributes.position.array;
          if (positions) {
            box.makeEmpty();
            var center = this.boundingSphere.center;
            for (var i = 0,
                il = positions.length; i < il; i += 3) {
              vector.fromArray(positions, i);
              box.expandByPoint(vector);
            }
            box.center(center);
            var maxRadiusSq = 0;
            for (var i = 0,
                il = positions.length; i < il; i += 3) {
              vector.fromArray(positions, i);
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
            }
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
            if (isNaN(this.boundingSphere.radius)) {
              console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
            }
          }
        };
      }(),
      computeFaceNormals: function() {},
      computeVertexNormals: function() {
        var index = this.index;
        var attributes = this.attributes;
        var groups = this.groups;
        if (attributes.position) {
          var positions = attributes.position.array;
          if (attributes.normal === undefined) {
            this.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(positions.length), 3));
          } else {
            var normals = attributes.normal.array;
            for (var i = 0,
                il = normals.length; i < il; i++) {
              normals[i] = 0;
            }
          }
          var normals = attributes.normal.array;
          var vA,
              vB,
              vC,
              pA = new THREE.Vector3(),
              pB = new THREE.Vector3(),
              pC = new THREE.Vector3(),
              cb = new THREE.Vector3(),
              ab = new THREE.Vector3();
          if (index) {
            var indices = index.array;
            if (groups.length === 0) {
              this.addGroup(0, indices.length);
            }
            for (var j = 0,
                jl = groups.length; j < jl; ++j) {
              var group = groups[j];
              var start = group.start;
              var count = group.count;
              for (var i = start,
                  il = start + count; i < il; i += 3) {
                vA = indices[i + 0] * 3;
                vB = indices[i + 1] * 3;
                vC = indices[i + 2] * 3;
                pA.fromArray(positions, vA);
                pB.fromArray(positions, vB);
                pC.fromArray(positions, vC);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                normals[vA] += cb.x;
                normals[vA + 1] += cb.y;
                normals[vA + 2] += cb.z;
                normals[vB] += cb.x;
                normals[vB + 1] += cb.y;
                normals[vB + 2] += cb.z;
                normals[vC] += cb.x;
                normals[vC + 1] += cb.y;
                normals[vC + 2] += cb.z;
              }
            }
          } else {
            for (var i = 0,
                il = positions.length; i < il; i += 9) {
              pA.fromArray(positions, i);
              pB.fromArray(positions, i + 3);
              pC.fromArray(positions, i + 6);
              cb.subVectors(pC, pB);
              ab.subVectors(pA, pB);
              cb.cross(ab);
              normals[i] = cb.x;
              normals[i + 1] = cb.y;
              normals[i + 2] = cb.z;
              normals[i + 3] = cb.x;
              normals[i + 4] = cb.y;
              normals[i + 5] = cb.z;
              normals[i + 6] = cb.x;
              normals[i + 7] = cb.y;
              normals[i + 8] = cb.z;
            }
          }
          this.normalizeNormals();
          attributes.normal.needsUpdate = true;
        }
      },
      computeTangents: function() {
        console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');
      },
      computeOffsets: function(size) {
        console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
      },
      merge: function(geometry, offset) {
        if (geometry instanceof THREE.BufferGeometry === false) {
          console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
          return;
        }
        if (offset === undefined)
          offset = 0;
        var attributes = this.attributes;
        for (var key in attributes) {
          if (geometry.attributes[key] === undefined)
            continue;
          var attribute1 = attributes[key];
          var attributeArray1 = attribute1.array;
          var attribute2 = geometry.attributes[key];
          var attributeArray2 = attribute2.array;
          var attributeSize = attribute2.itemSize;
          for (var i = 0,
              j = attributeSize * offset; i < attributeArray2.length; i++, j++) {
            attributeArray1[j] = attributeArray2[i];
          }
        }
        return this;
      },
      normalizeNormals: function() {
        var normals = this.attributes.normal.array;
        var x,
            y,
            z,
            n;
        for (var i = 0,
            il = normals.length; i < il; i += 3) {
          x = normals[i];
          y = normals[i + 1];
          z = normals[i + 2];
          n = 1.0 / Math.sqrt(x * x + y * y + z * z);
          normals[i] *= n;
          normals[i + 1] *= n;
          normals[i + 2] *= n;
        }
      },
      toJSON: function() {
        var data = {metadata: {
            version: 4.4,
            type: 'BufferGeometry',
            generator: 'BufferGeometry.toJSON'
          }};
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '')
          data.name = this.name;
        if (this.parameters !== undefined) {
          var parameters = this.parameters;
          for (var key in parameters) {
            if (parameters[key] !== undefined)
              data[key] = parameters[key];
          }
          return data;
        }
        data.data = {attributes: {}};
        var index = this.index;
        if (index !== null) {
          var array = Array.prototype.slice.call(index.array);
          data.data.index = {
            type: index.array.constructor.name,
            array: array
          };
        }
        var attributes = this.attributes;
        for (var key in attributes) {
          var attribute = attributes[key];
          var array = Array.prototype.slice.call(attribute.array);
          data.data.attributes[key] = {
            itemSize: attribute.itemSize,
            type: attribute.array.constructor.name,
            array: array
          };
        }
        var groups = this.groups;
        if (groups.length > 0) {
          data.data.groups = JSON.parse(JSON.stringify(groups));
        }
        var boundingSphere = this.boundingSphere;
        if (boundingSphere !== null) {
          data.data.boundingSphere = {
            center: boundingSphere.center.toArray(),
            radius: boundingSphere.radius
          };
        }
        return data;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(source) {
        var index = source.index;
        if (index !== null) {
          this.setIndex(index.clone());
        }
        var attributes = source.attributes;
        for (var name in attributes) {
          var attribute = attributes[name];
          this.addAttribute(name, attribute.clone());
        }
        var groups = source.groups;
        for (var i = 0,
            l = groups.length; i < l; i++) {
          var group = groups[i];
          this.addGroup(group.start, group.count);
        }
        return this;
      },
      dispose: function() {
        this.dispatchEvent({type: 'dispose'});
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);
    THREE.BufferGeometry.MaxIndex = 65535;
    THREE.InstancedBufferGeometry = function() {
      THREE.BufferGeometry.call(this);
      this.type = 'InstancedBufferGeometry';
      this.maxInstancedCount = undefined;
    };
    THREE.InstancedBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;
    THREE.InstancedBufferGeometry.prototype.addGroup = function(start, count, instances) {
      this.groups.push({
        start: start,
        count: count,
        instances: instances
      });
    };
    THREE.InstancedBufferGeometry.prototype.copy = function(source) {
      var index = source.index;
      if (index !== null) {
        this.setIndex(index.clone());
      }
      var attributes = source.attributes;
      for (var name in attributes) {
        var attribute = attributes[name];
        this.addAttribute(name, attribute.clone());
      }
      var groups = source.groups;
      for (var i = 0,
          l = groups.length; i < l; i++) {
        var group = groups[i];
        this.addGroup(group.start, group.count, group.instances);
      }
      return this;
    };
    THREE.EventDispatcher.prototype.apply(THREE.InstancedBufferGeometry.prototype);
    THREE.AnimationAction = function(clip, startTime, timeScale, weight, loop) {
      if (clip === undefined)
        throw new Error('clip is null');
      this.clip = clip;
      this.localRoot = null;
      this.startTime = startTime || 0;
      this.timeScale = timeScale || 1;
      this.weight = weight || 1;
      this.loop = loop || THREE.LoopRepeat;
      this.loopCount = 0;
      this.enabled = true;
      this.actionTime = -this.startTime;
      this.clipTime = 0;
      this.propertyBindings = [];
    };
    THREE.AnimationAction.prototype = {
      constructor: THREE.AnimationAction,
      setLocalRoot: function(localRoot) {
        this.localRoot = localRoot;
        return this;
      },
      updateTime: function(clipDeltaTime) {
        var previousClipTime = this.clipTime;
        var previousLoopCount = this.loopCount;
        var previousActionTime = this.actionTime;
        var duration = this.clip.duration;
        this.actionTime = this.actionTime + clipDeltaTime;
        if (this.loop === THREE.LoopOnce) {
          this.loopCount = 0;
          this.clipTime = Math.min(Math.max(this.actionTime, 0), duration);
          if (this.clipTime !== previousClipTime) {
            if (this.clipTime === duration) {
              this.mixer.dispatchEvent({
                type: 'finished',
                action: this,
                direction: 1
              });
            } else if (this.clipTime === 0) {
              this.mixer.dispatchEvent({
                type: 'finished',
                action: this,
                direction: -1
              });
            }
          }
          return this.clipTime;
        }
        this.loopCount = Math.floor(this.actionTime / duration);
        var newClipTime = this.actionTime - this.loopCount * duration;
        newClipTime = newClipTime % duration;
        if (this.loop == THREE.LoopPingPong) {
          if (Math.abs(this.loopCount % 2) === 1) {
            newClipTime = duration - newClipTime;
          }
        }
        this.clipTime = newClipTime;
        if (this.loopCount !== previousLoopCount) {
          this.mixer.dispatchEvent({
            type: 'loop',
            action: this,
            loopDelta: (this.loopCount - this.loopCount)
          });
        }
        return this.clipTime;
      },
      syncWith: function(action) {
        this.actionTime = action.actionTime;
        this.timeScale = action.timeScale;
        return this;
      },
      warpToDuration: function(duration) {
        this.timeScale = this.clip.duration / duration;
        return this;
      },
      init: function(time) {
        this.clipTime = time - this.startTime;
        return this;
      },
      update: function(clipDeltaTime) {
        this.updateTime(clipDeltaTime);
        var clipResults = this.clip.getAt(this.clipTime);
        return clipResults;
      },
      getTimeScaleAt: function(time) {
        if (this.timeScale.getAt) {
          return this.timeScale.getAt(time);
        }
        return this.timeScale;
      },
      getWeightAt: function(time) {
        if (this.weight.getAt) {
          return this.weight.getAt(time);
        }
        return this.weight;
      }
    };
    THREE.AnimationClip = function(name, duration, tracks) {
      this.name = name;
      this.tracks = tracks;
      this.duration = (duration !== undefined) ? duration : -1;
      if (this.duration < 0) {
        for (var i = 0; i < this.tracks.length; i++) {
          var track = this.tracks[i];
          this.duration = Math.max(track.keys[track.keys.length - 1].time);
        }
      }
      this.trim();
      this.optimize();
      this.results = [];
    };
    THREE.AnimationClip.prototype = {
      constructor: THREE.AnimationClip,
      getAt: function(clipTime) {
        clipTime = Math.max(0, Math.min(clipTime, this.duration));
        for (var i = 0; i < this.tracks.length; i++) {
          var track = this.tracks[i];
          this.results[i] = track.getAt(clipTime);
        }
        return this.results;
      },
      trim: function() {
        for (var i = 0; i < this.tracks.length; i++) {
          this.tracks[i].trim(0, this.duration);
        }
        return this;
      },
      optimize: function() {
        for (var i = 0; i < this.tracks.length; i++) {
          this.tracks[i].optimize();
        }
        return this;
      }
    };
    THREE.AnimationClip.CreateFromMorphTargetSequence = function(name, morphTargetSequence, fps) {
      var numMorphTargets = morphTargetSequence.length;
      var tracks = [];
      for (var i = 0; i < numMorphTargets; i++) {
        var keys = [];
        keys.push({
          time: (i + numMorphTargets - 1) % numMorphTargets,
          value: 0
        });
        keys.push({
          time: i,
          value: 1
        });
        keys.push({
          time: (i + 1) % numMorphTargets,
          value: 0
        });
        keys.sort(THREE.KeyframeTrack.keyComparer);
        if (keys[0].time === 0) {
          keys.push({
            time: numMorphTargets,
            value: keys[0].value
          });
        }
        tracks.push(new THREE.NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', keys).scale(1.0 / fps));
      }
      return new THREE.AnimationClip(name, -1, tracks);
    };
    THREE.AnimationClip.findByName = function(clipArray, name) {
      for (var i = 0; i < clipArray.length; i++) {
        if (clipArray[i].name === name) {
          return clipArray[i];
        }
      }
      return null;
    };
    THREE.AnimationClip.CreateClipsFromMorphTargetSequences = function(morphTargets, fps) {
      var animationToMorphTargets = {};
      var pattern = /^([\w-]*?)([\d]+)$/;
      for (var i = 0,
          il = morphTargets.length; i < il; i++) {
        var morphTarget = morphTargets[i];
        var parts = morphTarget.name.match(pattern);
        if (parts && parts.length > 1) {
          var name = parts[1];
          var animationMorphTargets = animationToMorphTargets[name];
          if (!animationMorphTargets) {
            animationToMorphTargets[name] = animationMorphTargets = [];
          }
          animationMorphTargets.push(morphTarget);
        }
      }
      var clips = [];
      for (var name in animationToMorphTargets) {
        clips.push(THREE.AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps));
      }
      return clips;
    };
    THREE.AnimationClip.parse = function(json) {
      var tracks = [];
      for (var i = 0; i < json.tracks.length; i++) {
        tracks.push(THREE.KeyframeTrack.parse(json.tracks[i]).scale(1.0 / json.fps));
      }
      return new THREE.AnimationClip(json.name, json.duration, tracks);
    };
    THREE.AnimationClip.parseAnimation = function(animation, bones, nodeName) {
      if (!animation) {
        console.error("  no animation in JSONLoader data");
        return null;
      }
      var convertTrack = function(trackName, animationKeys, propertyName, trackType, animationKeyToValueFunc) {
        var keys = [];
        for (var k = 0; k < animationKeys.length; k++) {
          var animationKey = animationKeys[k];
          if (animationKey[propertyName] !== undefined) {
            keys.push({
              time: animationKey.time,
              value: animationKeyToValueFunc(animationKey)
            });
          }
        }
        if (keys.length > 0) {
          return new trackType(trackName, keys);
        }
        return null;
      };
      var tracks = [];
      var clipName = animation.name || 'default';
      var duration = animation.length || -1;
      var fps = animation.fps || 30;
      var hierarchyTracks = animation.hierarchy || [];
      for (var h = 0; h < hierarchyTracks.length; h++) {
        var animationKeys = hierarchyTracks[h].keys;
        if (!animationKeys || animationKeys.length == 0) {
          continue;
        }
        if (animationKeys[0].morphTargets) {
          var morphTargetNames = {};
          for (var k = 0; k < animationKeys.length; k++) {
            if (animationKeys[k].morphTargets) {
              for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
                morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
              }
            }
          }
          for (var morphTargetName in morphTargetNames) {
            var keys = [];
            for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
              var animationKey = animationKeys[k];
              keys.push({
                time: animationKey.time,
                value: ((animationKey.morphTarget === morphTargetName) ? 1 : 0)
              });
            }
            tracks.push(new THREE.NumberKeyframeTrack(nodeName + '.morphTargetInfluence[' + morphTargetName + ']', keys));
          }
          duration = morphTargetNames.length * (fps || 1.0);
        } else {
          var boneName = nodeName + '.bones[' + bones[h].name + ']';
          var positionTrack = convertTrack(boneName + '.position', animationKeys, 'pos', THREE.VectorKeyframeTrack, function(animationKey) {
            return new THREE.Vector3().fromArray(animationKey.pos);
          });
          if (positionTrack)
            tracks.push(positionTrack);
          var quaternionTrack = convertTrack(boneName + '.quaternion', animationKeys, 'rot', THREE.QuaternionKeyframeTrack, function(animationKey) {
            if (animationKey.rot.slerp) {
              return animationKey.rot.clone();
            } else {
              return new THREE.Quaternion().fromArray(animationKey.rot);
            }
          });
          if (quaternionTrack)
            tracks.push(quaternionTrack);
          var scaleTrack = convertTrack(boneName + '.scale', animationKeys, 'scl', THREE.VectorKeyframeTrack, function(animationKey) {
            return new THREE.Vector3().fromArray(animationKey.scl);
          });
          if (scaleTrack)
            tracks.push(scaleTrack);
        }
      }
      if (tracks.length === 0) {
        return null;
      }
      var clip = new THREE.AnimationClip(clipName, duration, tracks);
      return clip;
    };
    THREE.AnimationMixer = function(root) {
      this.root = root;
      this.time = 0;
      this.timeScale = 1.0;
      this.actions = [];
      this.propertyBindingMap = {};
    };
    THREE.AnimationMixer.prototype = {
      constructor: THREE.AnimationMixer,
      addAction: function(action) {
        this.actions.push(action);
        action.init(this.time);
        action.mixer = this;
        var tracks = action.clip.tracks;
        var root = action.localRoot || this.root;
        for (var i = 0; i < tracks.length; i++) {
          var track = tracks[i];
          var propertyBindingKey = root.uuid + '-' + track.name;
          var propertyBinding = this.propertyBindingMap[propertyBindingKey];
          if (propertyBinding === undefined) {
            propertyBinding = new THREE.PropertyBinding(root, track.name);
            this.propertyBindingMap[propertyBindingKey] = propertyBinding;
          }
          action.propertyBindings.push(propertyBinding);
          propertyBinding.referenceCount += 1;
        }
      },
      removeAllActions: function() {
        for (var i = 0; i < this.actions.length; i++) {
          this.actions[i].mixer = null;
        }
        for (var properyBindingKey in this.propertyBindingMap) {
          this.propertyBindingMap[properyBindingKey].unbind();
        }
        this.actions = [];
        this.propertyBindingMap = {};
        return this;
      },
      removeAction: function(action) {
        var index = this.actions.indexOf(action);
        if (index !== -1) {
          this.actions.splice(index, 1);
          action.mixer = null;
        }
        var root = action.localRoot || this.root;
        var tracks = action.clip.tracks;
        for (var i = 0; i < tracks.length; i++) {
          var track = tracks[i];
          var propertyBindingKey = root.uuid + '-' + track.name;
          var propertyBinding = this.propertyBindingMap[propertyBindingKey];
          propertyBinding.referenceCount -= 1;
          if (propertyBinding.referenceCount <= 0) {
            propertyBinding.unbind();
            delete this.propertyBindingMap[propertyBindingKey];
          }
        }
        return this;
      },
      findActionByName: function(name) {
        for (var i = 0; i < this.actions.length; i++) {
          if (this.actions[i].name === name)
            return this.actions[i];
        }
        return null;
      },
      play: function(action, optionalFadeInDuration) {
        action.startTime = this.time;
        this.addAction(action);
        return this;
      },
      fadeOut: function(action, duration) {
        var keys = [];
        keys.push({
          time: this.time,
          value: 1
        });
        keys.push({
          time: this.time + duration,
          value: 0
        });
        action.weight = new THREE.NumberKeyframeTrack("weight", keys);
        return this;
      },
      fadeIn: function(action, duration) {
        var keys = [];
        keys.push({
          time: this.time,
          value: 0
        });
        keys.push({
          time: this.time + duration,
          value: 1
        });
        action.weight = new THREE.NumberKeyframeTrack("weight", keys);
        return this;
      },
      warp: function(action, startTimeScale, endTimeScale, duration) {
        var keys = [];
        keys.push({
          time: this.time,
          value: startTimeScale
        });
        keys.push({
          time: this.time + duration,
          value: endTimeScale
        });
        action.timeScale = new THREE.NumberKeyframeTrack("timeScale", keys);
        return this;
      },
      crossFade: function(fadeOutAction, fadeInAction, duration, warp) {
        this.fadeOut(fadeOutAction, duration);
        this.fadeIn(fadeInAction, duration);
        if (warp) {
          var startEndRatio = fadeOutAction.clip.duration / fadeInAction.clip.duration;
          var endStartRatio = 1.0 / startEndRatio;
          this.warp(fadeOutAction, 1.0, startEndRatio, duration);
          this.warp(fadeInAction, endStartRatio, 1.0, duration);
        }
        return this;
      },
      update: function(deltaTime) {
        var mixerDeltaTime = deltaTime * this.timeScale;
        this.time += mixerDeltaTime;
        for (var i = 0; i < this.actions.length; i++) {
          var action = this.actions[i];
          var weight = action.getWeightAt(this.time);
          var actionTimeScale = action.getTimeScaleAt(this.time);
          var actionDeltaTime = mixerDeltaTime * actionTimeScale;
          var actionResults = action.update(actionDeltaTime);
          if (action.weight <= 0 || !action.enabled)
            continue;
          for (var j = 0; j < actionResults.length; j++) {
            var name = action.clip.tracks[j].name;
            action.propertyBindings[j].accumulate(actionResults[j], weight);
          }
        }
        for (var propertyBindingKey in this.propertyBindingMap) {
          this.propertyBindingMap[propertyBindingKey].apply();
        }
        return this;
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.AnimationMixer.prototype);
    THREE.AnimationUtils = {
      getEqualsFunc: function(exemplarValue) {
        if (exemplarValue.equals) {
          return function equals_object(a, b) {
            return a.equals(b);
          };
        }
        return function equals_primitive(a, b) {
          return (a === b);
        };
      },
      clone: function(exemplarValue) {
        var typeName = typeof exemplarValue;
        if (typeName === "object") {
          if (exemplarValue.clone) {
            return exemplarValue.clone();
          }
          console.error("can not figure out how to copy exemplarValue", exemplarValue);
        }
        return exemplarValue;
      },
      lerp: function(a, b, alpha, interTrack) {
        var lerpFunc = THREE.AnimationUtils.getLerpFunc(a, interTrack);
        return lerpFunc(a, b, alpha);
      },
      lerp_object: function(a, b, alpha) {
        return a.lerp(b, alpha);
      },
      slerp_object: function(a, b, alpha) {
        return a.slerp(b, alpha);
      },
      lerp_number: function(a, b, alpha) {
        return a * (1 - alpha) + b * alpha;
      },
      lerp_boolean: function(a, b, alpha) {
        return (alpha < 0.5) ? a : b;
      },
      lerp_boolean_immediate: function(a, b, alpha) {
        return a;
      },
      lerp_string: function(a, b, alpha) {
        return (alpha < 0.5) ? a : b;
      },
      lerp_string_immediate: function(a, b, alpha) {
        return a;
      },
      getLerpFunc: function(exemplarValue, interTrack) {
        if (exemplarValue === undefined || exemplarValue === null)
          throw new Error("examplarValue is null");
        var typeName = typeof exemplarValue;
        switch (typeName) {
          case "object":
            if (exemplarValue.lerp) {
              return THREE.AnimationUtils.lerp_object;
            }
            if (exemplarValue.slerp) {
              return THREE.AnimationUtils.slerp_object;
            }
            break;
          case "number":
            return THREE.AnimationUtils.lerp_number;
          case "boolean":
            if (interTrack) {
              return THREE.AnimationUtils.lerp_boolean;
            } else {
              return THREE.AnimationUtils.lerp_boolean_immediate;
            }
          case "string":
            if (interTrack) {
              return THREE.AnimationUtils.lerp_string;
            } else {
              return THREE.AnimationUtils.lerp_string_immediate;
            }
        }
      }
    };
    THREE.KeyframeTrack = function(name, keys) {
      if (name === undefined)
        throw new Error("track name is undefined");
      if (keys === undefined || keys.length === 0)
        throw new Error("no keys in track named " + name);
      this.name = name;
      this.keys = keys;
      this.lastIndex = 0;
      this.validate();
      this.optimize();
    };
    THREE.KeyframeTrack.prototype = {
      constructor: THREE.KeyframeTrack,
      getAt: function(time) {
        while ((this.lastIndex < this.keys.length) && (time >= this.keys[this.lastIndex].time)) {
          this.lastIndex++;
        }
        ;
        while ((this.lastIndex > 0) && (time < this.keys[this.lastIndex - 1].time)) {
          this.lastIndex--;
        }
        if (this.lastIndex >= this.keys.length) {
          this.setResult(this.keys[this.keys.length - 1].value);
          return this.result;
        }
        if (this.lastIndex === 0) {
          this.setResult(this.keys[0].value);
          return this.result;
        }
        var prevKey = this.keys[this.lastIndex - 1];
        this.setResult(prevKey.value);
        if (prevKey.constantToNext) {
          return this.result;
        }
        var currentKey = this.keys[this.lastIndex];
        var alpha = (time - prevKey.time) / (currentKey.time - prevKey.time);
        this.result = this.lerpValues(this.result, currentKey.value, alpha);
        return this.result;
      },
      shift: function(timeOffset) {
        if (timeOffset !== 0.0) {
          for (var i = 0; i < this.keys.length; i++) {
            this.keys[i].time += timeOffset;
          }
        }
        return this;
      },
      scale: function(timeScale) {
        if (timeScale !== 1.0) {
          for (var i = 0; i < this.keys.length; i++) {
            this.keys[i].time *= timeScale;
          }
        }
        return this;
      },
      trim: function(startTime, endTime) {
        var firstKeysToRemove = 0;
        for (var i = 1; i < this.keys.length; i++) {
          if (this.keys[i] <= startTime) {
            firstKeysToRemove++;
          }
        }
        var lastKeysToRemove = 0;
        for (var i = this.keys.length - 2; i > 0; i++) {
          if (this.keys[i] >= endTime) {
            lastKeysToRemove++;
          } else {
            break;
          }
        }
        if ((firstKeysToRemove + lastKeysToRemove) > 0) {
          this.keys = this.keys.splice(firstKeysToRemove, this.keys.length - lastKeysToRemove - firstKeysToRemove);
          ;
        }
        return this;
      },
      validate: function() {
        var prevKey = null;
        if (this.keys.length === 0) {
          console.error("  track is empty, no keys", this);
          return;
        }
        for (var i = 0; i < this.keys.length; i++) {
          var currKey = this.keys[i];
          if (!currKey) {
            console.error("  key is null in track", this, i);
            return;
          }
          if ((typeof currKey.time) !== 'number' || isNaN(currKey.time)) {
            console.error("  key.time is not a valid number", this, i, currKey);
            return;
          }
          if (currKey.value === undefined || currKey.value === null) {
            console.error("  key.value is null in track", this, i, currKey);
            return;
          }
          if (prevKey && prevKey.time > currKey.time) {
            console.error("  key.time is less than previous key time, out of order keys", this, i, currKey, prevKey);
            return;
          }
          prevKey = currKey;
        }
        return this;
      },
      optimize: function() {
        var newKeys = [];
        var prevKey = this.keys[0];
        newKeys.push(prevKey);
        var equalsFunc = THREE.AnimationUtils.getEqualsFunc(prevKey.value);
        for (var i = 1; i < this.keys.length - 1; i++) {
          var currKey = this.keys[i];
          var nextKey = this.keys[i + 1];
          if ((prevKey.time === currKey.time)) {
            continue;
          }
          if (this.compareValues(prevKey.value, currKey.value) && this.compareValues(currKey.value, nextKey.value)) {
            continue;
          }
          prevKey.constantToNext = this.compareValues(prevKey.value, currKey.value);
          newKeys.push(currKey);
          prevKey = currKey;
        }
        newKeys.push(this.keys[this.keys.length - 1]);
        this.keys = newKeys;
        return this;
      }
    };
    THREE.KeyframeTrack.keyComparer = function keyComparator(key0, key1) {
      return key0.time - key1.time;
    };
    THREE.KeyframeTrack.parse = function(json) {
      if (json.type === undefined)
        throw new Error("track type undefined, can not parse");
      var trackType = THREE.KeyframeTrack.GetTrackTypeForTypeName(json.type);
      return trackType.parse(json);
    };
    THREE.KeyframeTrack.GetTrackTypeForTypeName = function(typeName) {
      switch (typeName.toLowerCase()) {
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
          return THREE.VectorKeyframeTrack;
        case "quaternion":
          return THREE.QuaternionKeyframeTrack;
        case "integer":
        case "scalar":
        case "double":
        case "float":
        case "number":
          return THREE.NumberKeyframeTrack;
        case "bool":
        case "boolean":
          return THREE.BooleanKeyframeTrack;
        case "string":
          return THREE.StringKeyframeTrack;
      }
      ;
      throw new Error("Unsupported typeName: " + typeName);
    };
    THREE.PropertyBinding = function(rootNode, trackName) {
      this.rootNode = rootNode;
      this.trackName = trackName;
      this.referenceCount = 0;
      this.originalValue = null;
      var parseResults = THREE.PropertyBinding.parseTrackName(trackName);
      this.directoryName = parseResults.directoryName;
      this.nodeName = parseResults.nodeName;
      this.objectName = parseResults.objectName;
      this.objectIndex = parseResults.objectIndex;
      this.propertyName = parseResults.propertyName;
      this.propertyIndex = parseResults.propertyIndex;
      this.node = THREE.PropertyBinding.findNode(rootNode, this.nodeName) || rootNode;
      this.cumulativeValue = null;
      this.cumulativeWeight = 0;
    };
    THREE.PropertyBinding.prototype = {
      constructor: THREE.PropertyBinding,
      reset: function() {
        this.cumulativeValue = null;
        this.cumulativeWeight = 0;
      },
      accumulate: function(value, weight) {
        if (!this.isBound)
          this.bind();
        if (this.cumulativeWeight === 0) {
          if (weight > 0) {
            if (this.cumulativeValue === null) {
              this.cumulativeValue = THREE.AnimationUtils.clone(value);
            }
            this.cumulativeWeight = weight;
          }
        } else {
          var lerpAlpha = weight / (this.cumulativeWeight + weight);
          this.cumulativeValue = this.lerpValue(this.cumulativeValue, value, lerpAlpha);
          this.cumulativeWeight += weight;
        }
      },
      unbind: function() {
        if (!this.isBound)
          return;
        this.setValue(this.originalValue);
        this.setValue = null;
        this.getValue = null;
        this.lerpValue = null;
        this.equalsValue = null;
        this.triggerDirty = null;
        this.isBound = false;
      },
      bind: function() {
        if (this.isBound)
          return;
        var targetObject = this.node;
        if (!targetObject) {
          console.error("  trying to update node for track: " + this.trackName + " but it wasn't found.");
          return;
        }
        if (this.objectName) {
          if (this.objectName === "materials") {
            if (!targetObject.material) {
              console.error('  can not bind to material as node does not have a material', this);
              return;
            }
            if (!targetObject.material.materials) {
              console.error('  can not bind to material.materials as node.material does not have a materials array', this);
              return;
            }
            targetObject = targetObject.material.materials;
          } else if (this.objectName === "bones") {
            if (!targetObject.skeleton) {
              console.error('  can not bind to bones as node does not have a skeleton', this);
              return;
            }
            targetObject = targetObject.skeleton.bones;
            for (var i = 0; i < targetObject.length; i++) {
              if (targetObject[i].name === this.objectIndex) {
                this.objectIndex = i;
                break;
              }
            }
          } else {
            if (targetObject[this.objectName] === undefined) {
              console.error('  can not bind to objectName of node, undefined', this);
              return;
            }
            targetObject = targetObject[this.objectName];
          }
          if (this.objectIndex !== undefined) {
            if (targetObject[this.objectIndex] === undefined) {
              console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject);
              return;
            }
            targetObject = targetObject[this.objectIndex];
          }
        }
        var nodeProperty = targetObject[this.propertyName];
        if (!nodeProperty) {
          console.error("  trying to update property for track: " + this.nodeName + '.' + this.propertyName + " but it wasn't found.", targetObject);
          return;
        }
        if (this.propertyIndex !== undefined) {
          if (this.propertyName === "morphTargetInfluences") {
            if (!targetObject.geometry) {
              console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry', this);
            }
            if (!targetObject.geometry.morphTargets) {
              console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this);
            }
            for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {
              if (targetObject.geometry.morphTargets[i].name === this.propertyIndex) {
                this.propertyIndex = i;
                break;
              }
            }
          }
          this.setValue = function setValue_propertyIndexed(value) {
            if (!this.equalsValue(nodeProperty[this.propertyIndex], value)) {
              nodeProperty[this.propertyIndex] = value;
              return true;
            }
            return false;
          };
          this.getValue = function getValue_propertyIndexed() {
            return nodeProperty[this.propertyIndex];
          };
        } else if (nodeProperty.copy) {
          this.setValue = function setValue_propertyObject(value) {
            if (!this.equalsValue(nodeProperty, value)) {
              nodeProperty.copy(value);
              return true;
            }
            return false;
          };
          this.getValue = function getValue_propertyObject() {
            return nodeProperty;
          };
        } else {
          this.setValue = function setValue_property(value) {
            if (!this.equalsValue(targetObject[this.propertyName], value)) {
              targetObject[this.propertyName] = value;
              return true;
            }
            return false;
          };
          this.getValue = function getValue_property() {
            return targetObject[this.propertyName];
          };
        }
        if (targetObject.needsUpdate !== undefined) {
          this.triggerDirty = function triggerDirty_needsUpdate() {
            this.node.needsUpdate = true;
          };
        } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
          this.triggerDirty = function triggerDirty_matrixWorldNeedsUpdate() {
            targetObject.matrixWorldNeedsUpdate = true;
          };
        }
        this.originalValue = this.getValue();
        this.equalsValue = THREE.AnimationUtils.getEqualsFunc(this.originalValue);
        this.lerpValue = THREE.AnimationUtils.getLerpFunc(this.originalValue, true);
        this.isBound = true;
      },
      apply: function() {
        if (!this.isBound)
          this.bind();
        if (this.cumulativeWeight > 0) {
          if (this.cumulativeWeight < 1) {
            var remainingWeight = 1 - this.cumulativeWeight;
            var lerpAlpha = remainingWeight / (this.cumulativeWeight + remainingWeight);
            this.cumulativeValue = this.lerpValue(this.cumulativeValue, this.originalValue, lerpAlpha);
          }
          var valueChanged = this.setValue(this.cumulativeValue);
          if (valueChanged && this.triggerDirty) {
            this.triggerDirty();
          }
          this.cumulativeValue = null;
          this.cumulativeWeight = 0;
        }
      }
    };
    THREE.PropertyBinding.parseTrackName = function(trackName) {
      var re = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_. ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/;
      var matches = re.exec(trackName);
      if (!matches) {
        throw new Error("cannot parse trackName at all: " + trackName);
      }
      if (matches.index === re.lastIndex) {
        re.lastIndex++;
      }
      var results = {
        directoryName: matches[1],
        nodeName: matches[3],
        objectName: matches[5],
        objectIndex: matches[7],
        propertyName: matches[9],
        propertyIndex: matches[11]
      };
      if (results.propertyName === null || results.propertyName.length === 0) {
        throw new Error("can not parse propertyName from trackName: " + trackName);
      }
      return results;
    };
    THREE.PropertyBinding.findNode = function(root, nodeName) {
      function searchSkeleton(skeleton) {
        for (var i = 0; i < skeleton.bones.length; i++) {
          var bone = skeleton.bones[i];
          if (bone.name === nodeName) {
            return bone;
          }
        }
        return null;
      }
      function searchNodeSubtree(children) {
        for (var i = 0; i < children.length; i++) {
          var childNode = children[i];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          var result = searchNodeSubtree(childNode.children);
          if (result)
            return result;
        }
        return null;
      }
      if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
        return root;
      }
      if (root.skeleton) {
        var bone = searchSkeleton(root.skeleton);
        if (bone) {
          return bone;
        }
      }
      if (root.children) {
        var subTreeNode = searchNodeSubtree(root.children);
        if (subTreeNode) {
          return subTreeNode;
        }
      }
      return null;
    };
    THREE.VectorKeyframeTrack = function(name, keys) {
      THREE.KeyframeTrack.call(this, name, keys);
      this.result = this.keys[0].value.clone();
    };
    THREE.VectorKeyframeTrack.prototype = Object.create(THREE.KeyframeTrack.prototype);
    THREE.VectorKeyframeTrack.prototype.constructor = THREE.VectorKeyframeTrack;
    THREE.VectorKeyframeTrack.prototype.setResult = function(value) {
      this.result.copy(value);
    };
    THREE.VectorKeyframeTrack.prototype.lerpValues = function(value0, value1, alpha) {
      return value0.lerp(value1, alpha);
    };
    THREE.VectorKeyframeTrack.prototype.compareValues = function(value0, value1) {
      return value0.equals(value1);
    };
    THREE.VectorKeyframeTrack.prototype.clone = function() {
      var clonedKeys = [];
      for (var i = 0; i < this.keys.length; i++) {
        var key = this.keys[i];
        clonedKeys.push({
          time: key.time,
          value: key.value.clone()
        });
      }
      return new THREE.VectorKeyframeTrack(this.name, clonedKeys);
    };
    THREE.VectorKeyframeTrack.parse = function(json) {
      var elementCount = json.keys[0].value.length;
      var valueType = THREE['Vector' + elementCount];
      var keys = [];
      for (var i = 0; i < json.keys.length; i++) {
        var jsonKey = json.keys[i];
        keys.push({
          value: new valueType().fromArray(jsonKey.value),
          time: jsonKey.time
        });
      }
      return new THREE.VectorKeyframeTrack(json.name, keys);
    };
    THREE.QuaternionKeyframeTrack = function(name, keys) {
      THREE.KeyframeTrack.call(this, name, keys);
      this.result = this.keys[0].value.clone();
    };
    THREE.QuaternionKeyframeTrack.prototype = Object.create(THREE.KeyframeTrack.prototype);
    THREE.QuaternionKeyframeTrack.prototype.constructor = THREE.QuaternionKeyframeTrack;
    THREE.QuaternionKeyframeTrack.prototype.setResult = function(value) {
      this.result.copy(value);
    };
    THREE.QuaternionKeyframeTrack.prototype.lerpValues = function(value0, value1, alpha) {
      return value0.slerp(value1, alpha);
    };
    THREE.QuaternionKeyframeTrack.prototype.compareValues = function(value0, value1) {
      return value0.equals(value1);
    };
    THREE.QuaternionKeyframeTrack.prototype.multiply = function(quat) {
      for (var i = 0; i < this.keys.length; i++) {
        this.keys[i].value.multiply(quat);
      }
      return this;
    };
    THREE.QuaternionKeyframeTrack.prototype.clone = function() {
      var clonedKeys = [];
      for (var i = 0; i < this.keys.length; i++) {
        var key = this.keys[i];
        clonedKeys.push({
          time: key.time,
          value: key.value.clone()
        });
      }
      return new THREE.QuaternionKeyframeTrack(this.name, clonedKeys);
    };
    THREE.QuaternionKeyframeTrack.parse = function(json) {
      var keys = [];
      for (var i = 0; i < json.keys.length; i++) {
        var jsonKey = json.keys[i];
        keys.push({
          value: new THREE.Quaternion().fromArray(jsonKey.value),
          time: jsonKey.time
        });
      }
      return new THREE.QuaternionKeyframeTrack(json.name, keys);
    };
    THREE.StringKeyframeTrack = function(name, keys) {
      THREE.KeyframeTrack.call(this, name, keys);
      this.result = this.keys[0].value;
    };
    THREE.StringKeyframeTrack.prototype = Object.create(THREE.KeyframeTrack.prototype);
    THREE.StringKeyframeTrack.prototype.constructor = THREE.StringKeyframeTrack;
    THREE.StringKeyframeTrack.prototype.setResult = function(value) {
      this.result = value;
    };
    THREE.StringKeyframeTrack.prototype.lerpValues = function(value0, value1, alpha) {
      return (alpha < 1.0) ? value0 : value1;
    };
    THREE.StringKeyframeTrack.prototype.compareValues = function(value0, value1) {
      return (value0 === value1);
    };
    THREE.StringKeyframeTrack.prototype.clone = function() {
      var clonedKeys = [];
      for (var i = 0; i < this.keys.length; i++) {
        var key = this.keys[i];
        clonedKeys.push({
          time: key.time,
          value: key.value
        });
      }
      return new THREE.StringKeyframeTrack(this.name, clonedKeys);
    };
    THREE.StringKeyframeTrack.parse = function(json) {
      return new THREE.StringKeyframeTrack(json.name, json.keys);
    };
    THREE.BooleanKeyframeTrack = function(name, keys) {
      THREE.KeyframeTrack.call(this, name, keys);
      this.result = this.keys[0].value;
    };
    THREE.BooleanKeyframeTrack.prototype = Object.create(THREE.KeyframeTrack.prototype);
    THREE.BooleanKeyframeTrack.prototype.constructor = THREE.BooleanKeyframeTrack;
    THREE.BooleanKeyframeTrack.prototype.setResult = function(value) {
      this.result = value;
    };
    THREE.BooleanKeyframeTrack.prototype.lerpValues = function(value0, value1, alpha) {
      return (alpha < 1.0) ? value0 : value1;
    };
    THREE.BooleanKeyframeTrack.prototype.compareValues = function(value0, value1) {
      return (value0 === value1);
    };
    THREE.BooleanKeyframeTrack.prototype.clone = function() {
      var clonedKeys = [];
      for (var i = 0; i < this.keys.length; i++) {
        var key = this.keys[i];
        clonedKeys.push({
          time: key.time,
          value: key.value
        });
      }
      return new THREE.BooleanKeyframeTrack(this.name, clonedKeys);
    };
    THREE.BooleanKeyframeTrack.parse = function(json) {
      return new THREE.BooleanKeyframeTrack(json.name, json.keys);
    };
    THREE.NumberKeyframeTrack = function(name, keys) {
      THREE.KeyframeTrack.call(this, name, keys);
      this.result = this.keys[0].value;
    };
    THREE.NumberKeyframeTrack.prototype = Object.create(THREE.KeyframeTrack.prototype);
    THREE.NumberKeyframeTrack.prototype.constructor = THREE.NumberKeyframeTrack;
    THREE.NumberKeyframeTrack.prototype.setResult = function(value) {
      this.result = value;
    };
    THREE.NumberKeyframeTrack.prototype.lerpValues = function(value0, value1, alpha) {
      return value0 * (1 - alpha) + value1 * alpha;
    };
    THREE.NumberKeyframeTrack.prototype.compareValues = function(value0, value1) {
      return (value0 === value1);
    };
    THREE.NumberKeyframeTrack.prototype.clone = function() {
      var clonedKeys = [];
      for (var i = 0; i < this.keys.length; i++) {
        var key = this.keys[i];
        clonedKeys.push({
          time: key.time,
          value: key.value
        });
      }
      return new THREE.NumberKeyframeTrack(this.name, clonedKeys);
    };
    THREE.NumberKeyframeTrack.parse = function(json) {
      return new THREE.NumberKeyframeTrack(json.name, json.keys);
    };
    THREE.Camera = function() {
      THREE.Object3D.call(this);
      this.type = 'Camera';
      this.matrixWorldInverse = new THREE.Matrix4();
      this.projectionMatrix = new THREE.Matrix4();
    };
    THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Camera.prototype.constructor = THREE.Camera;
    THREE.Camera.prototype.getWorldDirection = function() {
      var quaternion = new THREE.Quaternion();
      return function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        this.getWorldQuaternion(quaternion);
        return result.set(0, 0, -1).applyQuaternion(quaternion);
      };
    }();
    THREE.Camera.prototype.lookAt = function() {
      var m1 = new THREE.Matrix4();
      return function(vector) {
        m1.lookAt(this.position, vector, this.up);
        this.quaternion.setFromRotationMatrix(m1);
      };
    }();
    THREE.Camera.prototype.clone = function() {
      return new this.constructor().copy(this);
    };
    THREE.Camera.prototype.copy = function(source) {
      THREE.Object3D.prototype.copy.call(this, source);
      this.matrixWorldInverse.copy(source.matrixWorldInverse);
      this.projectionMatrix.copy(source.projectionMatrix);
      return this;
    };
    THREE.CubeCamera = function(near, far, cubeResolution) {
      THREE.Object3D.call(this);
      this.type = 'CubeCamera';
      var fov = 90,
          aspect = 1;
      var cameraPX = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraPX.up.set(0, -1, 0);
      cameraPX.lookAt(new THREE.Vector3(1, 0, 0));
      this.add(cameraPX);
      var cameraNX = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraNX.up.set(0, -1, 0);
      cameraNX.lookAt(new THREE.Vector3(-1, 0, 0));
      this.add(cameraNX);
      var cameraPY = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraPY.up.set(0, 0, 1);
      cameraPY.lookAt(new THREE.Vector3(0, 1, 0));
      this.add(cameraPY);
      var cameraNY = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraNY.up.set(0, 0, -1);
      cameraNY.lookAt(new THREE.Vector3(0, -1, 0));
      this.add(cameraNY);
      var cameraPZ = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraPZ.up.set(0, -1, 0);
      cameraPZ.lookAt(new THREE.Vector3(0, 0, 1));
      this.add(cameraPZ);
      var cameraNZ = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraNZ.up.set(0, -1, 0);
      cameraNZ.lookAt(new THREE.Vector3(0, 0, -1));
      this.add(cameraNZ);
      this.renderTarget = new THREE.WebGLRenderTargetCube(cubeResolution, cubeResolution, {
        format: THREE.RGBFormat,
        magFilter: THREE.LinearFilter,
        minFilter: THREE.LinearFilter
      });
      this.updateCubeMap = function(renderer, scene) {
        if (this.parent === null)
          this.updateMatrixWorld();
        var renderTarget = this.renderTarget;
        var generateMipmaps = renderTarget.texture.generateMipmaps;
        renderTarget.texture.generateMipmaps = false;
        renderTarget.activeCubeFace = 0;
        renderer.render(scene, cameraPX, renderTarget);
        renderTarget.activeCubeFace = 1;
        renderer.render(scene, cameraNX, renderTarget);
        renderTarget.activeCubeFace = 2;
        renderer.render(scene, cameraPY, renderTarget);
        renderTarget.activeCubeFace = 3;
        renderer.render(scene, cameraNY, renderTarget);
        renderTarget.activeCubeFace = 4;
        renderer.render(scene, cameraPZ, renderTarget);
        renderTarget.texture.generateMipmaps = generateMipmaps;
        renderTarget.activeCubeFace = 5;
        renderer.render(scene, cameraNZ, renderTarget);
        renderer.setRenderTarget(null);
      };
    };
    THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);
    THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;
    THREE.OrthographicCamera = function(left, right, top, bottom, near, far) {
      THREE.Camera.call(this);
      this.type = 'OrthographicCamera';
      this.zoom = 1;
      this.left = left;
      this.right = right;
      this.top = top;
      this.bottom = bottom;
      this.near = (near !== undefined) ? near : 0.1;
      this.far = (far !== undefined) ? far : 2000;
      this.updateProjectionMatrix();
    };
    THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);
    THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;
    THREE.OrthographicCamera.prototype.updateProjectionMatrix = function() {
      var dx = (this.right - this.left) / (2 * this.zoom);
      var dy = (this.top - this.bottom) / (2 * this.zoom);
      var cx = (this.right + this.left) / 2;
      var cy = (this.top + this.bottom) / 2;
      this.projectionMatrix.makeOrthographic(cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far);
    };
    THREE.OrthographicCamera.prototype.copy = function(source) {
      THREE.Camera.prototype.copy.call(this, source);
      this.left = source.left;
      this.right = source.right;
      this.top = source.top;
      this.bottom = source.bottom;
      this.near = source.near;
      this.far = source.far;
      this.zoom = source.zoom;
      return this;
    };
    THREE.OrthographicCamera.prototype.toJSON = function(meta) {
      var data = THREE.Object3D.prototype.toJSON.call(this, meta);
      data.object.zoom = this.zoom;
      data.object.left = this.left;
      data.object.right = this.right;
      data.object.top = this.top;
      data.object.bottom = this.bottom;
      data.object.near = this.near;
      data.object.far = this.far;
      return data;
    };
    THREE.PerspectiveCamera = function(fov, aspect, near, far) {
      THREE.Camera.call(this);
      this.type = 'PerspectiveCamera';
      this.zoom = 1;
      this.fov = fov !== undefined ? fov : 50;
      this.aspect = aspect !== undefined ? aspect : 1;
      this.near = near !== undefined ? near : 0.1;
      this.far = far !== undefined ? far : 2000;
      this.updateProjectionMatrix();
    };
    THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
    THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;
    THREE.PerspectiveCamera.prototype.setLens = function(focalLength, frameHeight) {
      if (frameHeight === undefined)
        frameHeight = 24;
      this.fov = 2 * THREE.Math.radToDeg(Math.atan(frameHeight / (focalLength * 2)));
      this.updateProjectionMatrix();
    };
    THREE.PerspectiveCamera.prototype.setViewOffset = function(fullWidth, fullHeight, x, y, width, height) {
      this.fullWidth = fullWidth;
      this.fullHeight = fullHeight;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.updateProjectionMatrix();
    };
    THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
      var fov = THREE.Math.radToDeg(2 * Math.atan(Math.tan(THREE.Math.degToRad(this.fov) * 0.5) / this.zoom));
      if (this.fullWidth) {
        var aspect = this.fullWidth / this.fullHeight;
        var top = Math.tan(THREE.Math.degToRad(fov * 0.5)) * this.near;
        var bottom = -top;
        var left = aspect * bottom;
        var right = aspect * top;
        var width = Math.abs(right - left);
        var height = Math.abs(top - bottom);
        this.projectionMatrix.makeFrustum(left + this.x * width / this.fullWidth, left + (this.x + this.width) * width / this.fullWidth, top - (this.y + this.height) * height / this.fullHeight, top - this.y * height / this.fullHeight, this.near, this.far);
      } else {
        this.projectionMatrix.makePerspective(fov, this.aspect, this.near, this.far);
      }
    };
    THREE.PerspectiveCamera.prototype.copy = function(source) {
      THREE.Camera.prototype.copy.call(this, source);
      this.fov = source.fov;
      this.aspect = source.aspect;
      this.near = source.near;
      this.far = source.far;
      this.zoom = source.zoom;
      return this;
    };
    THREE.PerspectiveCamera.prototype.toJSON = function(meta) {
      var data = THREE.Object3D.prototype.toJSON.call(this, meta);
      data.object.zoom = this.zoom;
      data.object.fov = this.fov;
      data.object.aspect = this.aspect;
      data.object.near = this.near;
      data.object.far = this.far;
      return data;
    };
    THREE.Light = function(color) {
      THREE.Object3D.call(this);
      this.type = 'Light';
      this.color = new THREE.Color(color);
      this.receiveShadow = undefined;
    };
    THREE.Light.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Light.prototype.constructor = THREE.Light;
    Object.defineProperties(THREE.Light.prototype, {
      onlyShadow: {set: function(value) {
          console.warn('THREE.Light: .onlyShadow has been removed.');
        }},
      shadowCameraFov: {set: function(value) {
          this.shadow.camera.fov = value;
        }},
      shadowCameraLeft: {set: function(value) {
          this.shadow.camera.left = value;
        }},
      shadowCameraRight: {set: function(value) {
          this.shadow.camera.right = value;
        }},
      shadowCameraTop: {set: function(value) {
          this.shadow.camera.top = value;
        }},
      shadowCameraBottom: {set: function(value) {
          this.shadow.camera.bottom = value;
        }},
      shadowCameraNear: {set: function(value) {
          this.shadow.camera.near = value;
        }},
      shadowCameraFar: {set: function(value) {
          this.shadow.camera.far = value;
        }},
      shadowCameraVisible: {set: function(value) {
          console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow ) instead.');
        }},
      shadowBias: {set: function(value) {
          this.shadow.bias = value;
        }},
      shadowDarkness: {set: function(value) {
          this.shadow.darkness = value;
        }},
      shadowMapWidth: {set: function(value) {
          this.shadow.mapSize.width = value;
        }},
      shadowMapHeight: {set: function(value) {
          this.shadow.mapSize.height = value;
        }}
    });
    THREE.Light.prototype.copy = function(source) {
      THREE.Object3D.prototype.copy.call(this, source);
      this.color.copy(source.color);
      return this;
    };
    THREE.Light.prototype.toJSON = function(meta) {
      var data = THREE.Object3D.prototype.toJSON.call(this, meta);
      data.object.color = this.color.getHex();
      if (this.groundColor !== undefined)
        data.object.groundColor = this.groundColor.getHex();
      if (this.intensity !== undefined)
        data.object.intensity = this.intensity;
      if (this.distance !== undefined)
        data.object.distance = this.distance;
      if (this.angle !== undefined)
        data.object.angle = this.angle;
      if (this.decay !== undefined)
        data.object.decay = this.decay;
      if (this.exponent !== undefined)
        data.object.exponent = this.exponent;
      return data;
    };
    THREE.LightShadow = function(camera) {
      this.camera = camera;
      this.bias = 0;
      this.darkness = 1;
      this.mapSize = new THREE.Vector2(512, 512);
      this.map = null;
      this.matrix = null;
    };
    THREE.LightShadow.prototype = {
      constructor: THREE.LightShadow,
      copy: function(source) {
        this.camera = source.camera.clone();
        this.bias = source.bias;
        this.darkness = source.darkness;
        this.mapSize.copy(source.mapSize);
      },
      clone: function() {
        return new this.constructor().copy(this);
      }
    };
    THREE.AmbientLight = function(color) {
      THREE.Light.call(this, color);
      this.type = 'AmbientLight';
      this.castShadow = undefined;
    };
    THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
    THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;
    THREE.DirectionalLight = function(color, intensity) {
      THREE.Light.call(this, color);
      this.type = 'DirectionalLight';
      this.position.set(0, 1, 0);
      this.updateMatrix();
      this.target = new THREE.Object3D();
      this.intensity = (intensity !== undefined) ? intensity : 1;
      this.shadow = new THREE.LightShadow(new THREE.OrthographicCamera(-500, 500, 500, -500, 50, 5000));
    };
    THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
    THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;
    THREE.DirectionalLight.prototype.copy = function(source) {
      THREE.Light.prototype.copy.call(this, source);
      this.intensity = source.intensity;
      this.target = source.target.clone();
      this.shadow = source.shadow.clone();
      return this;
    };
    THREE.HemisphereLight = function(skyColor, groundColor, intensity) {
      THREE.Light.call(this, skyColor);
      this.type = 'HemisphereLight';
      this.castShadow = undefined;
      this.position.set(0, 1, 0);
      this.updateMatrix();
      this.groundColor = new THREE.Color(groundColor);
      this.intensity = (intensity !== undefined) ? intensity : 1;
    };
    THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);
    THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;
    THREE.HemisphereLight.prototype.copy = function(source) {
      THREE.Light.prototype.copy.call(this, source);
      this.groundColor.copy(source.groundColor);
      this.intensity = source.intensity;
      return this;
    };
    THREE.PointLight = function(color, intensity, distance, decay) {
      THREE.Light.call(this, color);
      this.type = 'PointLight';
      this.intensity = (intensity !== undefined) ? intensity : 1;
      this.distance = (distance !== undefined) ? distance : 0;
      this.decay = (decay !== undefined) ? decay : 1;
      this.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(90, 1, 1, 500));
    };
    THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
    THREE.PointLight.prototype.constructor = THREE.PointLight;
    THREE.PointLight.prototype.copy = function(source) {
      THREE.Light.prototype.copy.call(this, source);
      this.intensity = source.intensity;
      this.distance = source.distance;
      this.decay = source.decay;
      this.shadow = source.shadow.clone();
      return this;
    };
    THREE.SpotLight = function(color, intensity, distance, angle, exponent, decay) {
      THREE.Light.call(this, color);
      this.type = 'SpotLight';
      this.position.set(0, 1, 0);
      this.updateMatrix();
      this.target = new THREE.Object3D();
      this.intensity = (intensity !== undefined) ? intensity : 1;
      this.distance = (distance !== undefined) ? distance : 0;
      this.angle = (angle !== undefined) ? angle : Math.PI / 3;
      this.exponent = (exponent !== undefined) ? exponent : 10;
      this.decay = (decay !== undefined) ? decay : 1;
      this.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(50, 1, 50, 5000));
    };
    THREE.SpotLight.prototype = Object.create(THREE.Light.prototype);
    THREE.SpotLight.prototype.constructor = THREE.SpotLight;
    THREE.SpotLight.prototype.copy = function(source) {
      THREE.Light.prototype.copy.call(this, source);
      this.intensity = source.intensity;
      this.distance = source.distance;
      this.angle = source.angle;
      this.exponent = source.exponent;
      this.decay = source.decay;
      this.target = source.target.clone();
      this.shadow = source.shadow.clone();
      return this;
    };
    THREE.Cache = {
      enabled: false,
      files: {},
      add: function(key, file) {
        if (this.enabled === false)
          return;
        this.files[key] = file;
      },
      get: function(key) {
        if (this.enabled === false)
          return;
        return this.files[key];
      },
      remove: function(key) {
        delete this.files[key];
      },
      clear: function() {
        this.files = {};
      }
    };
    THREE.Loader = function() {
      this.onLoadStart = function() {};
      this.onLoadProgress = function() {};
      this.onLoadComplete = function() {};
    };
    THREE.Loader.prototype = {
      constructor: THREE.Loader,
      crossOrigin: undefined,
      extractUrlBase: function(url) {
        var parts = url.split('/');
        if (parts.length === 1)
          return './';
        parts.pop();
        return parts.join('/') + '/';
      },
      initMaterials: function(materials, texturePath, crossOrigin) {
        var array = [];
        for (var i = 0; i < materials.length; ++i) {
          array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
        }
        return array;
      },
      createMaterial: (function() {
        var color,
            textureLoader,
            materialLoader;
        return function(m, texturePath, crossOrigin) {
          if (color === undefined)
            color = new THREE.Color();
          if (textureLoader === undefined)
            textureLoader = new THREE.TextureLoader();
          if (materialLoader === undefined)
            materialLoader = new THREE.MaterialLoader();
          var textures = {};
          function loadTexture(path, repeat, offset, wrap, anisotropy) {
            var fullPath = texturePath + path;
            var loader = THREE.Loader.Handlers.get(fullPath);
            var texture;
            if (loader !== null) {
              texture = loader.load(fullPath);
            } else {
              textureLoader.setCrossOrigin(crossOrigin);
              texture = textureLoader.load(fullPath);
            }
            if (repeat !== undefined) {
              texture.repeat.fromArray(repeat);
              if (repeat[0] !== 1)
                texture.wrapS = THREE.RepeatWrapping;
              if (repeat[1] !== 1)
                texture.wrapT = THREE.RepeatWrapping;
            }
            if (offset !== undefined) {
              texture.offset.fromArray(offset);
            }
            if (wrap !== undefined) {
              if (wrap[0] === 'repeat')
                texture.wrapS = THREE.RepeatWrapping;
              if (wrap[0] === 'mirror')
                texture.wrapS = THREE.MirroredRepeatWrapping;
              if (wrap[1] === 'repeat')
                texture.wrapT = THREE.RepeatWrapping;
              if (wrap[1] === 'mirror')
                texture.wrapT = THREE.MirroredRepeatWrapping;
            }
            if (anisotropy !== undefined) {
              texture.anisotropy = anisotropy;
            }
            var uuid = THREE.Math.generateUUID();
            textures[uuid] = texture;
            return uuid;
          }
          var json = {
            uuid: THREE.Math.generateUUID(),
            type: 'MeshLambertMaterial'
          };
          for (var name in m) {
            var value = m[name];
            switch (name) {
              case 'DbgColor':
                json.color = value;
                break;
              case 'DbgIndex':
              case 'opticalDensity':
              case 'illumination':
                break;
              case 'DbgName':
                json.name = value;
                break;
              case 'blending':
                json.blending = THREE[value];
                break;
              case 'colorDiffuse':
                json.color = color.fromArray(value).getHex();
                break;
              case 'colorSpecular':
                json.specular = color.fromArray(value).getHex();
                break;
              case 'colorEmissive':
                json.emissive = color.fromArray(value).getHex();
                break;
              case 'specularCoef':
                json.shininess = value;
                break;
              case 'shading':
                if (value.toLowerCase() === 'basic')
                  json.type = 'MeshBasicMaterial';
                if (value.toLowerCase() === 'phong')
                  json.type = 'MeshPhongMaterial';
                break;
              case 'mapDiffuse':
                json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
                break;
              case 'mapDiffuseRepeat':
              case 'mapDiffuseOffset':
              case 'mapDiffuseWrap':
              case 'mapDiffuseAnisotropy':
                break;
              case 'mapLight':
                json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
                break;
              case 'mapLightRepeat':
              case 'mapLightOffset':
              case 'mapLightWrap':
              case 'mapLightAnisotropy':
                break;
              case 'mapAO':
                json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
                break;
              case 'mapAORepeat':
              case 'mapAOOffset':
              case 'mapAOWrap':
              case 'mapAOAnisotropy':
                break;
              case 'mapBump':
                json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
                break;
              case 'mapBumpScale':
                json.bumpScale = value;
                break;
              case 'mapBumpRepeat':
              case 'mapBumpOffset':
              case 'mapBumpWrap':
              case 'mapBumpAnisotropy':
                break;
              case 'mapNormal':
                json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
                break;
              case 'mapNormalFactor':
                json.normalScale = [value, value];
                break;
              case 'mapNormalRepeat':
              case 'mapNormalOffset':
              case 'mapNormalWrap':
              case 'mapNormalAnisotropy':
                break;
              case 'mapSpecular':
                json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
                break;
              case 'mapSpecularRepeat':
              case 'mapSpecularOffset':
              case 'mapSpecularWrap':
              case 'mapSpecularAnisotropy':
                break;
              case 'mapAlpha':
                json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
                break;
              case 'mapAlphaRepeat':
              case 'mapAlphaOffset':
              case 'mapAlphaWrap':
              case 'mapAlphaAnisotropy':
                break;
              case 'flipSided':
                json.side = THREE.BackSide;
                break;
              case 'doubleSided':
                json.side = THREE.DoubleSide;
                break;
              case 'transparency':
                console.warn('THREE.Loader: transparency has been renamed to opacity');
                json.opacity = value;
                break;
              case 'opacity':
              case 'transparent':
              case 'depthTest':
              case 'depthWrite':
              case 'transparent':
              case 'visible':
              case 'wireframe':
                json[name] = value;
                break;
              case 'vertexColors':
                if (value === true)
                  json.vertexColors = THREE.VertexColors;
                if (value === 'face')
                  json.vertexColors = THREE.FaceColors;
                break;
              default:
                console.error('Loader.createMaterial: Unsupported', name, value);
                break;
            }
          }
          if (json.type !== 'MeshPhongMaterial')
            delete json.specular;
          if (json.opacity < 1)
            json.transparent = true;
          materialLoader.setTextures(textures);
          return materialLoader.parse(json);
        };
      })()
    };
    THREE.Loader.Handlers = {
      handlers: [],
      add: function(regex, loader) {
        this.handlers.push(regex, loader);
      },
      get: function(file) {
        var handlers = this.handlers;
        for (var i = 0,
            l = handlers.length; i < l; i += 2) {
          var regex = handlers[i];
          var loader = handlers[i + 1];
          if (regex.test(file)) {
            return loader;
          }
        }
        return null;
      }
    };
    THREE.XHRLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    };
    THREE.XHRLoader.prototype = {
      constructor: THREE.XHRLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var cached = THREE.Cache.get(url);
        if (cached !== undefined) {
          if (onLoad) {
            setTimeout(function() {
              onLoad(cached);
            }, 0);
          }
          return cached;
        }
        var request = new XMLHttpRequest();
        request.open('GET', url, true);
        request.addEventListener('load', function(event) {
          var response = event.target.response;
          THREE.Cache.add(url, response);
          if (onLoad)
            onLoad(response);
          scope.manager.itemEnd(url);
        }, false);
        if (onProgress !== undefined) {
          request.addEventListener('progress', function(event) {
            onProgress(event);
          }, false);
        }
        request.addEventListener('error', function(event) {
          if (onError)
            onError(event);
          scope.manager.itemError(url);
        }, false);
        if (this.crossOrigin !== undefined)
          request.crossOrigin = this.crossOrigin;
        if (this.responseType !== undefined)
          request.responseType = this.responseType;
        if (this.withCredentials !== undefined)
          request.withCredentials = this.withCredentials;
        request.send(null);
        scope.manager.itemStart(url);
        return request;
      },
      setResponseType: function(value) {
        this.responseType = value;
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      },
      setWithCredentials: function(value) {
        this.withCredentials = value;
      }
    };
    THREE.ImageLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    };
    THREE.ImageLoader.prototype = {
      constructor: THREE.ImageLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var cached = THREE.Cache.get(url);
        if (cached !== undefined) {
          scope.manager.itemStart(url);
          if (onLoad) {
            setTimeout(function() {
              onLoad(cached);
              scope.manager.itemEnd(url);
            }, 0);
          } else {
            scope.manager.itemEnd(url);
          }
          return cached;
        }
        var image = document.createElement('img');
        image.addEventListener('load', function(event) {
          THREE.Cache.add(url, this);
          if (onLoad)
            onLoad(this);
          scope.manager.itemEnd(url);
        }, false);
        if (onProgress !== undefined) {
          image.addEventListener('progress', function(event) {
            onProgress(event);
          }, false);
        }
        image.addEventListener('error', function(event) {
          if (onError)
            onError(event);
          scope.manager.itemError(url);
        }, false);
        if (this.crossOrigin !== undefined)
          image.crossOrigin = this.crossOrigin;
        scope.manager.itemStart(url);
        image.src = url;
        return image;
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      }
    };
    THREE.JSONLoader = function(manager) {
      if (typeof manager === 'boolean') {
        console.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.');
        manager = undefined;
      }
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
      this.withCredentials = false;
    };
    THREE.JSONLoader.prototype = {
      constructor: THREE.JSONLoader,
      get statusDomElement() {
        if (this._statusDomElement === undefined) {
          this._statusDomElement = document.createElement('div');
        }
        console.warn('THREE.JSONLoader: .statusDomElement has been removed.');
        return this._statusDomElement;
      },
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var texturePath = this.texturePath && (typeof this.texturePath === "string") ? this.texturePath : THREE.Loader.prototype.extractUrlBase(url);
        var loader = new THREE.XHRLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(text) {
          var json = JSON.parse(text);
          var metadata = json.metadata;
          if (metadata !== undefined) {
            if (metadata.type === 'object') {
              console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.');
              return;
            }
            if (metadata.type === 'scene') {
              console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.');
              return;
            }
          }
          var object = scope.parse(json, texturePath);
          onLoad(object.geometry, object.materials);
        });
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      },
      setTexturePath: function(value) {
        this.texturePath = value;
      },
      parse: function(json, texturePath) {
        var geometry = new THREE.Geometry(),
            scale = (json.scale !== undefined) ? 1.0 / json.scale : 1.0;
        parseModel(scale);
        parseSkin();
        parseMorphing(scale);
        parseAnimations();
        geometry.computeFaceNormals();
        geometry.computeBoundingSphere();
        function parseModel(scale) {
          function isBitSet(value, position) {
            return value & (1 << position);
          }
          var i,
              j,
              fi,
              offset,
              zLength,
              colorIndex,
              normalIndex,
              uvIndex,
              materialIndex,
              type,
              isQuad,
              hasMaterial,
              hasFaceVertexUv,
              hasFaceNormal,
              hasFaceVertexNormal,
              hasFaceColor,
              hasFaceVertexColor,
              vertex,
              face,
              faceA,
              faceB,
              hex,
              normal,
              uvLayer,
              uv,
              u,
              v,
              faces = json.faces,
              vertices = json.vertices,
              normals = json.normals,
              colors = json.colors,
              nUvLayers = 0;
          if (json.uvs !== undefined) {
            for (i = 0; i < json.uvs.length; i++) {
              if (json.uvs[i].length)
                nUvLayers++;
            }
            for (i = 0; i < nUvLayers; i++) {
              geometry.faceVertexUvs[i] = [];
            }
          }
          offset = 0;
          zLength = vertices.length;
          while (offset < zLength) {
            vertex = new THREE.Vector3();
            vertex.x = vertices[offset++] * scale;
            vertex.y = vertices[offset++] * scale;
            vertex.z = vertices[offset++] * scale;
            geometry.vertices.push(vertex);
          }
          offset = 0;
          zLength = faces.length;
          while (offset < zLength) {
            type = faces[offset++];
            isQuad = isBitSet(type, 0);
            hasMaterial = isBitSet(type, 1);
            hasFaceVertexUv = isBitSet(type, 3);
            hasFaceNormal = isBitSet(type, 4);
            hasFaceVertexNormal = isBitSet(type, 5);
            hasFaceColor = isBitSet(type, 6);
            hasFaceVertexColor = isBitSet(type, 7);
            if (isQuad) {
              faceA = new THREE.Face3();
              faceA.a = faces[offset];
              faceA.b = faces[offset + 1];
              faceA.c = faces[offset + 3];
              faceB = new THREE.Face3();
              faceB.a = faces[offset + 1];
              faceB.b = faces[offset + 2];
              faceB.c = faces[offset + 3];
              offset += 4;
              if (hasMaterial) {
                materialIndex = faces[offset++];
                faceA.materialIndex = materialIndex;
                faceB.materialIndex = materialIndex;
              }
              fi = geometry.faces.length;
              if (hasFaceVertexUv) {
                for (i = 0; i < nUvLayers; i++) {
                  uvLayer = json.uvs[i];
                  geometry.faceVertexUvs[i][fi] = [];
                  geometry.faceVertexUvs[i][fi + 1] = [];
                  for (j = 0; j < 4; j++) {
                    uvIndex = faces[offset++];
                    u = uvLayer[uvIndex * 2];
                    v = uvLayer[uvIndex * 2 + 1];
                    uv = new THREE.Vector2(u, v);
                    if (j !== 2)
                      geometry.faceVertexUvs[i][fi].push(uv);
                    if (j !== 0)
                      geometry.faceVertexUvs[i][fi + 1].push(uv);
                  }
                }
              }
              if (hasFaceNormal) {
                normalIndex = faces[offset++] * 3;
                faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                faceB.normal.copy(faceA.normal);
              }
              if (hasFaceVertexNormal) {
                for (i = 0; i < 4; i++) {
                  normalIndex = faces[offset++] * 3;
                  normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                  if (i !== 2)
                    faceA.vertexNormals.push(normal);
                  if (i !== 0)
                    faceB.vertexNormals.push(normal);
                }
              }
              if (hasFaceColor) {
                colorIndex = faces[offset++];
                hex = colors[colorIndex];
                faceA.color.setHex(hex);
                faceB.color.setHex(hex);
              }
              if (hasFaceVertexColor) {
                for (i = 0; i < 4; i++) {
                  colorIndex = faces[offset++];
                  hex = colors[colorIndex];
                  if (i !== 2)
                    faceA.vertexColors.push(new THREE.Color(hex));
                  if (i !== 0)
                    faceB.vertexColors.push(new THREE.Color(hex));
                }
              }
              geometry.faces.push(faceA);
              geometry.faces.push(faceB);
            } else {
              face = new THREE.Face3();
              face.a = faces[offset++];
              face.b = faces[offset++];
              face.c = faces[offset++];
              if (hasMaterial) {
                materialIndex = faces[offset++];
                face.materialIndex = materialIndex;
              }
              fi = geometry.faces.length;
              if (hasFaceVertexUv) {
                for (i = 0; i < nUvLayers; i++) {
                  uvLayer = json.uvs[i];
                  geometry.faceVertexUvs[i][fi] = [];
                  for (j = 0; j < 3; j++) {
                    uvIndex = faces[offset++];
                    u = uvLayer[uvIndex * 2];
                    v = uvLayer[uvIndex * 2 + 1];
                    uv = new THREE.Vector2(u, v);
                    geometry.faceVertexUvs[i][fi].push(uv);
                  }
                }
              }
              if (hasFaceNormal) {
                normalIndex = faces[offset++] * 3;
                face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
              }
              if (hasFaceVertexNormal) {
                for (i = 0; i < 3; i++) {
                  normalIndex = faces[offset++] * 3;
                  normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                  face.vertexNormals.push(normal);
                }
              }
              if (hasFaceColor) {
                colorIndex = faces[offset++];
                face.color.setHex(colors[colorIndex]);
              }
              if (hasFaceVertexColor) {
                for (i = 0; i < 3; i++) {
                  colorIndex = faces[offset++];
                  face.vertexColors.push(new THREE.Color(colors[colorIndex]));
                }
              }
              geometry.faces.push(face);
            }
          }
        }
        ;
        function parseSkin() {
          var influencesPerVertex = (json.influencesPerVertex !== undefined) ? json.influencesPerVertex : 2;
          if (json.skinWeights) {
            for (var i = 0,
                l = json.skinWeights.length; i < l; i += influencesPerVertex) {
              var x = json.skinWeights[i];
              var y = (influencesPerVertex > 1) ? json.skinWeights[i + 1] : 0;
              var z = (influencesPerVertex > 2) ? json.skinWeights[i + 2] : 0;
              var w = (influencesPerVertex > 3) ? json.skinWeights[i + 3] : 0;
              geometry.skinWeights.push(new THREE.Vector4(x, y, z, w));
            }
          }
          if (json.skinIndices) {
            for (var i = 0,
                l = json.skinIndices.length; i < l; i += influencesPerVertex) {
              var a = json.skinIndices[i];
              var b = (influencesPerVertex > 1) ? json.skinIndices[i + 1] : 0;
              var c = (influencesPerVertex > 2) ? json.skinIndices[i + 2] : 0;
              var d = (influencesPerVertex > 3) ? json.skinIndices[i + 3] : 0;
              geometry.skinIndices.push(new THREE.Vector4(a, b, c, d));
            }
          }
          geometry.bones = json.bones;
          if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {
            console.warn('When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' + geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.');
          }
        }
        ;
        function parseMorphing(scale) {
          if (json.morphTargets !== undefined) {
            for (var i = 0,
                l = json.morphTargets.length; i < l; i++) {
              geometry.morphTargets[i] = {};
              geometry.morphTargets[i].name = json.morphTargets[i].name;
              geometry.morphTargets[i].vertices = [];
              var dstVertices = geometry.morphTargets[i].vertices;
              var srcVertices = json.morphTargets[i].vertices;
              for (var v = 0,
                  vl = srcVertices.length; v < vl; v += 3) {
                var vertex = new THREE.Vector3();
                vertex.x = srcVertices[v] * scale;
                vertex.y = srcVertices[v + 1] * scale;
                vertex.z = srcVertices[v + 2] * scale;
                dstVertices.push(vertex);
              }
            }
          }
          if (json.morphColors !== undefined && json.morphColors.length > 0) {
            console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
            var faces = geometry.faces;
            var morphColors = json.morphColors[0].colors;
            for (var i = 0,
                l = faces.length; i < l; i++) {
              faces[i].color.fromArray(morphColors, i * 3);
            }
          }
        }
        function parseAnimations() {
          var outputAnimations = [];
          var animations = [];
          if (json.animation !== undefined) {
            animations.push(json.animation);
          }
          if (json.animations !== undefined) {
            if (json.animations.length) {
              animations = animations.concat(json.animations);
            } else {
              animations.push(json.animations);
            }
          }
          for (var i = 0; i < animations.length; i++) {
            var clip = THREE.AnimationClip.parseAnimation(animations[i], geometry.bones);
            if (clip)
              outputAnimations.push(clip);
          }
          if (geometry.morphTargets) {
            var morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
            outputAnimations = outputAnimations.concat(morphAnimationClips);
          }
          if (outputAnimations.length > 0)
            geometry.animations = outputAnimations;
        }
        ;
        if (json.materials === undefined || json.materials.length === 0) {
          return {geometry: geometry};
        } else {
          var materials = THREE.Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin);
          return {
            geometry: geometry,
            materials: materials
          };
        }
      }
    };
    THREE.LoadingManager = function(onLoad, onProgress, onError) {
      var scope = this;
      var isLoading = false,
          itemsLoaded = 0,
          itemsTotal = 0;
      this.onStart = undefined;
      this.onLoad = onLoad;
      this.onProgress = onProgress;
      this.onError = onError;
      this.itemStart = function(url) {
        itemsTotal++;
        if (isLoading === false) {
          if (scope.onStart !== undefined) {
            scope.onStart(url, itemsLoaded, itemsTotal);
          }
        }
        isLoading = true;
      };
      this.itemEnd = function(url) {
        itemsLoaded++;
        if (scope.onProgress !== undefined) {
          scope.onProgress(url, itemsLoaded, itemsTotal);
        }
        if (itemsLoaded === itemsTotal) {
          isLoading = false;
          if (scope.onLoad !== undefined) {
            scope.onLoad();
          }
        }
      };
      this.itemError = function(url) {
        if (scope.onError !== undefined) {
          scope.onError(url);
        }
      };
    };
    THREE.DefaultLoadingManager = new THREE.LoadingManager();
    THREE.BufferGeometryLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    };
    THREE.BufferGeometryLoader.prototype = {
      constructor: THREE.BufferGeometryLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new THREE.XHRLoader(scope.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.load(url, function(text) {
          onLoad(scope.parse(JSON.parse(text)));
        }, onProgress, onError);
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      },
      parse: function(json) {
        var geometry = new THREE.BufferGeometry();
        var index = json.data.index;
        if (index !== undefined) {
          var typedArray = new self[index.type](index.array);
          geometry.setIndex(new THREE.BufferAttribute(typedArray, 1));
        }
        var attributes = json.data.attributes;
        for (var key in attributes) {
          var attribute = attributes[key];
          var typedArray = new self[attribute.type](attribute.array);
          geometry.addAttribute(key, new THREE.BufferAttribute(typedArray, attribute.itemSize));
        }
        var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
        if (groups !== undefined) {
          for (var i = 0,
              n = groups.length; i !== n; ++i) {
            var group = groups[i];
            geometry.addGroup(group.start, group.count);
          }
        }
        var boundingSphere = json.data.boundingSphere;
        if (boundingSphere !== undefined) {
          var center = new THREE.Vector3();
          if (boundingSphere.center !== undefined) {
            center.fromArray(boundingSphere.center);
          }
          geometry.boundingSphere = new THREE.Sphere(center, boundingSphere.radius);
        }
        return geometry;
      }
    };
    THREE.MaterialLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
      this.textures = {};
    };
    THREE.MaterialLoader.prototype = {
      constructor: THREE.MaterialLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new THREE.XHRLoader(scope.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.load(url, function(text) {
          onLoad(scope.parse(JSON.parse(text)));
        }, onProgress, onError);
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      },
      setTextures: function(value) {
        this.textures = value;
      },
      getTexture: function(name) {
        var textures = this.textures;
        if (textures[name] === undefined) {
          console.warn('THREE.MaterialLoader: Undefined texture', name);
        }
        return textures[name];
      },
      parse: function(json) {
        var material = new THREE[json.type];
        material.uuid = json.uuid;
        if (json.name !== undefined)
          material.name = json.name;
        if (json.color !== undefined)
          material.color.setHex(json.color);
        if (json.emissive !== undefined)
          material.emissive.setHex(json.emissive);
        if (json.specular !== undefined)
          material.specular.setHex(json.specular);
        if (json.shininess !== undefined)
          material.shininess = json.shininess;
        if (json.uniforms !== undefined)
          material.uniforms = json.uniforms;
        if (json.vertexShader !== undefined)
          material.vertexShader = json.vertexShader;
        if (json.fragmentShader !== undefined)
          material.fragmentShader = json.fragmentShader;
        if (json.vertexColors !== undefined)
          material.vertexColors = json.vertexColors;
        if (json.shading !== undefined)
          material.shading = json.shading;
        if (json.blending !== undefined)
          material.blending = json.blending;
        if (json.side !== undefined)
          material.side = json.side;
        if (json.opacity !== undefined)
          material.opacity = json.opacity;
        if (json.transparent !== undefined)
          material.transparent = json.transparent;
        if (json.alphaTest !== undefined)
          material.alphaTest = json.alphaTest;
        if (json.depthTest !== undefined)
          material.depthTest = json.depthTest;
        if (json.depthWrite !== undefined)
          material.depthWrite = json.depthWrite;
        if (json.wireframe !== undefined)
          material.wireframe = json.wireframe;
        if (json.wireframeLinewidth !== undefined)
          material.wireframeLinewidth = json.wireframeLinewidth;
        if (json.size !== undefined)
          material.size = json.size;
        if (json.sizeAttenuation !== undefined)
          material.sizeAttenuation = json.sizeAttenuation;
        if (json.map !== undefined)
          material.map = this.getTexture(json.map);
        if (json.alphaMap !== undefined) {
          material.alphaMap = this.getTexture(json.alphaMap);
          material.transparent = true;
        }
        if (json.bumpMap !== undefined)
          material.bumpMap = this.getTexture(json.bumpMap);
        if (json.bumpScale !== undefined)
          material.bumpScale = json.bumpScale;
        if (json.normalMap !== undefined)
          material.normalMap = this.getTexture(json.normalMap);
        if (json.normalScale)
          material.normalScale = new THREE.Vector2(json.normalScale, json.normalScale);
        if (json.displacementMap !== undefined)
          material.displacementMap = this.getTexture(json.displacementMap);
        if (json.displacementScale !== undefined)
          material.displacementScale = json.displacementScale;
        if (json.displacementBias !== undefined)
          material.displacementBias = json.displacementBias;
        if (json.specularMap !== undefined)
          material.specularMap = this.getTexture(json.specularMap);
        if (json.envMap !== undefined) {
          material.envMap = this.getTexture(json.envMap);
          material.combine = THREE.MultiplyOperation;
        }
        if (json.reflectivity)
          material.reflectivity = json.reflectivity;
        if (json.lightMap !== undefined)
          material.lightMap = this.getTexture(json.lightMap);
        if (json.lightMapIntensity !== undefined)
          material.lightMapIntensity = json.lightMapIntensity;
        if (json.aoMap !== undefined)
          material.aoMap = this.getTexture(json.aoMap);
        if (json.aoMapIntensity !== undefined)
          material.aoMapIntensity = json.aoMapIntensity;
        if (json.materials !== undefined) {
          for (var i = 0,
              l = json.materials.length; i < l; i++) {
            material.materials.push(this.parse(json.materials[i]));
          }
        }
        return material;
      }
    };
    THREE.ObjectLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
      this.texturePath = '';
    };
    THREE.ObjectLoader.prototype = {
      constructor: THREE.ObjectLoader,
      load: function(url, onLoad, onProgress, onError) {
        if (this.texturePath === '') {
          this.texturePath = url.substring(0, url.lastIndexOf('/') + 1);
        }
        var scope = this;
        var loader = new THREE.XHRLoader(scope.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.load(url, function(text) {
          scope.parse(JSON.parse(text), onLoad);
        }, onProgress, onError);
      },
      setTexturePath: function(value) {
        this.texturePath = value;
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      },
      parse: function(json, onLoad) {
        var geometries = this.parseGeometries(json.geometries);
        var images = this.parseImages(json.images, function() {
          if (onLoad !== undefined)
            onLoad(object);
        });
        var textures = this.parseTextures(json.textures, images);
        var materials = this.parseMaterials(json.materials, textures);
        var object = this.parseObject(json.object, geometries, materials);
        if (json.animations) {
          object.animations = this.parseAnimations(json.animations);
        }
        if (json.images === undefined || json.images.length === 0) {
          if (onLoad !== undefined)
            onLoad(object);
        }
        return object;
      },
      parseGeometries: function(json) {
        var geometries = {};
        if (json !== undefined) {
          var geometryLoader = new THREE.JSONLoader();
          var bufferGeometryLoader = new THREE.BufferGeometryLoader();
          for (var i = 0,
              l = json.length; i < l; i++) {
            var geometry;
            var data = json[i];
            switch (data.type) {
              case 'PlaneGeometry':
              case 'PlaneBufferGeometry':
                geometry = new THREE[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                break;
              case 'BoxGeometry':
              case 'CubeGeometry':
                geometry = new THREE.BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                break;
              case 'CircleBufferGeometry':
                geometry = new THREE.CircleBufferGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
                break;
              case 'CircleGeometry':
                geometry = new THREE.CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
                break;
              case 'CylinderGeometry':
                geometry = new THREE.CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                break;
              case 'SphereGeometry':
                geometry = new THREE.SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                break;
              case 'SphereBufferGeometry':
                geometry = new THREE.SphereBufferGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                break;
              case 'DodecahedronGeometry':
                geometry = new THREE.DodecahedronGeometry(data.radius, data.detail);
                break;
              case 'IcosahedronGeometry':
                geometry = new THREE.IcosahedronGeometry(data.radius, data.detail);
                break;
              case 'OctahedronGeometry':
                geometry = new THREE.OctahedronGeometry(data.radius, data.detail);
                break;
              case 'TetrahedronGeometry':
                geometry = new THREE.TetrahedronGeometry(data.radius, data.detail);
                break;
              case 'RingGeometry':
                geometry = new THREE.RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
                break;
              case 'TorusGeometry':
                geometry = new THREE.TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                break;
              case 'TorusKnotGeometry':
                geometry = new THREE.TorusKnotGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.p, data.q, data.heightScale);
                break;
              case 'BufferGeometry':
                geometry = bufferGeometryLoader.parse(data);
                break;
              case 'Geometry':
                geometry = geometryLoader.parse(data.data, this.texturePath).geometry;
                break;
              default:
                console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                continue;
            }
            geometry.uuid = data.uuid;
            if (data.name !== undefined)
              geometry.name = data.name;
            geometries[data.uuid] = geometry;
          }
        }
        return geometries;
      },
      parseMaterials: function(json, textures) {
        var materials = {};
        if (json !== undefined) {
          var loader = new THREE.MaterialLoader();
          loader.setTextures(textures);
          for (var i = 0,
              l = json.length; i < l; i++) {
            var material = loader.parse(json[i]);
            materials[material.uuid] = material;
          }
        }
        return materials;
      },
      parseAnimations: function(json) {
        var animations = [];
        for (var i = 0; i < json.length; i++) {
          var clip = THREE.AnimationClip.parse(json[i]);
          animations.push(clip);
        }
        return animations;
      },
      parseImages: function(json, onLoad) {
        var scope = this;
        var images = {};
        function loadImage(url) {
          scope.manager.itemStart(url);
          return loader.load(url, function() {
            scope.manager.itemEnd(url);
          });
        }
        if (json !== undefined && json.length > 0) {
          var manager = new THREE.LoadingManager(onLoad);
          var loader = new THREE.ImageLoader(manager);
          loader.setCrossOrigin(this.crossOrigin);
          for (var i = 0,
              l = json.length; i < l; i++) {
            var image = json[i];
            var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
            images[image.uuid] = loadImage(path);
          }
        }
        return images;
      },
      parseTextures: function(json, images) {
        function parseConstant(value) {
          if (typeof(value) === 'number')
            return value;
          console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
          return THREE[value];
        }
        var textures = {};
        if (json !== undefined) {
          for (var i = 0,
              l = json.length; i < l; i++) {
            var data = json[i];
            if (data.image === undefined) {
              console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
            }
            if (images[data.image] === undefined) {
              console.warn('THREE.ObjectLoader: Undefined image', data.image);
            }
            var texture = new THREE.Texture(images[data.image]);
            texture.needsUpdate = true;
            texture.uuid = data.uuid;
            if (data.name !== undefined)
              texture.name = data.name;
            if (data.mapping !== undefined)
              texture.mapping = parseConstant(data.mapping);
            if (data.offset !== undefined)
              texture.offset = new THREE.Vector2(data.offset[0], data.offset[1]);
            if (data.repeat !== undefined)
              texture.repeat = new THREE.Vector2(data.repeat[0], data.repeat[1]);
            if (data.minFilter !== undefined)
              texture.minFilter = parseConstant(data.minFilter);
            if (data.magFilter !== undefined)
              texture.magFilter = parseConstant(data.magFilter);
            if (data.anisotropy !== undefined)
              texture.anisotropy = data.anisotropy;
            if (Array.isArray(data.wrap)) {
              texture.wrapS = parseConstant(data.wrap[0]);
              texture.wrapT = parseConstant(data.wrap[1]);
            }
            textures[data.uuid] = texture;
          }
        }
        return textures;
      },
      parseObject: function() {
        var matrix = new THREE.Matrix4();
        return function(data, geometries, materials) {
          var object;
          function getGeometry(name) {
            if (geometries[name] === undefined) {
              console.warn('THREE.ObjectLoader: Undefined geometry', name);
            }
            return geometries[name];
          }
          function getMaterial(name) {
            if (name === undefined)
              return undefined;
            if (materials[name] === undefined) {
              console.warn('THREE.ObjectLoader: Undefined material', name);
            }
            return materials[name];
          }
          switch (data.type) {
            case 'Scene':
              object = new THREE.Scene();
              break;
            case 'PerspectiveCamera':
              object = new THREE.PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
              break;
            case 'OrthographicCamera':
              object = new THREE.OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
              break;
            case 'AmbientLight':
              object = new THREE.AmbientLight(data.color);
              break;
            case 'DirectionalLight':
              object = new THREE.DirectionalLight(data.color, data.intensity);
              break;
            case 'PointLight':
              object = new THREE.PointLight(data.color, data.intensity, data.distance, data.decay);
              break;
            case 'SpotLight':
              object = new THREE.SpotLight(data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay);
              break;
            case 'HemisphereLight':
              object = new THREE.HemisphereLight(data.color, data.groundColor, data.intensity);
              break;
            case 'Mesh':
              object = new THREE.Mesh(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case 'LOD':
              object = new THREE.LOD();
              break;
            case 'Line':
              object = new THREE.Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
              break;
            case 'PointCloud':
            case 'Points':
              object = new THREE.Points(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case 'Sprite':
              object = new THREE.Sprite(getMaterial(data.material));
              break;
            case 'Group':
              object = new THREE.Group();
              break;
            default:
              object = new THREE.Object3D();
          }
          object.uuid = data.uuid;
          if (data.name !== undefined)
            object.name = data.name;
          if (data.matrix !== undefined) {
            matrix.fromArray(data.matrix);
            matrix.decompose(object.position, object.quaternion, object.scale);
          } else {
            if (data.position !== undefined)
              object.position.fromArray(data.position);
            if (data.rotation !== undefined)
              object.rotation.fromArray(data.rotation);
            if (data.scale !== undefined)
              object.scale.fromArray(data.scale);
          }
          if (data.castShadow !== undefined)
            object.castShadow = data.castShadow;
          if (data.receiveShadow !== undefined)
            object.receiveShadow = data.receiveShadow;
          if (data.visible !== undefined)
            object.visible = data.visible;
          if (data.userData !== undefined)
            object.userData = data.userData;
          if (data.children !== undefined) {
            for (var child in data.children) {
              object.add(this.parseObject(data.children[child], geometries, materials));
            }
          }
          if (data.type === 'LOD') {
            var levels = data.levels;
            for (var l = 0; l < levels.length; l++) {
              var level = levels[l];
              var child = object.getObjectByProperty('uuid', level.object);
              if (child !== undefined) {
                object.addLevel(child, level.distance);
              }
            }
          }
          return object;
        };
      }()
    };
    THREE.TextureLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    };
    THREE.TextureLoader.prototype = {
      constructor: THREE.TextureLoader,
      load: function(url, onLoad, onProgress, onError) {
        var texture = new THREE.Texture();
        var loader = new THREE.ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.load(url, function(image) {
          texture.image = image;
          texture.needsUpdate = true;
          if (onLoad !== undefined) {
            onLoad(texture);
          }
        }, onProgress, onError);
        return texture;
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      }
    };
    THREE.CubeTextureLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    };
    THREE.CubeTextureLoader.prototype = {
      constructor: THREE.CubeTextureLoader,
      load: function(urls, onLoad, onProgress, onError) {
        var texture = new THREE.CubeTexture([]);
        var loader = new THREE.ImageLoader();
        loader.setCrossOrigin(this.crossOrigin);
        var loaded = 0;
        function loadTexture(i) {
          loader.load(urls[i], function(image) {
            texture.images[i] = image;
            loaded++;
            if (loaded === 6) {
              texture.needsUpdate = true;
              if (onLoad)
                onLoad(texture);
            }
          }, undefined, onError);
        }
        for (var i = 0; i < urls.length; ++i) {
          loadTexture(i);
        }
        return texture;
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      }
    };
    THREE.DataTextureLoader = THREE.BinaryTextureLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
      this._parser = null;
    };
    THREE.BinaryTextureLoader.prototype = {
      constructor: THREE.BinaryTextureLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var texture = new THREE.DataTexture();
        var loader = new THREE.XHRLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setResponseType('arraybuffer');
        loader.load(url, function(buffer) {
          var texData = scope._parser(buffer);
          if (!texData)
            return;
          if (undefined !== texData.image) {
            texture.image = texData.image;
          } else if (undefined !== texData.data) {
            texture.image.width = texData.width;
            texture.image.height = texData.height;
            texture.image.data = texData.data;
          }
          texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
          texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;
          texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
          texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;
          texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
          if (undefined !== texData.format) {
            texture.format = texData.format;
          }
          if (undefined !== texData.type) {
            texture.type = texData.type;
          }
          if (undefined !== texData.mipmaps) {
            texture.mipmaps = texData.mipmaps;
          }
          if (1 === texData.mipmapCount) {
            texture.minFilter = THREE.LinearFilter;
          }
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture, texData);
        }, onProgress, onError);
        return texture;
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      }
    };
    THREE.CompressedTextureLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
      this._parser = null;
    };
    THREE.CompressedTextureLoader.prototype = {
      constructor: THREE.CompressedTextureLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var images = [];
        var texture = new THREE.CompressedTexture();
        texture.image = images;
        var loader = new THREE.XHRLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setResponseType('arraybuffer');
        if (Array.isArray(url)) {
          var loaded = 0;
          var loadTexture = function(i) {
            loader.load(url[i], function(buffer) {
              var texDatas = scope._parser(buffer, true);
              images[i] = {
                width: texDatas.width,
                height: texDatas.height,
                format: texDatas.format,
                mipmaps: texDatas.mipmaps
              };
              loaded += 1;
              if (loaded === 6) {
                if (texDatas.mipmapCount === 1)
                  texture.minFilter = THREE.LinearFilter;
                texture.format = texDatas.format;
                texture.needsUpdate = true;
                if (onLoad)
                  onLoad(texture);
              }
            }, onProgress, onError);
          };
          for (var i = 0,
              il = url.length; i < il; ++i) {
            loadTexture(i);
          }
        } else {
          loader.load(url, function(buffer) {
            var texDatas = scope._parser(buffer, true);
            if (texDatas.isCubemap) {
              var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
              for (var f = 0; f < faces; f++) {
                images[f] = {mipmaps: []};
                for (var i = 0; i < texDatas.mipmapCount; i++) {
                  images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                  images[f].format = texDatas.format;
                  images[f].width = texDatas.width;
                  images[f].height = texDatas.height;
                }
              }
            } else {
              texture.image.width = texDatas.width;
              texture.image.height = texDatas.height;
              texture.mipmaps = texDatas.mipmaps;
            }
            if (texDatas.mipmapCount === 1) {
              texture.minFilter = THREE.LinearFilter;
            }
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad)
              onLoad(texture);
          }, onProgress, onError);
        }
        return texture;
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      }
    };
    THREE.Material = function() {
      Object.defineProperty(this, 'id', {value: THREE.MaterialIdCount++});
      this.uuid = THREE.Math.generateUUID();
      this.name = '';
      this.type = 'Material';
      this.side = THREE.FrontSide;
      this.opacity = 1;
      this.transparent = false;
      this.blending = THREE.NormalBlending;
      this.blendSrc = THREE.SrcAlphaFactor;
      this.blendDst = THREE.OneMinusSrcAlphaFactor;
      this.blendEquation = THREE.AddEquation;
      this.blendSrcAlpha = null;
      this.blendDstAlpha = null;
      this.blendEquationAlpha = null;
      this.depthFunc = THREE.LessEqualDepth;
      this.depthTest = true;
      this.depthWrite = true;
      this.colorWrite = true;
      this.precision = null;
      this.polygonOffset = false;
      this.polygonOffsetFactor = 0;
      this.polygonOffsetUnits = 0;
      this.alphaTest = 0;
      this.overdraw = 0;
      this.visible = true;
      this._needsUpdate = true;
    };
    THREE.Material.prototype = {
      constructor: THREE.Material,
      get needsUpdate() {
        return this._needsUpdate;
      },
      set needsUpdate(value) {
        if (value === true)
          this.update();
        this._needsUpdate = value;
      },
      setValues: function(values) {
        if (values === undefined)
          return;
        for (var key in values) {
          var newValue = values[key];
          if (newValue === undefined) {
            console.warn("THREE.Material: '" + key + "' parameter is undefined.");
            continue;
          }
          var currentValue = this[key];
          if (currentValue === undefined) {
            console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
            continue;
          }
          if (currentValue instanceof THREE.Color) {
            currentValue.set(newValue);
          } else if (currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3) {
            currentValue.copy(newValue);
          } else if (key === 'overdraw') {
            this[key] = Number(newValue);
          } else {
            this[key] = newValue;
          }
        }
      },
      toJSON: function(meta) {
        var data = {metadata: {
            version: 4.4,
            type: 'Material',
            generator: 'Material.toJSON'
          }};
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '')
          data.name = this.name;
        if (this.color instanceof THREE.Color)
          data.color = this.color.getHex();
        if (this.emissive instanceof THREE.Color)
          data.emissive = this.emissive.getHex();
        if (this.specular instanceof THREE.Color)
          data.specular = this.specular.getHex();
        if (this.shininess !== undefined)
          data.shininess = this.shininess;
        if (this.map instanceof THREE.Texture)
          data.map = this.map.toJSON(meta).uuid;
        if (this.alphaMap instanceof THREE.Texture)
          data.alphaMap = this.alphaMap.toJSON(meta).uuid;
        if (this.lightMap instanceof THREE.Texture)
          data.lightMap = this.lightMap.toJSON(meta).uuid;
        if (this.bumpMap instanceof THREE.Texture) {
          data.bumpMap = this.bumpMap.toJSON(meta).uuid;
          data.bumpScale = this.bumpScale;
        }
        if (this.normalMap instanceof THREE.Texture) {
          data.normalMap = this.normalMap.toJSON(meta).uuid;
          data.normalScale = this.normalScale;
        }
        if (this.displacementMap instanceof THREE.Texture) {
          data.displacementMap = this.displacementMap.toJSON(meta).uuid;
          data.displacementScale = this.displacementScale;
          data.displacementBias = this.displacementBias;
        }
        if (this.specularMap instanceof THREE.Texture)
          data.specularMap = this.specularMap.toJSON(meta).uuid;
        if (this.envMap instanceof THREE.Texture) {
          data.envMap = this.envMap.toJSON(meta).uuid;
          data.reflectivity = this.reflectivity;
        }
        if (this.size !== undefined)
          data.size = this.size;
        if (this.sizeAttenuation !== undefined)
          data.sizeAttenuation = this.sizeAttenuation;
        if (this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors)
          data.vertexColors = this.vertexColors;
        if (this.shading !== undefined && this.shading !== THREE.SmoothShading)
          data.shading = this.shading;
        if (this.blending !== undefined && this.blending !== THREE.NormalBlending)
          data.blending = this.blending;
        if (this.side !== undefined && this.side !== THREE.FrontSide)
          data.side = this.side;
        if (this.opacity < 1)
          data.opacity = this.opacity;
        if (this.transparent === true)
          data.transparent = this.transparent;
        if (this.alphaTest > 0)
          data.alphaTest = this.alphaTest;
        if (this.wireframe === true)
          data.wireframe = this.wireframe;
        if (this.wireframeLinewidth > 1)
          data.wireframeLinewidth = this.wireframeLinewidth;
        return data;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(source) {
        this.name = source.name;
        this.side = source.side;
        this.opacity = source.opacity;
        this.transparent = source.transparent;
        this.blending = source.blending;
        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;
        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;
        this.precision = source.precision;
        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;
        this.alphaTest = source.alphaTest;
        this.overdraw = source.overdraw;
        this.visible = source.visible;
        return this;
      },
      update: function() {
        this.dispatchEvent({type: 'update'});
      },
      dispose: function() {
        this.dispatchEvent({type: 'dispose'});
      },
      get wrapAround() {
        console.warn('THREE.' + this.type + ': .wrapAround has been removed.');
      },
      set wrapAround(boolean) {
        console.warn('THREE.' + this.type + ': .wrapAround has been removed.');
      },
      get wrapRGB() {
        console.warn('THREE.' + this.type + ': .wrapRGB has been removed.');
        return new THREE.Color();
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);
    THREE.MaterialIdCount = 0;
    THREE.LineBasicMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'LineBasicMaterial';
      this.color = new THREE.Color(0xffffff);
      this.linewidth = 1;
      this.linecap = 'round';
      this.linejoin = 'round';
      this.vertexColors = THREE.NoColors;
      this.fog = true;
      this.setValues(parameters);
    };
    THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;
    THREE.LineBasicMaterial.prototype.copy = function(source) {
      THREE.Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.linewidth = source.linewidth;
      this.linecap = source.linecap;
      this.linejoin = source.linejoin;
      this.vertexColors = source.vertexColors;
      this.fog = source.fog;
      return this;
    };
    THREE.LineDashedMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'LineDashedMaterial';
      this.color = new THREE.Color(0xffffff);
      this.linewidth = 1;
      this.scale = 1;
      this.dashSize = 3;
      this.gapSize = 1;
      this.vertexColors = false;
      this.fog = true;
      this.setValues(parameters);
    };
    THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;
    THREE.LineDashedMaterial.prototype.copy = function(source) {
      THREE.Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.linewidth = source.linewidth;
      this.scale = source.scale;
      this.dashSize = source.dashSize;
      this.gapSize = source.gapSize;
      this.vertexColors = source.vertexColors;
      this.fog = source.fog;
      return this;
    };
    THREE.MeshBasicMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'MeshBasicMaterial';
      this.color = new THREE.Color(0xffffff);
      this.map = null;
      this.aoMap = null;
      this.aoMapIntensity = 1.0;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = THREE.MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.fog = true;
      this.shading = THREE.SmoothShading;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = 'round';
      this.wireframeLinejoin = 'round';
      this.vertexColors = THREE.NoColors;
      this.skinning = false;
      this.morphTargets = false;
      this.setValues(parameters);
    };
    THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;
    THREE.MeshBasicMaterial.prototype.copy = function(source) {
      THREE.Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.map = source.map;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.fog = source.fog;
      this.shading = source.shading;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.vertexColors = source.vertexColors;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      return this;
    };
    THREE.MeshLambertMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'MeshLambertMaterial';
      this.color = new THREE.Color(0xffffff);
      this.emissive = new THREE.Color(0x000000);
      this.map = null;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = THREE.MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.fog = true;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = 'round';
      this.wireframeLinejoin = 'round';
      this.vertexColors = THREE.NoColors;
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.setValues(parameters);
    };
    THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;
    THREE.MeshLambertMaterial.prototype.copy = function(source) {
      THREE.Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.emissive.copy(source.emissive);
      this.map = source.map;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.fog = source.fog;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.vertexColors = source.vertexColors;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      return this;
    };
    THREE.MeshPhongMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'MeshPhongMaterial';
      this.color = new THREE.Color(0xffffff);
      this.emissive = new THREE.Color(0x000000);
      this.specular = new THREE.Color(0x111111);
      this.shininess = 30;
      this.metal = false;
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1.0;
      this.aoMap = null;
      this.aoMapIntensity = 1.0;
      this.emissiveMap = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalScale = new THREE.Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = THREE.MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.fog = true;
      this.shading = THREE.SmoothShading;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = 'round';
      this.wireframeLinejoin = 'round';
      this.vertexColors = THREE.NoColors;
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.setValues(parameters);
    };
    THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;
    THREE.MeshPhongMaterial.prototype.copy = function(source) {
      THREE.Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.emissive.copy(source.emissive);
      this.specular.copy(source.specular);
      this.shininess = source.shininess;
      this.metal = source.metal;
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissiveMap = source.emissiveMap;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.fog = source.fog;
      this.shading = source.shading;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.vertexColors = source.vertexColors;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      return this;
    };
    THREE.MeshDepthMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'MeshDepthMaterial';
      this.morphTargets = false;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.setValues(parameters);
    };
    THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;
    THREE.MeshDepthMaterial.prototype.copy = function(source) {
      THREE.Material.prototype.copy.call(this, source);
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      return this;
    };
    THREE.MeshNormalMaterial = function(parameters) {
      THREE.Material.call(this, parameters);
      this.type = 'MeshNormalMaterial';
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.morphTargets = false;
      this.setValues(parameters);
    };
    THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;
    THREE.MeshNormalMaterial.prototype.copy = function(source) {
      THREE.Material.prototype.copy.call(this, source);
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      return this;
    };
    THREE.MultiMaterial = function(materials) {
      this.uuid = THREE.Math.generateUUID();
      this.type = 'MultiMaterial';
      this.materials = materials instanceof Array ? materials : [];
      this.visible = true;
    };
    THREE.MultiMaterial.prototype = {
      constructor: THREE.MultiMaterial,
      toJSON: function() {
        var output = {
          metadata: {
            version: 4.2,
            type: 'material',
            generator: 'MaterialExporter'
          },
          uuid: this.uuid,
          type: this.type,
          materials: []
        };
        for (var i = 0,
            l = this.materials.length; i < l; i++) {
          output.materials.push(this.materials[i].toJSON());
        }
        output.visible = this.visible;
        return output;
      },
      clone: function() {
        var material = new this.constructor();
        for (var i = 0; i < this.materials.length; i++) {
          material.materials.push(this.materials[i].clone());
        }
        material.visible = this.visible;
        return material;
      }
    };
    THREE.MeshFaceMaterial = THREE.MultiMaterial;
    THREE.PointsMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'PointsMaterial';
      this.color = new THREE.Color(0xffffff);
      this.map = null;
      this.size = 1;
      this.sizeAttenuation = true;
      this.vertexColors = THREE.NoColors;
      this.fog = true;
      this.setValues(parameters);
    };
    THREE.PointsMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;
    THREE.PointsMaterial.prototype.copy = function(source) {
      THREE.Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.map = source.map;
      this.size = source.size;
      this.sizeAttenuation = source.sizeAttenuation;
      this.vertexColors = source.vertexColors;
      this.fog = source.fog;
      return this;
    };
    THREE.PointCloudMaterial = function(parameters) {
      console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
      return new THREE.PointsMaterial(parameters);
    };
    THREE.ParticleBasicMaterial = function(parameters) {
      console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
      return new THREE.PointsMaterial(parameters);
    };
    THREE.ParticleSystemMaterial = function(parameters) {
      console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
      return new THREE.PointsMaterial(parameters);
    };
    THREE.ShaderMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'ShaderMaterial';
      this.defines = {};
      this.uniforms = {};
      this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
      this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
      this.shading = THREE.SmoothShading;
      this.linewidth = 1;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.fog = false;
      this.lights = false;
      this.vertexColors = THREE.NoColors;
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.derivatives = false;
      this.defaultAttributeValues = {
        'color': [1, 1, 1],
        'uv': [0, 0],
        'uv2': [0, 0]
      };
      this.index0AttributeName = undefined;
      if (parameters !== undefined) {
        if (parameters.attributes !== undefined) {
          console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
        }
        this.setValues(parameters);
      }
    };
    THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;
    THREE.ShaderMaterial.prototype.copy = function(source) {
      THREE.Material.prototype.copy.call(this, source);
      this.fragmentShader = source.fragmentShader;
      this.vertexShader = source.vertexShader;
      this.uniforms = THREE.UniformsUtils.clone(source.uniforms);
      this.attributes = source.attributes;
      this.defines = source.defines;
      this.shading = source.shading;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.fog = source.fog;
      this.lights = source.lights;
      this.vertexColors = source.vertexColors;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      this.derivatives = source.derivatives;
      return this;
    };
    THREE.ShaderMaterial.prototype.toJSON = function(meta) {
      var data = THREE.Material.prototype.toJSON.call(this, meta);
      data.uniforms = this.uniforms;
      data.attributes = this.attributes;
      data.vertexShader = this.vertexShader;
      data.fragmentShader = this.fragmentShader;
      return data;
    };
    THREE.RawShaderMaterial = function(parameters) {
      THREE.ShaderMaterial.call(this, parameters);
      this.type = 'RawShaderMaterial';
    };
    THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
    THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
    THREE.SpriteMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'SpriteMaterial';
      this.color = new THREE.Color(0xffffff);
      this.map = null;
      this.rotation = 0;
      this.fog = false;
      this.setValues(parameters);
    };
    THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;
    THREE.SpriteMaterial.prototype.copy = function(source) {
      THREE.Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.map = source.map;
      this.rotation = source.rotation;
      this.fog = source.fog;
      return this;
    };
    THREE.Texture = function(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      Object.defineProperty(this, 'id', {value: THREE.TextureIdCount++});
      this.uuid = THREE.Math.generateUUID();
      this.name = '';
      this.sourceFile = '';
      this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
      this.mipmaps = [];
      this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;
      this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
      this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;
      this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
      this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;
      this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
      this.format = format !== undefined ? format : THREE.RGBAFormat;
      this.type = type !== undefined ? type : THREE.UnsignedByteType;
      this.offset = new THREE.Vector2(0, 0);
      this.repeat = new THREE.Vector2(1, 1);
      this.generateMipmaps = true;
      this.premultiplyAlpha = false;
      this.flipY = true;
      this.unpackAlignment = 4;
      this.version = 0;
      this.onUpdate = null;
    };
    THREE.Texture.DEFAULT_IMAGE = undefined;
    THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;
    THREE.Texture.prototype = {
      constructor: THREE.Texture,
      set needsUpdate(value) {
        if (value === true)
          this.version++;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(source) {
        this.image = source.image;
        this.mipmaps = source.mipmaps.slice(0);
        this.mapping = source.mapping;
        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;
        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;
        this.anisotropy = source.anisotropy;
        this.format = source.format;
        this.type = source.type;
        this.offset.copy(source.offset);
        this.repeat.copy(source.repeat);
        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;
        return this;
      },
      toJSON: function(meta) {
        if (meta.textures[this.uuid] !== undefined) {
          return meta.textures[this.uuid];
        }
        function getDataURL(image) {
          var canvas;
          if (image.toDataURL !== undefined) {
            canvas = image;
          } else {
            canvas = document.createElement('canvas');
            canvas.width = image.width;
            canvas.height = image.height;
            canvas.getContext('2d').drawImage(image, 0, 0, image.width, image.height);
          }
          if (canvas.width > 2048 || canvas.height > 2048) {
            return canvas.toDataURL('image/jpeg', 0.6);
          } else {
            return canvas.toDataURL('image/png');
          }
        }
        var output = {
          metadata: {
            version: 4.4,
            type: 'Texture',
            generator: 'Texture.toJSON'
          },
          uuid: this.uuid,
          name: this.name,
          mapping: this.mapping,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          wrap: [this.wrapS, this.wrapT],
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy
        };
        if (this.image !== undefined) {
          var image = this.image;
          if (image.uuid === undefined) {
            image.uuid = THREE.Math.generateUUID();
          }
          if (meta.images[image.uuid] === undefined) {
            meta.images[image.uuid] = {
              uuid: image.uuid,
              url: getDataURL(image)
            };
          }
          output.image = image.uuid;
        }
        meta.textures[this.uuid] = output;
        return output;
      },
      dispose: function() {
        this.dispatchEvent({type: 'dispose'});
      },
      transformUv: function(uv) {
        if (this.mapping !== THREE.UVMapping)
          return;
        uv.multiply(this.repeat);
        uv.add(this.offset);
        if (uv.x < 0 || uv.x > 1) {
          switch (this.wrapS) {
            case THREE.RepeatWrapping:
              uv.x = uv.x - Math.floor(uv.x);
              break;
            case THREE.ClampToEdgeWrapping:
              uv.x = uv.x < 0 ? 0 : 1;
              break;
            case THREE.MirroredRepeatWrapping:
              if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                uv.x = Math.ceil(uv.x) - uv.x;
              } else {
                uv.x = uv.x - Math.floor(uv.x);
              }
              break;
          }
        }
        if (uv.y < 0 || uv.y > 1) {
          switch (this.wrapT) {
            case THREE.RepeatWrapping:
              uv.y = uv.y - Math.floor(uv.y);
              break;
            case THREE.ClampToEdgeWrapping:
              uv.y = uv.y < 0 ? 0 : 1;
              break;
            case THREE.MirroredRepeatWrapping:
              if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                uv.y = Math.ceil(uv.y) - uv.y;
              } else {
                uv.y = uv.y - Math.floor(uv.y);
              }
              break;
          }
        }
        if (this.flipY) {
          uv.y = 1 - uv.y;
        }
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);
    THREE.TextureIdCount = 0;
    THREE.CanvasTexture = function(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      THREE.Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.needsUpdate = true;
    };
    THREE.CanvasTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;
    THREE.CubeTexture = function(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;
      THREE.Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.images = images;
      this.flipY = false;
    };
    THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;
    THREE.CubeTexture.prototype.copy = function(source) {
      THREE.Texture.prototype.copy.call(this, source);
      this.images = source.images;
      return this;
    };
    THREE.CompressedTexture = function(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {
      THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.image = {
        width: width,
        height: height
      };
      this.mipmaps = mipmaps;
      this.flipY = false;
      this.generateMipmaps = false;
    };
    THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;
    THREE.DataTexture = function(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {
      THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.image = {
        data: data,
        width: width,
        height: height
      };
      this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
      this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;
      this.flipY = false;
      this.generateMipmaps = false;
    };
    THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.DataTexture.prototype.constructor = THREE.DataTexture;
    THREE.VideoTexture = function(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      THREE.Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.generateMipmaps = false;
      var scope = this;
      function update() {
        requestAnimationFrame(update);
        if (video.readyState === video.HAVE_ENOUGH_DATA) {
          scope.needsUpdate = true;
        }
      }
      update();
    };
    THREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;
    THREE.Group = function() {
      THREE.Object3D.call(this);
      this.type = 'Group';
    };
    THREE.Group.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Group.prototype.constructor = THREE.Group;
    THREE.Points = function(geometry, material) {
      THREE.Object3D.call(this);
      this.type = 'Points';
      this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
      this.material = material !== undefined ? material : new THREE.PointsMaterial({color: Math.random() * 0xffffff});
    };
    THREE.Points.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Points.prototype.constructor = THREE.Points;
    THREE.Points.prototype.raycast = (function() {
      var inverseMatrix = new THREE.Matrix4();
      var ray = new THREE.Ray();
      return function raycast(raycaster, intersects) {
        var object = this;
        var geometry = object.geometry;
        var threshold = raycaster.params.Points.threshold;
        inverseMatrix.getInverse(this.matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        if (geometry.boundingBox !== null) {
          if (ray.isIntersectionBox(geometry.boundingBox) === false) {
            return;
          }
        }
        var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        var localThresholdSq = localThreshold * localThreshold;
        var position = new THREE.Vector3();
        function testPoint(point, index) {
          var rayPointDistanceSq = ray.distanceSqToPoint(point);
          if (rayPointDistanceSq < localThresholdSq) {
            var intersectPoint = ray.closestPointToPoint(point);
            intersectPoint.applyMatrix4(object.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(intersectPoint);
            if (distance < raycaster.near || distance > raycaster.far)
              return;
            intersects.push({
              distance: distance,
              distanceToRay: Math.sqrt(rayPointDistanceSq),
              point: intersectPoint.clone(),
              index: index,
              face: null,
              object: object
            });
          }
        }
        if (geometry instanceof THREE.BufferGeometry) {
          var index = geometry.index;
          var attributes = geometry.attributes;
          var positions = attributes.position.array;
          if (index !== null) {
            var indices = index.array;
            for (var i = 0,
                il = indices.length; i < il; i++) {
              var a = indices[i];
              position.fromArray(positions, a * 3);
              testPoint(position, a);
            }
          } else {
            for (var i = 0,
                l = positions.length / 3; i < l; i++) {
              position.fromArray(positions, i * 3);
              testPoint(position, i);
            }
          }
        } else {
          var vertices = geometry.vertices;
          for (var i = 0,
              l = vertices.length; i < l; i++) {
            testPoint(vertices[i], i);
          }
        }
      };
    }());
    THREE.Points.prototype.clone = function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    };
    THREE.PointCloud = function(geometry, material) {
      console.warn('THREE.PointCloud has been renamed to THREE.Points.');
      return new THREE.Points(geometry, material);
    };
    THREE.ParticleSystem = function(geometry, material) {
      console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
      return new THREE.Points(geometry, material);
    };
    THREE.Line = function(geometry, material, mode) {
      if (mode === 1) {
        console.warn('THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.');
        return new THREE.LineSegments(geometry, material);
      }
      THREE.Object3D.call(this);
      this.type = 'Line';
      this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
      this.material = material !== undefined ? material : new THREE.LineBasicMaterial({color: Math.random() * 0xffffff});
    };
    THREE.Line.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Line.prototype.constructor = THREE.Line;
    THREE.Line.prototype.raycast = (function() {
      var inverseMatrix = new THREE.Matrix4();
      var ray = new THREE.Ray();
      var sphere = new THREE.Sphere();
      return function raycast(raycaster, intersects) {
        var precision = raycaster.linePrecision;
        var precisionSq = precision * precision;
        var geometry = this.geometry;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        sphere.copy(geometry.boundingSphere);
        sphere.applyMatrix4(this.matrixWorld);
        if (raycaster.ray.isIntersectionSphere(sphere) === false) {
          return;
        }
        inverseMatrix.getInverse(this.matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        var vStart = new THREE.Vector3();
        var vEnd = new THREE.Vector3();
        var interSegment = new THREE.Vector3();
        var interRay = new THREE.Vector3();
        var step = this instanceof THREE.LineSegments ? 2 : 1;
        if (geometry instanceof THREE.BufferGeometry) {
          var index = geometry.index;
          var attributes = geometry.attributes;
          if (index !== null) {
            var indices = index.array;
            var positions = attributes.position.array;
            for (var i = 0,
                l = indices.length - 1; i < l; i += step) {
              var a = indices[i];
              var b = indices[i + 1];
              vStart.fromArray(positions, a * 3);
              vEnd.fromArray(positions, b * 3);
              var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
              if (distSq > precisionSq)
                continue;
              interRay.applyMatrix4(this.matrixWorld);
              var distance = raycaster.ray.origin.distanceTo(interRay);
              if (distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects.push({
                distance: distance,
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          } else {
            var positions = attributes.position.array;
            for (var i = 0,
                l = positions.length / 3 - 1; i < l; i += step) {
              vStart.fromArray(positions, 3 * i);
              vEnd.fromArray(positions, 3 * i + 3);
              var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
              if (distSq > precisionSq)
                continue;
              interRay.applyMatrix4(this.matrixWorld);
              var distance = raycaster.ray.origin.distanceTo(interRay);
              if (distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects.push({
                distance: distance,
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          }
        } else if (geometry instanceof THREE.Geometry) {
          var vertices = geometry.vertices;
          var nbVertices = vertices.length;
          for (var i = 0; i < nbVertices - 1; i += step) {
            var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
            if (distSq > precisionSq)
              continue;
            interRay.applyMatrix4(this.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far)
              continue;
            intersects.push({
              distance: distance,
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        }
      };
    }());
    THREE.Line.prototype.clone = function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    };
    THREE.LineStrip = 0;
    THREE.LinePieces = 1;
    THREE.LineSegments = function(geometry, material) {
      THREE.Line.call(this, geometry, material);
      this.type = 'LineSegments';
    };
    THREE.LineSegments.prototype = Object.create(THREE.Line.prototype);
    THREE.LineSegments.prototype.constructor = THREE.LineSegments;
    THREE.Mesh = function(geometry, material) {
      THREE.Object3D.call(this);
      this.type = 'Mesh';
      this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
      this.material = material !== undefined ? material : new THREE.MeshBasicMaterial({color: Math.random() * 0xffffff});
      this.updateMorphTargets();
    };
    THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Mesh.prototype.constructor = THREE.Mesh;
    THREE.Mesh.prototype.updateMorphTargets = function() {
      if (this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0) {
        this.morphTargetBase = -1;
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (var m = 0,
            ml = this.geometry.morphTargets.length; m < ml; m++) {
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[this.geometry.morphTargets[m].name] = m;
        }
      }
    };
    THREE.Mesh.prototype.getMorphTargetIndexByName = function(name) {
      if (this.morphTargetDictionary[name] !== undefined) {
        return this.morphTargetDictionary[name];
      }
      console.warn('THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.');
      return 0;
    };
    THREE.Mesh.prototype.raycast = (function() {
      var inverseMatrix = new THREE.Matrix4();
      var ray = new THREE.Ray();
      var sphere = new THREE.Sphere();
      var vA = new THREE.Vector3();
      var vB = new THREE.Vector3();
      var vC = new THREE.Vector3();
      var tempA = new THREE.Vector3();
      var tempB = new THREE.Vector3();
      var tempC = new THREE.Vector3();
      var uvA = new THREE.Vector2();
      var uvB = new THREE.Vector2();
      var uvC = new THREE.Vector2();
      var barycoord = new THREE.Vector3();
      var intersectionPoint = new THREE.Vector3();
      var intersectionPointWorld = new THREE.Vector3();
      function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
        THREE.Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord);
        uv1.multiplyScalar(barycoord.x);
        uv2.multiplyScalar(barycoord.y);
        uv3.multiplyScalar(barycoord.z);
        uv1.add(uv2).add(uv3);
        return uv1.clone();
      }
      function checkIntersection(object, raycaster, ray, pA, pB, pC, point) {
        var intersect;
        var material = object.material;
        if (material.side === THREE.BackSide) {
          intersect = ray.intersectTriangle(pC, pB, pA, true, point);
        } else {
          intersect = ray.intersectTriangle(pA, pB, pC, material.side !== THREE.DoubleSide, point);
        }
        if (intersect === null)
          return null;
        intersectionPointWorld.copy(point);
        intersectionPointWorld.applyMatrix4(object.matrixWorld);
        var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
        if (distance < raycaster.near || distance > raycaster.far)
          return null;
        return {
          distance: distance,
          point: intersectionPointWorld.clone(),
          object: object
        };
      }
      function checkBufferGeometryIntersection(object, raycaster, ray, positions, uvs, a, b, c) {
        vA.fromArray(positions, a * 3);
        vB.fromArray(positions, b * 3);
        vC.fromArray(positions, c * 3);
        var intersection = checkIntersection(object, raycaster, ray, vA, vB, vC, intersectionPoint);
        if (intersection) {
          if (uvs) {
            uvA.fromArray(uvs, a * 2);
            uvB.fromArray(uvs, b * 2);
            uvC.fromArray(uvs, c * 2);
            intersection.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);
          }
          intersection.face = new THREE.Face3(a, b, c, THREE.Triangle.normal(vA, vB, vC));
          intersection.faceIndex = a;
        }
        return intersection;
      }
      return function raycast(raycaster, intersects) {
        var geometry = this.geometry;
        var material = this.material;
        if (material === undefined)
          return;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        var matrixWorld = this.matrixWorld;
        sphere.copy(geometry.boundingSphere);
        sphere.applyMatrix4(matrixWorld);
        if (raycaster.ray.isIntersectionSphere(sphere) === false)
          return;
        inverseMatrix.getInverse(matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        if (geometry.boundingBox !== null) {
          if (ray.isIntersectionBox(geometry.boundingBox) === false)
            return;
        }
        var uvs,
            intersection;
        if (geometry instanceof THREE.BufferGeometry) {
          var a,
              b,
              c;
          var index = geometry.index;
          var attributes = geometry.attributes;
          var positions = attributes.position.array;
          if (attributes.uv !== undefined) {
            uvs = attributes.uv.array;
          }
          if (index !== null) {
            var indices = index.array;
            for (var i = 0,
                l = indices.length; i < l; i += 3) {
              a = indices[i];
              b = indices[i + 1];
              c = indices[i + 2];
              intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(i / 3);
                intersects.push(intersection);
              }
            }
          } else {
            for (var i = 0,
                l = positions.length; i < l; i += 9) {
              a = i / 3;
              b = a + 1;
              c = a + 2;
              intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);
              if (intersection) {
                intersection.index = a;
                intersects.push(intersection);
              }
            }
          }
        } else if (geometry instanceof THREE.Geometry) {
          var fvA,
              fvB,
              fvC;
          var isFaceMaterial = material instanceof THREE.MeshFaceMaterial;
          var materials = isFaceMaterial === true ? material.materials : null;
          var vertices = geometry.vertices;
          var faces = geometry.faces;
          var faceVertexUvs = geometry.faceVertexUvs[0];
          if (faceVertexUvs.length > 0)
            uvs = faceVertexUvs;
          for (var f = 0,
              fl = faces.length; f < fl; f++) {
            var face = faces[f];
            var faceMaterial = isFaceMaterial === true ? materials[face.materialIndex] : material;
            if (faceMaterial === undefined)
              continue;
            fvA = vertices[face.a];
            fvB = vertices[face.b];
            fvC = vertices[face.c];
            if (faceMaterial.morphTargets === true) {
              var morphTargets = geometry.morphTargets;
              var morphInfluences = this.morphTargetInfluences;
              vA.set(0, 0, 0);
              vB.set(0, 0, 0);
              vC.set(0, 0, 0);
              for (var t = 0,
                  tl = morphTargets.length; t < tl; t++) {
                var influence = morphInfluences[t];
                if (influence === 0)
                  continue;
                var targets = morphTargets[t].vertices;
                vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
                vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
                vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
              }
              vA.add(fvA);
              vB.add(fvB);
              vC.add(fvC);
              fvA = vA;
              fvB = vB;
              fvC = vC;
            }
            intersection = checkIntersection(this, raycaster, ray, fvA, fvB, fvC, intersectionPoint);
            if (intersection) {
              if (uvs) {
                var uvs_f = uvs[f];
                uvA.copy(uvs_f[0]);
                uvB.copy(uvs_f[1]);
                uvC.copy(uvs_f[2]);
                intersection.uv = uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC);
              }
              intersection.face = face;
              intersection.faceIndex = f;
              intersects.push(intersection);
            }
          }
        }
      };
    }());
    THREE.Mesh.prototype.clone = function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    };
    THREE.Bone = function(skin) {
      THREE.Object3D.call(this);
      this.type = 'Bone';
      this.skin = skin;
    };
    THREE.Bone.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Bone.prototype.constructor = THREE.Bone;
    THREE.Bone.prototype.copy = function(source) {
      THREE.Object3D.prototype.copy.call(this, source);
      this.skin = source.skin;
      return this;
    };
    THREE.Skeleton = function(bones, boneInverses, useVertexTexture) {
      this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;
      this.identityMatrix = new THREE.Matrix4();
      bones = bones || [];
      this.bones = bones.slice(0);
      if (this.useVertexTexture) {
        var size = Math.sqrt(this.bones.length * 4);
        size = THREE.Math.nextPowerOfTwo(Math.ceil(size));
        size = Math.max(size, 4);
        this.boneTextureWidth = size;
        this.boneTextureHeight = size;
        this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4);
        this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType);
      } else {
        this.boneMatrices = new Float32Array(16 * this.bones.length);
      }
      if (boneInverses === undefined) {
        this.calculateInverses();
      } else {
        if (this.bones.length === boneInverses.length) {
          this.boneInverses = boneInverses.slice(0);
        } else {
          console.warn('THREE.Skeleton bonInverses is the wrong length.');
          this.boneInverses = [];
          for (var b = 0,
              bl = this.bones.length; b < bl; b++) {
            this.boneInverses.push(new THREE.Matrix4());
          }
        }
      }
    };
    THREE.Skeleton.prototype.calculateInverses = function() {
      this.boneInverses = [];
      for (var b = 0,
          bl = this.bones.length; b < bl; b++) {
        var inverse = new THREE.Matrix4();
        if (this.bones[b]) {
          inverse.getInverse(this.bones[b].matrixWorld);
        }
        this.boneInverses.push(inverse);
      }
    };
    THREE.Skeleton.prototype.pose = function() {
      var bone;
      for (var b = 0,
          bl = this.bones.length; b < bl; b++) {
        bone = this.bones[b];
        if (bone) {
          bone.matrixWorld.getInverse(this.boneInverses[b]);
        }
      }
      for (var b = 0,
          bl = this.bones.length; b < bl; b++) {
        bone = this.bones[b];
        if (bone) {
          if (bone.parent) {
            bone.matrix.getInverse(bone.parent.matrixWorld);
            bone.matrix.multiply(bone.matrixWorld);
          } else {
            bone.matrix.copy(bone.matrixWorld);
          }
          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
        }
      }
    };
    THREE.Skeleton.prototype.update = (function() {
      var offsetMatrix = new THREE.Matrix4();
      return function update() {
        for (var b = 0,
            bl = this.bones.length; b < bl; b++) {
          var matrix = this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix;
          offsetMatrix.multiplyMatrices(matrix, this.boneInverses[b]);
          offsetMatrix.flattenToArrayOffset(this.boneMatrices, b * 16);
        }
        if (this.useVertexTexture) {
          this.boneTexture.needsUpdate = true;
        }
      };
    })();
    THREE.Skeleton.prototype.clone = function() {
      return new THREE.Skeleton(this.bones, this.boneInverses, this.useVertexTexture);
    };
    THREE.SkinnedMesh = function(geometry, material, useVertexTexture) {
      THREE.Mesh.call(this, geometry, material);
      this.type = 'SkinnedMesh';
      this.bindMode = "attached";
      this.bindMatrix = new THREE.Matrix4();
      this.bindMatrixInverse = new THREE.Matrix4();
      var bones = [];
      if (this.geometry && this.geometry.bones !== undefined) {
        var bone,
            gbone;
        for (var b = 0,
            bl = this.geometry.bones.length; b < bl; ++b) {
          gbone = this.geometry.bones[b];
          bone = new THREE.Bone(this);
          bones.push(bone);
          bone.name = gbone.name;
          bone.position.fromArray(gbone.pos);
          bone.quaternion.fromArray(gbone.rotq);
          if (gbone.scl !== undefined)
            bone.scale.fromArray(gbone.scl);
        }
        for (var b = 0,
            bl = this.geometry.bones.length; b < bl; ++b) {
          gbone = this.geometry.bones[b];
          if (gbone.parent !== -1 && gbone.parent !== null) {
            bones[gbone.parent].add(bones[b]);
          } else {
            this.add(bones[b]);
          }
        }
      }
      this.normalizeSkinWeights();
      this.updateMatrixWorld(true);
      this.bind(new THREE.Skeleton(bones, undefined, useVertexTexture), this.matrixWorld);
    };
    THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);
    THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;
    THREE.SkinnedMesh.prototype.bind = function(skeleton, bindMatrix) {
      this.skeleton = skeleton;
      if (bindMatrix === undefined) {
        this.updateMatrixWorld(true);
        this.skeleton.calculateInverses();
        bindMatrix = this.matrixWorld;
      }
      this.bindMatrix.copy(bindMatrix);
      this.bindMatrixInverse.getInverse(bindMatrix);
    };
    THREE.SkinnedMesh.prototype.pose = function() {
      this.skeleton.pose();
    };
    THREE.SkinnedMesh.prototype.normalizeSkinWeights = function() {
      if (this.geometry instanceof THREE.Geometry) {
        for (var i = 0; i < this.geometry.skinIndices.length; i++) {
          var sw = this.geometry.skinWeights[i];
          var scale = 1.0 / sw.lengthManhattan();
          if (scale !== Infinity) {
            sw.multiplyScalar(scale);
          } else {
            sw.set(1);
          }
        }
      } else {}
    };
    THREE.SkinnedMesh.prototype.updateMatrixWorld = function(force) {
      THREE.Mesh.prototype.updateMatrixWorld.call(this, true);
      if (this.bindMode === "attached") {
        this.bindMatrixInverse.getInverse(this.matrixWorld);
      } else if (this.bindMode === "detached") {
        this.bindMatrixInverse.getInverse(this.bindMatrix);
      } else {
        console.warn('THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode);
      }
    };
    THREE.SkinnedMesh.prototype.clone = function() {
      return new this.constructor(this.geometry, this.material, this.useVertexTexture).copy(this);
    };
    THREE.LOD = function() {
      THREE.Object3D.call(this);
      this.type = 'LOD';
      Object.defineProperties(this, {
        levels: {
          enumerable: true,
          value: []
        },
        objects: {get: function() {
            console.warn('THREE.LOD: .objects has been renamed to .levels.');
            return this.levels;
          }}
      });
    };
    THREE.LOD.prototype = Object.create(THREE.Object3D.prototype);
    THREE.LOD.prototype.constructor = THREE.LOD;
    THREE.LOD.prototype.addLevel = function(object, distance) {
      if (distance === undefined)
        distance = 0;
      distance = Math.abs(distance);
      var levels = this.levels;
      for (var l = 0; l < levels.length; l++) {
        if (distance < levels[l].distance) {
          break;
        }
      }
      levels.splice(l, 0, {
        distance: distance,
        object: object
      });
      this.add(object);
    };
    THREE.LOD.prototype.getObjectForDistance = function(distance) {
      var levels = this.levels;
      for (var i = 1,
          l = levels.length; i < l; i++) {
        if (distance < levels[i].distance) {
          break;
        }
      }
      return levels[i - 1].object;
    };
    THREE.LOD.prototype.raycast = (function() {
      var matrixPosition = new THREE.Vector3();
      return function raycast(raycaster, intersects) {
        matrixPosition.setFromMatrixPosition(this.matrixWorld);
        var distance = raycaster.ray.origin.distanceTo(matrixPosition);
        this.getObjectForDistance(distance).raycast(raycaster, intersects);
      };
    }());
    THREE.LOD.prototype.update = function() {
      var v1 = new THREE.Vector3();
      var v2 = new THREE.Vector3();
      return function update(camera) {
        var levels = this.levels;
        if (levels.length > 1) {
          v1.setFromMatrixPosition(camera.matrixWorld);
          v2.setFromMatrixPosition(this.matrixWorld);
          var distance = v1.distanceTo(v2);
          levels[0].object.visible = true;
          for (var i = 1,
              l = levels.length; i < l; i++) {
            if (distance >= levels[i].distance) {
              levels[i - 1].object.visible = false;
              levels[i].object.visible = true;
            } else {
              break;
            }
          }
          for (; i < l; i++) {
            levels[i].object.visible = false;
          }
        }
      };
    }();
    THREE.LOD.prototype.copy = function(source) {
      THREE.Object3D.prototype.copy.call(this, source, false);
      var levels = source.levels;
      for (var i = 0,
          l = levels.length; i < l; i++) {
        var level = levels[i];
        this.addLevel(level.object.clone(), level.distance);
      }
      return this;
    };
    THREE.LOD.prototype.toJSON = function(meta) {
      var data = THREE.Object3D.prototype.toJSON.call(this, meta);
      data.object.levels = [];
      var levels = this.levels;
      for (var i = 0,
          l = levels.length; i < l; i++) {
        var level = levels[i];
        data.object.levels.push({
          object: level.object.uuid,
          distance: level.distance
        });
      }
      return data;
    };
    THREE.Sprite = (function() {
      var indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
      var vertices = new Float32Array([-0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0, -0.5, 0.5, 0]);
      var uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
      var geometry = new THREE.BufferGeometry();
      geometry.setIndex(new THREE.BufferAttribute(indices, 1));
      geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
      geometry.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
      return function Sprite(material) {
        THREE.Object3D.call(this);
        this.type = 'Sprite';
        this.geometry = geometry;
        this.material = (material !== undefined) ? material : new THREE.SpriteMaterial();
      };
    })();
    THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Sprite.prototype.constructor = THREE.Sprite;
    THREE.Sprite.prototype.raycast = (function() {
      var matrixPosition = new THREE.Vector3();
      return function raycast(raycaster, intersects) {
        matrixPosition.setFromMatrixPosition(this.matrixWorld);
        var distanceSq = raycaster.ray.distanceSqToPoint(matrixPosition);
        var guessSizeSq = this.scale.x * this.scale.y;
        if (distanceSq > guessSizeSq) {
          return;
        }
        intersects.push({
          distance: Math.sqrt(distanceSq),
          point: this.position,
          face: null,
          object: this
        });
      };
    }());
    THREE.Sprite.prototype.clone = function() {
      return new this.constructor(this.material).copy(this);
    };
    THREE.Particle = THREE.Sprite;
    THREE.LensFlare = function(texture, size, distance, blending, color) {
      THREE.Object3D.call(this);
      this.lensFlares = [];
      this.positionScreen = new THREE.Vector3();
      this.customUpdateCallback = undefined;
      if (texture !== undefined) {
        this.add(texture, size, distance, blending, color);
      }
    };
    THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype);
    THREE.LensFlare.prototype.constructor = THREE.LensFlare;
    THREE.LensFlare.prototype.add = function(texture, size, distance, blending, color, opacity) {
      if (size === undefined)
        size = -1;
      if (distance === undefined)
        distance = 0;
      if (opacity === undefined)
        opacity = 1;
      if (color === undefined)
        color = new THREE.Color(0xffffff);
      if (blending === undefined)
        blending = THREE.NormalBlending;
      distance = Math.min(distance, Math.max(0, distance));
      this.lensFlares.push({
        texture: texture,
        size: size,
        distance: distance,
        x: 0,
        y: 0,
        z: 0,
        scale: 1,
        rotation: 0,
        opacity: opacity,
        color: color,
        blending: blending
      });
    };
    THREE.LensFlare.prototype.updateLensFlares = function() {
      var f,
          fl = this.lensFlares.length;
      var flare;
      var vecX = -this.positionScreen.x * 2;
      var vecY = -this.positionScreen.y * 2;
      for (f = 0; f < fl; f++) {
        flare = this.lensFlares[f];
        flare.x = this.positionScreen.x + vecX * flare.distance;
        flare.y = this.positionScreen.y + vecY * flare.distance;
        flare.wantedRotation = flare.x * Math.PI * 0.25;
        flare.rotation += (flare.wantedRotation - flare.rotation) * 0.25;
      }
    };
    THREE.LensFlare.prototype.copy = function(source) {
      THREE.Object3D.prototype.copy.call(this, source);
      this.positionScreen.copy(source.positionScreen);
      this.customUpdateCallback = source.customUpdateCallback;
      for (var i = 0,
          l = source.lensFlares.length; i < l; i++) {
        this.lensFlares.push(source.lensFlares[i]);
      }
      return this;
    };
    THREE.Scene = function() {
      THREE.Object3D.call(this);
      this.type = 'Scene';
      this.fog = null;
      this.overrideMaterial = null;
      this.autoUpdate = true;
    };
    THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Scene.prototype.constructor = THREE.Scene;
    THREE.Scene.prototype.copy = function(source) {
      THREE.Object3D.prototype.copy.call(this, source);
      if (source.fog !== null)
        this.fog = source.fog.clone();
      if (source.overrideMaterial !== null)
        this.overrideMaterial = source.overrideMaterial.clone();
      this.autoUpdate = source.autoUpdate;
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      return this;
    };
    THREE.Fog = function(color, near, far) {
      this.name = '';
      this.color = new THREE.Color(color);
      this.near = (near !== undefined) ? near : 1;
      this.far = (far !== undefined) ? far : 1000;
    };
    THREE.Fog.prototype.clone = function() {
      return new THREE.Fog(this.color.getHex(), this.near, this.far);
    };
    THREE.FogExp2 = function(color, density) {
      this.name = '';
      this.color = new THREE.Color(color);
      this.density = (density !== undefined) ? density : 0.00025;
    };
    THREE.FogExp2.prototype.clone = function() {
      return new THREE.FogExp2(this.color.getHex(), this.density);
    };
    THREE.ShaderChunk = {};
    THREE.ShaderChunk['alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";
    THREE.ShaderChunk['alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";
    THREE.ShaderChunk['alphatest_fragment'] = "#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";
    THREE.ShaderChunk['aomap_fragment'] = "#ifdef USE_AOMAP\n\n	totalAmbientLight *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n";
    THREE.ShaderChunk['aomap_pars_fragment'] = "#ifdef USE_AOMAP\n\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n\n#endif";
    THREE.ShaderChunk['begin_vertex'] = "\nvec3 transformed = vec3( position );\n";
    THREE.ShaderChunk['beginnormal_vertex'] = "\nvec3 objectNormal = vec3( normal );\n";
    THREE.ShaderChunk['bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n";
    THREE.ShaderChunk['color_fragment'] = "#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif";
    THREE.ShaderChunk['color_pars_fragment'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";
    THREE.ShaderChunk['color_pars_vertex'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";
    THREE.ShaderChunk['color_vertex'] = "#ifdef USE_COLOR\n\n	vColor.xyz = color.xyz;\n\n#endif";
    THREE.ShaderChunk['common'] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n\n}\n\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	float distance = dot( planeNormal, point - pointOnPlane );\n\n	return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n\n	if ( decayExponent > 0.0 ) {\n\n	  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n	}\n\n	return 1.0;\n\n}\n\nvec3 F_Schlick( in vec3 specularColor, in float dotLH ) {\n\n\n	float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );\n\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {\n\n\n	return 0.25;\n\n}\n\nfloat D_BlinnPhong( in float shininess, in float dotNH ) {\n\n\n	return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {\n\n	vec3 halfDir = normalize( lightDir + viewDir );\n\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( lightDir, halfDir ) );\n\n	vec3 F = F_Schlick( specularColor, dotLH );\n\n	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n	float D = D_BlinnPhong( shininess, dotNH );\n\n	return F * G * D;\n\n}\n\nvec3 inputToLinear( in vec3 a ) {\n\n	#ifdef GAMMA_INPUT\n\n		return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n\nvec3 linearToOutput( in vec3 a ) {\n\n	#ifdef GAMMA_OUTPUT\n\n		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n";
    THREE.ShaderChunk['defaultnormal_vertex'] = "#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";
    THREE.ShaderChunk['displacementmap_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n";
    THREE.ShaderChunk['displacementmap_pars_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n\n#endif\n";
    THREE.ShaderChunk['emissivemap_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n	emissiveColor.rgb = inputToLinear( emissiveColor.rgb );\n\n	totalEmissiveLight *= emissiveColor.rgb;\n\n#endif\n";
    THREE.ShaderChunk['emissivemap_pars_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	uniform sampler2D emissiveMap;\n\n#endif\n";
    THREE.ShaderChunk['envmap_fragment'] = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	envColor.xyz = inputToLinear( envColor.xyz );\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n";
    THREE.ShaderChunk['envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['fog_fragment'] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";
    THREE.ShaderChunk['fog_pars_fragment'] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";
    THREE.ShaderChunk['hemilight_fragment'] = "#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 lightColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		totalAmbientLight += lightColor;\n\n	}\n\n#endif\n\n";
    THREE.ShaderChunk['lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n	totalAmbientLight += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n#endif\n";
    THREE.ShaderChunk['lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n\n#endif";
    THREE.ShaderChunk['lights_lambert_pars_vertex'] = "#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n";
    THREE.ShaderChunk['lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\nvec3 normal = normalize( transformedNormal );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lVector = pointLightPosition[ i ] - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n\n			float dotProduct = dot( normal, lightDir );\n\n			vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			float hemiDiffuseWeightBack = - 0.5 * dotProduct + 0.5;\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n";
    THREE.ShaderChunk['lights_phong_fragment'] = "vec3 viewDir = normalize( vViewPosition );\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lightPosition = pointLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n\n			float cosineTerm = saturate( dot( normal, lightDir ) );\n\n			totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n\n			vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n			totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * cosineTerm;\n\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * cosineTerm;\n\n	}\n\n#endif\n";
    THREE.ShaderChunk['lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n";
    THREE.ShaderChunk['lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\n#endif\n";
    THREE.ShaderChunk['lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif\n";
    THREE.ShaderChunk['linear_to_gamma_fragment'] = "\n	outgoingLight = linearToOutput( outgoingLight );\n";
    THREE.ShaderChunk['logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";
    THREE.ShaderChunk['logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";
    THREE.ShaderChunk['logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";
    THREE.ShaderChunk['map_fragment'] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n\n	diffuseColor *= texelColor;\n\n#endif\n";
    THREE.ShaderChunk['map_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";
    THREE.ShaderChunk['map_particle_fragment'] = "#ifdef USE_MAP\n\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";
    THREE.ShaderChunk['map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n\n#endif\n";
    THREE.ShaderChunk['morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n";
    THREE.ShaderChunk['morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";
    THREE.ShaderChunk['morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['normal_phong_fragment'] = "#ifndef FLAT_SHADED\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n	#endif\n\n#else\n\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n";
    THREE.ShaderChunk['normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";
    THREE.ShaderChunk['project_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";
    THREE.ShaderChunk['shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n	for ( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		float texelSizeY =  1.0 / shadowMapSize[ i ].y;\n\n		float shadow = 0.0;\n\n#if defined( POINT_LIGHT_SHADOWS )\n\n		bool isPointLight = shadowDarkness[ i ] < 0.0;\n\n		if ( isPointLight ) {\n\n			float realShadowDarkness = abs( shadowDarkness[ i ] );\n\n			vec3 lightToPosition = vShadowCoord[ i ].xyz;\n\n	#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n			vec3 bd3D = normalize( lightToPosition );\n			float dp = length( lightToPosition );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n\n	#if defined( SHADOWMAP_TYPE_PCF )\n			const float Dr = 1.25;\n	#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			const float Dr = 2.25;\n	#endif\n\n			float os = Dr *  2.0 * texelSizeY;\n\n			const vec3 Gsd = vec3( - 1, 0, 1 );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			shadow *= realShadowDarkness * ( 1.0 / 21.0 );\n\n	#else \n			vec3 bd3D = normalize( lightToPosition );\n			float dp = length( lightToPosition );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			shadow *= realShadowDarkness;\n\n	#endif\n\n		} else {\n\n#endif \n			float texelSizeX =  1.0 / shadowMapSize[ i ].x;\n\n			vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n\n			bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n			bool inFrustum = all( inFrustumVec );\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n			bool frustumTest = all( frustumTestVec );\n\n			if ( frustumTest ) {\n\n	#if defined( SHADOWMAP_TYPE_PCF )\n\n\n				/*\n					for ( float y = -1.25; y <= 1.25; y += 1.25 )\n						for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n							vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n							float fDepth = unpackDepth( rgbaDepth );\n							if ( fDepth < shadowCoord.z )\n								shadow += 1.0;\n					}\n					shadow /= 9.0;\n				*/\n\n				shadowCoord.z += shadowBias[ i ];\n\n				const float ShadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = texelSizeX;\n				float yPixelOffset = texelSizeY;\n\n				float dx0 = - 1.25 * xPixelOffset;\n				float dy0 = - 1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				float fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				shadow *= shadowDarkness[ i ];\n\n	#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\n				shadowCoord.z += shadowBias[ i ];\n\n				float xPixelOffset = texelSizeX;\n				float yPixelOffset = texelSizeY;\n\n				float dx0 = - 1.0 * xPixelOffset;\n				float dy0 = - 1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[ 0 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[ 0 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[ 0 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[ 1 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[ 1 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[ 1 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[ 2 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[ 2 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[ 2 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[ 0 ] = vec3( lessThan( depthKernel[ 0 ], shadowZ ) );\n				shadowKernel[ 0 ] *= vec3( 0.25 );\n\n				shadowKernel[ 1 ] = vec3( lessThan( depthKernel[ 1 ], shadowZ ) );\n				shadowKernel[ 1 ] *= vec3( 0.25 );\n\n				shadowKernel[ 2 ] = vec3( lessThan( depthKernel[ 2 ], shadowZ ) );\n				shadowKernel[ 2 ] *= vec3( 0.25 );\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[ i ].xy );\n\n				shadowKernel[ 0 ] = mix( shadowKernel[ 1 ], shadowKernel[ 0 ], fractionalCoord.x );\n				shadowKernel[ 1 ] = mix( shadowKernel[ 2 ], shadowKernel[ 1 ], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[ 0 ][ 1 ], shadowKernel[ 0 ][ 0 ], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[ 0 ][ 2 ], shadowKernel[ 0 ][ 1 ], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[ 1 ][ 1 ], shadowKernel[ 1 ][ 0 ], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[ 1 ][ 2 ], shadowKernel[ 1 ][ 1 ], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) ) * shadowDarkness[ i ];\n\n	#else \n				shadowCoord.z += shadowBias[ i ];\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n					shadow = shadowDarkness[ i ];\n\n	#endif\n\n			}\n\n#ifdef SHADOWMAP_DEBUG\n\n			if ( inFrustum ) {\n\n				if ( i == 0 ) {\n\n					outgoingLight *= vec3( 1.0, 0.5, 0.0 );\n\n				} else if ( i == 1 ) {\n\n					outgoingLight *= vec3( 0.0, 1.0, 0.8 );\n\n				} else {\n\n					outgoingLight *= vec3( 0.0, 0.5, 1.0 );\n\n				}\n\n			}\n\n#endif\n\n#if defined( POINT_LIGHT_SHADOWS )\n\n		}\n\n#endif\n\n		shadowMask = shadowMask * vec3( 1.0 - shadow );\n\n	}\n\n#endif\n";
    THREE.ShaderChunk['shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n	#if defined(POINT_LIGHT_SHADOWS)\n\n\n		void adjustShadowValue1K( const float testDepth, const vec4 textureData, const float bias, inout float shadowValue ) {\n\n			const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n			if ( testDepth >= dot( textureData, bitSh ) * 1000.0 + bias )\n				shadowValue += 1.0;\n\n		}\n\n\n		vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\n			vec3 absV = abs( v );\n\n\n			float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n			absV *= scaleToCube;\n\n\n			v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\n\n			vec2 planar = v.xy;\n\n			float almostATexel = 1.5 * texelSizeY;\n			float almostOne = 1.0 - almostATexel;\n\n			if ( absV.z >= almostOne ) {\n\n				if ( v.z > 0.0 )\n					planar.x = 4.0 - v.x;\n\n			} else if ( absV.x >= almostOne ) {\n\n				float signX = sign( v.x );\n				planar.x = v.z * signX + 2.0 * signX;\n\n			} else if ( absV.y >= almostOne ) {\n\n				float signY = sign( v.y );\n				planar.x = v.x + 2.0 * signY + 2.0;\n				planar.y = v.z * signY - 2.0;\n\n			}\n\n\n			return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n		}\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n#endif";
    THREE.ShaderChunk['shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n	for ( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n			vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif";
    THREE.ShaderChunk['skinbase_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";
    THREE.ShaderChunk['skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['skinning_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";
    THREE.ShaderChunk['skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n";
    THREE.ShaderChunk['specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";
    THREE.ShaderChunk['specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";
    THREE.ShaderChunk['uv2_pars_fragment'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	varying vec2 vUv2;\n\n#endif";
    THREE.ShaderChunk['uv2_pars_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n\n#endif";
    THREE.ShaderChunk['uv2_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	vUv2 = uv2;\n\n#endif";
    THREE.ShaderChunk['uv_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n\n#endif";
    THREE.ShaderChunk['uv_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";
    THREE.ShaderChunk['uv_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";
    THREE.ShaderChunk['worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n	#endif\n\n#endif\n";
    THREE.UniformsUtils = {
      merge: function(uniforms) {
        var merged = {};
        for (var u = 0; u < uniforms.length; u++) {
          var tmp = this.clone(uniforms[u]);
          for (var p in tmp) {
            merged[p] = tmp[p];
          }
        }
        return merged;
      },
      clone: function(uniforms_src) {
        var uniforms_dst = {};
        for (var u in uniforms_src) {
          uniforms_dst[u] = {};
          for (var p in uniforms_src[u]) {
            var parameter_src = uniforms_src[u][p];
            if (parameter_src instanceof THREE.Color || parameter_src instanceof THREE.Vector2 || parameter_src instanceof THREE.Vector3 || parameter_src instanceof THREE.Vector4 || parameter_src instanceof THREE.Matrix3 || parameter_src instanceof THREE.Matrix4 || parameter_src instanceof THREE.Texture) {
              uniforms_dst[u][p] = parameter_src.clone();
            } else if (Array.isArray(parameter_src)) {
              uniforms_dst[u][p] = parameter_src.slice();
            } else {
              uniforms_dst[u][p] = parameter_src;
            }
          }
        }
        return uniforms_dst;
      }
    };
    THREE.UniformsLib = {
      common: {
        "diffuse": {
          type: "c",
          value: new THREE.Color(0xeeeeee)
        },
        "opacity": {
          type: "f",
          value: 1.0
        },
        "map": {
          type: "t",
          value: null
        },
        "offsetRepeat": {
          type: "v4",
          value: new THREE.Vector4(0, 0, 1, 1)
        },
        "specularMap": {
          type: "t",
          value: null
        },
        "alphaMap": {
          type: "t",
          value: null
        },
        "envMap": {
          type: "t",
          value: null
        },
        "flipEnvMap": {
          type: "f",
          value: -1
        },
        "reflectivity": {
          type: "f",
          value: 1.0
        },
        "refractionRatio": {
          type: "f",
          value: 0.98
        }
      },
      aomap: {
        "aoMap": {
          type: "t",
          value: null
        },
        "aoMapIntensity": {
          type: "f",
          value: 1
        }
      },
      lightmap: {
        "lightMap": {
          type: "t",
          value: null
        },
        "lightMapIntensity": {
          type: "f",
          value: 1
        }
      },
      emissivemap: {"emissiveMap": {
          type: "t",
          value: null
        }},
      bumpmap: {
        "bumpMap": {
          type: "t",
          value: null
        },
        "bumpScale": {
          type: "f",
          value: 1
        }
      },
      normalmap: {
        "normalMap": {
          type: "t",
          value: null
        },
        "normalScale": {
          type: "v2",
          value: new THREE.Vector2(1, 1)
        }
      },
      displacementmap: {
        "displacementMap": {
          type: "t",
          value: null
        },
        "displacementScale": {
          type: "f",
          value: 1
        },
        "displacementBias": {
          type: "f",
          value: 0
        }
      },
      fog: {
        "fogDensity": {
          type: "f",
          value: 0.00025
        },
        "fogNear": {
          type: "f",
          value: 1
        },
        "fogFar": {
          type: "f",
          value: 2000
        },
        "fogColor": {
          type: "c",
          value: new THREE.Color(0xffffff)
        }
      },
      lights: {
        "ambientLightColor": {
          type: "fv",
          value: []
        },
        "directionalLightDirection": {
          type: "fv",
          value: []
        },
        "directionalLightColor": {
          type: "fv",
          value: []
        },
        "hemisphereLightDirection": {
          type: "fv",
          value: []
        },
        "hemisphereLightSkyColor": {
          type: "fv",
          value: []
        },
        "hemisphereLightGroundColor": {
          type: "fv",
          value: []
        },
        "pointLightColor": {
          type: "fv",
          value: []
        },
        "pointLightPosition": {
          type: "fv",
          value: []
        },
        "pointLightDistance": {
          type: "fv1",
          value: []
        },
        "pointLightDecay": {
          type: "fv1",
          value: []
        },
        "spotLightColor": {
          type: "fv",
          value: []
        },
        "spotLightPosition": {
          type: "fv",
          value: []
        },
        "spotLightDirection": {
          type: "fv",
          value: []
        },
        "spotLightDistance": {
          type: "fv1",
          value: []
        },
        "spotLightAngleCos": {
          type: "fv1",
          value: []
        },
        "spotLightExponent": {
          type: "fv1",
          value: []
        },
        "spotLightDecay": {
          type: "fv1",
          value: []
        }
      },
      points: {
        "psColor": {
          type: "c",
          value: new THREE.Color(0xeeeeee)
        },
        "opacity": {
          type: "f",
          value: 1.0
        },
        "size": {
          type: "f",
          value: 1.0
        },
        "scale": {
          type: "f",
          value: 1.0
        },
        "map": {
          type: "t",
          value: null
        },
        "offsetRepeat": {
          type: "v4",
          value: new THREE.Vector4(0, 0, 1, 1)
        },
        "fogDensity": {
          type: "f",
          value: 0.00025
        },
        "fogNear": {
          type: "f",
          value: 1
        },
        "fogFar": {
          type: "f",
          value: 2000
        },
        "fogColor": {
          type: "c",
          value: new THREE.Color(0xffffff)
        }
      },
      shadowmap: {
        "shadowMap": {
          type: "tv",
          value: []
        },
        "shadowMapSize": {
          type: "v2v",
          value: []
        },
        "shadowBias": {
          type: "fv1",
          value: []
        },
        "shadowDarkness": {
          type: "fv1",
          value: []
        },
        "shadowMatrix": {
          type: "m4v",
          value: []
        }
      }
    };
    THREE.ShaderLib = {
      'basic': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["common"], THREE.UniformsLib["aomap"], THREE.UniformsLib["fog"], THREE.UniformsLib["shadowmap"]]),
        vertexShader: [THREE.ShaderChunk["common"], THREE.ShaderChunk["uv_pars_vertex"], THREE.ShaderChunk["uv2_pars_vertex"], THREE.ShaderChunk["envmap_pars_vertex"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["uv_vertex"], THREE.ShaderChunk["uv2_vertex"], THREE.ShaderChunk["color_vertex"], THREE.ShaderChunk["skinbase_vertex"], "	#ifdef USE_ENVMAP", THREE.ShaderChunk["beginnormal_vertex"], THREE.ShaderChunk["morphnormal_vertex"], THREE.ShaderChunk["skinnormal_vertex"], THREE.ShaderChunk["defaultnormal_vertex"], "	#endif", THREE.ShaderChunk["begin_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["project_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["envmap_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["uv_pars_fragment"], THREE.ShaderChunk["uv2_pars_fragment"], THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["alphamap_pars_fragment"], THREE.ShaderChunk["aomap_pars_fragment"], THREE.ShaderChunk["envmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["specularmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", "	vec3 totalAmbientLight = vec3( 1.0 );", "	vec3 shadowMask = vec3( 1.0 );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphamap_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], THREE.ShaderChunk["aomap_fragment"], THREE.ShaderChunk["shadowmap_fragment"], "	outgoingLight = diffuseColor.rgb * totalAmbientLight * shadowMask;", THREE.ShaderChunk["envmap_fragment"], THREE.ShaderChunk["linear_to_gamma_fragment"], THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
      },
      'lambert': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["common"], THREE.UniformsLib["fog"], THREE.UniformsLib["lights"], THREE.UniformsLib["shadowmap"], {"emissive": {
            type: "c",
            value: new THREE.Color(0x000000)
          }}]),
        vertexShader: ["#define LAMBERT", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "#endif", THREE.ShaderChunk["common"], THREE.ShaderChunk["uv_pars_vertex"], THREE.ShaderChunk["uv2_pars_vertex"], THREE.ShaderChunk["envmap_pars_vertex"], THREE.ShaderChunk["lights_lambert_pars_vertex"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["uv_vertex"], THREE.ShaderChunk["uv2_vertex"], THREE.ShaderChunk["color_vertex"], THREE.ShaderChunk["beginnormal_vertex"], THREE.ShaderChunk["morphnormal_vertex"], THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["skinnormal_vertex"], THREE.ShaderChunk["defaultnormal_vertex"], THREE.ShaderChunk["begin_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["project_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["envmap_vertex"], THREE.ShaderChunk["lights_lambert_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform float opacity;", "uniform vec3 ambientLightColor;", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "#endif", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["uv_pars_fragment"], THREE.ShaderChunk["uv2_pars_fragment"], THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["alphamap_pars_fragment"], THREE.ShaderChunk["envmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["specularmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", "	vec3 totalAmbientLight = ambientLightColor;", "	vec3 shadowMask = vec3( 1.0 );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphamap_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], THREE.ShaderChunk["shadowmap_fragment"], "	#ifdef DOUBLE_SIDED", "		if ( gl_FrontFacing )", "			outgoingLight += diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + emissive;", "		else", "			outgoingLight += diffuseColor.rgb * ( vLightBack * shadowMask + totalAmbientLight ) + emissive;", "	#else", "		outgoingLight += diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + emissive;", "	#endif", THREE.ShaderChunk["envmap_fragment"], THREE.ShaderChunk["linear_to_gamma_fragment"], THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
      },
      'phong': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["common"], THREE.UniformsLib["aomap"], THREE.UniformsLib["lightmap"], THREE.UniformsLib["emissivemap"], THREE.UniformsLib["bumpmap"], THREE.UniformsLib["normalmap"], THREE.UniformsLib["displacementmap"], THREE.UniformsLib["fog"], THREE.UniformsLib["lights"], THREE.UniformsLib["shadowmap"], {
          "emissive": {
            type: "c",
            value: new THREE.Color(0x000000)
          },
          "specular": {
            type: "c",
            value: new THREE.Color(0x111111)
          },
          "shininess": {
            type: "f",
            value: 30
          }
        }]),
        vertexShader: ["#define PHONG", "varying vec3 vViewPosition;", "#ifndef FLAT_SHADED", "	varying vec3 vNormal;", "#endif", THREE.ShaderChunk["common"], THREE.ShaderChunk["uv_pars_vertex"], THREE.ShaderChunk["uv2_pars_vertex"], THREE.ShaderChunk["displacementmap_pars_vertex"], THREE.ShaderChunk["envmap_pars_vertex"], THREE.ShaderChunk["lights_phong_pars_vertex"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["uv_vertex"], THREE.ShaderChunk["uv2_vertex"], THREE.ShaderChunk["color_vertex"], THREE.ShaderChunk["beginnormal_vertex"], THREE.ShaderChunk["morphnormal_vertex"], THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["skinnormal_vertex"], THREE.ShaderChunk["defaultnormal_vertex"], "#ifndef FLAT_SHADED", "	vNormal = normalize( transformedNormal );", "#endif", THREE.ShaderChunk["begin_vertex"], THREE.ShaderChunk["displacementmap_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["project_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "	vViewPosition = - mvPosition.xyz;", THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["envmap_vertex"], THREE.ShaderChunk["lights_phong_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n"),
        fragmentShader: ["#define PHONG", "uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform vec3 specular;", "uniform float shininess;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["uv_pars_fragment"], THREE.ShaderChunk["uv2_pars_fragment"], THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["alphamap_pars_fragment"], THREE.ShaderChunk["aomap_pars_fragment"], THREE.ShaderChunk["lightmap_pars_fragment"], THREE.ShaderChunk["emissivemap_pars_fragment"], THREE.ShaderChunk["envmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["lights_phong_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["bumpmap_pars_fragment"], THREE.ShaderChunk["normalmap_pars_fragment"], THREE.ShaderChunk["specularmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", "	vec3 totalAmbientLight = ambientLightColor;", "	vec3 totalEmissiveLight = emissive;", "	vec3 shadowMask = vec3( 1.0 );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphamap_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], THREE.ShaderChunk["normal_phong_fragment"], THREE.ShaderChunk["lightmap_fragment"], THREE.ShaderChunk["hemilight_fragment"], THREE.ShaderChunk["aomap_fragment"], THREE.ShaderChunk["emissivemap_fragment"], THREE.ShaderChunk["lights_phong_fragment"], THREE.ShaderChunk["shadowmap_fragment"], "totalDiffuseLight *= shadowMask;", "totalSpecularLight *= shadowMask;", "#ifdef METAL", "	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) * specular + totalSpecularLight + totalEmissiveLight;", "#else", "	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) + totalSpecularLight + totalEmissiveLight;", "#endif", THREE.ShaderChunk["envmap_fragment"], THREE.ShaderChunk["linear_to_gamma_fragment"], THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
      },
      'points': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["points"], THREE.UniformsLib["shadowmap"]]),
        vertexShader: ["uniform float size;", "uniform float scale;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["color_vertex"], "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	#ifdef USE_SIZEATTENUATION", "		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );", "	#else", "		gl_PointSize = size;", "	#endif", "	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk["logdepthbuf_vertex"], THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform vec3 psColor;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["map_particle_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( psColor, opacity );", "	vec3 shadowMask = vec3( 1.0 );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_particle_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["shadowmap_fragment"], "	outgoingLight = diffuseColor.rgb * shadowMask;", THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
      },
      'dashed': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["common"], THREE.UniformsLib["fog"], {
          "scale": {
            type: "f",
            value: 1
          },
          "dashSize": {
            type: "f",
            value: 1
          },
          "totalSize": {
            type: "f",
            value: 2
          }
        }]),
        vertexShader: ["uniform float scale;", "attribute float lineDistance;", "varying float vLineDistance;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["color_vertex"], "	vLineDistance = scale * lineDistance;", "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", "uniform float dashSize;", "uniform float totalSize;", "varying float vLineDistance;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	if ( mod( vLineDistance, totalSize ) > dashSize ) {", "		discard;", "	}", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["color_fragment"], "	outgoingLight = diffuseColor.rgb;", THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
      },
      'depth': {
        uniforms: {
          "mNear": {
            type: "f",
            value: 1.0
          },
          "mFar": {
            type: "f",
            value: 2000.0
          },
          "opacity": {
            type: "f",
            value: 1.0
          }
        },
        vertexShader: [THREE.ShaderChunk["common"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["begin_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["project_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform float mNear;", "uniform float mFar;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", THREE.ShaderChunk["logdepthbuf_fragment"], "	#ifdef USE_LOGDEPTHBUF_EXT", "		float depth = gl_FragDepthEXT / gl_FragCoord.w;", "	#else", "		float depth = gl_FragCoord.z / gl_FragCoord.w;", "	#endif", "	float color = 1.0 - smoothstep( mNear, mFar, depth );", "	gl_FragColor = vec4( vec3( color ), opacity );", "}"].join("\n")
      },
      'normal': {
        uniforms: {"opacity": {
            type: "f",
            value: 1.0
          }},
        vertexShader: ["varying vec3 vNormal;", THREE.ShaderChunk["common"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", "	vNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk["begin_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["project_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform float opacity;", "varying vec3 vNormal;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], "}"].join("\n")
      },
      'cube': {
        uniforms: {
          "tCube": {
            type: "t",
            value: null
          },
          "tFlip": {
            type: "f",
            value: -1
          }
        },
        vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", "	vWorldPosition = transformDirection( position, modelMatrix );", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform samplerCube tCube;", "uniform float tFlip;", "varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );", THREE.ShaderChunk["logdepthbuf_fragment"], "}"].join("\n")
      },
      'equirect': {
        uniforms: {
          "tEquirect": {
            type: "t",
            value: null
          },
          "tFlip": {
            type: "f",
            value: -1
          }
        },
        vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", "	vWorldPosition = transformDirection( position, modelMatrix );", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform sampler2D tEquirect;", "uniform float tFlip;", "varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "vec3 direction = normalize( vWorldPosition );", "vec2 sampleUV;", "sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );", "sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;", "gl_FragColor = texture2D( tEquirect, sampleUV );", THREE.ShaderChunk["logdepthbuf_fragment"], "}"].join("\n")
      },
      'depthRGBA': {
        uniforms: {},
        vertexShader: [THREE.ShaderChunk["common"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["begin_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["project_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: [THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "vec4 pack_depth( const in float depth ) {", "	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );", "	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );", "	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", "	res -= res.xxyz * bit_mask;", "	return res;", "}", "void main() {", THREE.ShaderChunk["logdepthbuf_fragment"], "	#ifdef USE_LOGDEPTHBUF_EXT", "		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );", "	#else", "		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );", "	#endif", "}"].join("\n")
      },
      'distanceRGBA': {
        uniforms: {"lightPos": {
            type: "v3",
            value: new THREE.Vector3(0, 0, 0)
          }},
        vertexShader: ["varying vec4 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], "void main() {", THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["begin_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["project_vertex"], THREE.ShaderChunk["worldpos_vertex"], "vWorldPosition = worldPosition;", "}"].join("\n"),
        fragmentShader: ["uniform vec3 lightPos;", "varying vec4 vWorldPosition;", THREE.ShaderChunk["common"], "vec4 pack1K ( float depth ) {", "   depth /= 1000.0;", "   const vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );", "	const vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );", "	vec4 res = fract( depth * bitSh );", "	res -= res.xxyz * bitMsk;", "	return res; ", "}", "float unpack1K ( vec4 color ) {", "	const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );", "	return dot( color, bitSh ) * 1000.0;", "}", "void main () {", "	gl_FragColor = pack1K( length( vWorldPosition.xyz - lightPos.xyz ) );", "}"].join("\n")
      }
    };
    THREE.WebGLRenderer = function(parameters) {
      console.log('THREE.WebGLRenderer', THREE.REVISION);
      parameters = parameters || {};
      var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement('canvas'),
          _context = parameters.context !== undefined ? parameters.context : null,
          _width = _canvas.width,
          _height = _canvas.height,
          pixelRatio = 1,
          _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
          _depth = parameters.depth !== undefined ? parameters.depth : true,
          _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
          _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
          _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
          _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
          _clearColor = new THREE.Color(0x000000),
          _clearAlpha = 0;
      var lights = [];
      var opaqueObjects = [];
      var opaqueObjectsLastIndex = -1;
      var transparentObjects = [];
      var transparentObjectsLastIndex = -1;
      var morphInfluences = new Float32Array(8);
      var sprites = [];
      var lensFlares = [];
      this.domElement = _canvas;
      this.context = null;
      this.autoClear = true;
      this.autoClearColor = true;
      this.autoClearDepth = true;
      this.autoClearStencil = true;
      this.sortObjects = true;
      this.gammaFactor = 2.0;
      this.gammaInput = false;
      this.gammaOutput = false;
      this.maxMorphTargets = 8;
      this.maxMorphNormals = 4;
      this.autoScaleCubemaps = true;
      var _this = this,
          _currentProgram = null,
          _currentFramebuffer = null,
          _currentMaterialId = -1,
          _currentGeometryProgram = '',
          _currentCamera = null,
          _usedTextureUnits = 0,
          _viewportX = 0,
          _viewportY = 0,
          _viewportWidth = _canvas.width,
          _viewportHeight = _canvas.height,
          _currentWidth = 0,
          _currentHeight = 0,
          _frustum = new THREE.Frustum(),
          _projScreenMatrix = new THREE.Matrix4(),
          _vector3 = new THREE.Vector3(),
          _direction = new THREE.Vector3(),
          _lightsNeedUpdate = true,
          _lights = {
            ambient: [0, 0, 0],
            directional: {
              length: 0,
              colors: [],
              positions: []
            },
            point: {
              length: 0,
              colors: [],
              positions: [],
              distances: [],
              decays: []
            },
            spot: {
              length: 0,
              colors: [],
              positions: [],
              distances: [],
              directions: [],
              anglesCos: [],
              exponents: [],
              decays: []
            },
            hemi: {
              length: 0,
              skyColors: [],
              groundColors: [],
              positions: []
            }
          },
          _infoMemory = {
            geometries: 0,
            textures: 0
          },
          _infoRender = {
            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0
          };
      this.info = {
        render: _infoRender,
        memory: _infoMemory,
        programs: null
      };
      var _gl;
      try {
        var attributes = {
          alpha: _alpha,
          depth: _depth,
          stencil: _stencil,
          antialias: _antialias,
          premultipliedAlpha: _premultipliedAlpha,
          preserveDrawingBuffer: _preserveDrawingBuffer
        };
        _gl = _context || _canvas.getContext('webgl', attributes) || _canvas.getContext('experimental-webgl', attributes);
        if (_gl === null) {
          if (_canvas.getContext('webgl') !== null) {
            throw 'Error creating WebGL context with your selected attributes.';
          } else {
            throw 'Error creating WebGL context.';
          }
        }
        _canvas.addEventListener('webglcontextlost', onContextLost, false);
      } catch (error) {
        console.error('THREE.WebGLRenderer: ' + error);
      }
      var extensions = new THREE.WebGLExtensions(_gl);
      extensions.get('OES_texture_float');
      extensions.get('OES_texture_float_linear');
      extensions.get('OES_texture_half_float');
      extensions.get('OES_texture_half_float_linear');
      extensions.get('OES_standard_derivatives');
      extensions.get('ANGLE_instanced_arrays');
      if (extensions.get('OES_element_index_uint')) {
        THREE.BufferGeometry.MaxIndex = 4294967296;
      }
      var capabilities = new THREE.WebGLCapabilities(_gl, extensions, parameters);
      var state = new THREE.WebGLState(_gl, extensions, paramThreeToGL);
      var properties = new THREE.WebGLProperties();
      var objects = new THREE.WebGLObjects(_gl, properties, this.info);
      var programCache = new THREE.WebGLPrograms(this, capabilities);
      this.info.programs = programCache.programs;
      var bufferRenderer = new THREE.WebGLBufferRenderer(_gl, extensions, _infoRender);
      var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer(_gl, extensions, _infoRender);
      function glClearColor(r, g, b, a) {
        if (_premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }
        _gl.clearColor(r, g, b, a);
      }
      function setDefaultGLState() {
        state.init();
        _gl.viewport(_viewportX, _viewportY, _viewportWidth, _viewportHeight);
        glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
      }
      function resetGLState() {
        _currentProgram = null;
        _currentCamera = null;
        _currentGeometryProgram = '';
        _currentMaterialId = -1;
        _lightsNeedUpdate = true;
        state.reset();
      }
      setDefaultGLState();
      this.context = _gl;
      this.capabilities = capabilities;
      this.extensions = extensions;
      this.state = state;
      var shadowMap = new THREE.WebGLShadowMap(this, lights, objects);
      this.shadowMap = shadowMap;
      var spritePlugin = new THREE.SpritePlugin(this, sprites);
      var lensFlarePlugin = new THREE.LensFlarePlugin(this, lensFlares);
      this.getContext = function() {
        return _gl;
      };
      this.getContextAttributes = function() {
        return _gl.getContextAttributes();
      };
      this.forceContextLoss = function() {
        extensions.get('WEBGL_lose_context').loseContext();
      };
      this.getMaxAnisotropy = (function() {
        var value;
        return function getMaxAnisotropy() {
          if (value !== undefined)
            return value;
          var extension = extensions.get('EXT_texture_filter_anisotropic');
          if (extension !== null) {
            value = _gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else {
            value = 0;
          }
          return value;
        };
      })();
      this.getPrecision = function() {
        return capabilities.precision;
      };
      this.getPixelRatio = function() {
        return pixelRatio;
      };
      this.setPixelRatio = function(value) {
        if (value !== undefined)
          pixelRatio = value;
      };
      this.getSize = function() {
        return {
          width: _width,
          height: _height
        };
      };
      this.setSize = function(width, height, updateStyle) {
        _width = width;
        _height = height;
        _canvas.width = width * pixelRatio;
        _canvas.height = height * pixelRatio;
        if (updateStyle !== false) {
          _canvas.style.width = width + 'px';
          _canvas.style.height = height + 'px';
        }
        this.setViewport(0, 0, width, height);
      };
      this.setViewport = function(x, y, width, height) {
        _viewportX = x * pixelRatio;
        _viewportY = y * pixelRatio;
        _viewportWidth = width * pixelRatio;
        _viewportHeight = height * pixelRatio;
        _gl.viewport(_viewportX, _viewportY, _viewportWidth, _viewportHeight);
      };
      this.getViewport = function(dimensions) {
        dimensions.x = _viewportX / pixelRatio;
        dimensions.y = _viewportY / pixelRatio;
        dimensions.z = _viewportWidth / pixelRatio;
        dimensions.w = _viewportHeight / pixelRatio;
      };
      this.setScissor = function(x, y, width, height) {
        _gl.scissor(x * pixelRatio, y * pixelRatio, width * pixelRatio, height * pixelRatio);
      };
      this.enableScissorTest = function(boolean) {
        state.setScissorTest(boolean);
      };
      this.getClearColor = function() {
        return _clearColor;
      };
      this.setClearColor = function(color, alpha) {
        _clearColor.set(color);
        _clearAlpha = alpha !== undefined ? alpha : 1;
        glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
      };
      this.getClearAlpha = function() {
        return _clearAlpha;
      };
      this.setClearAlpha = function(alpha) {
        _clearAlpha = alpha;
        glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
      };
      this.clear = function(color, depth, stencil) {
        var bits = 0;
        if (color === undefined || color)
          bits |= _gl.COLOR_BUFFER_BIT;
        if (depth === undefined || depth)
          bits |= _gl.DEPTH_BUFFER_BIT;
        if (stencil === undefined || stencil)
          bits |= _gl.STENCIL_BUFFER_BIT;
        _gl.clear(bits);
      };
      this.clearColor = function() {
        _gl.clear(_gl.COLOR_BUFFER_BIT);
      };
      this.clearDepth = function() {
        _gl.clear(_gl.DEPTH_BUFFER_BIT);
      };
      this.clearStencil = function() {
        _gl.clear(_gl.STENCIL_BUFFER_BIT);
      };
      this.clearTarget = function(renderTarget, color, depth, stencil) {
        this.setRenderTarget(renderTarget);
        this.clear(color, depth, stencil);
      };
      this.resetGLState = resetGLState;
      this.dispose = function() {
        _canvas.removeEventListener('webglcontextlost', onContextLost, false);
      };
      function onContextLost(event) {
        event.preventDefault();
        resetGLState();
        setDefaultGLState();
        properties.clear();
      }
      ;
      function onTextureDispose(event) {
        var texture = event.target;
        texture.removeEventListener('dispose', onTextureDispose);
        deallocateTexture(texture);
        _infoMemory.textures--;
      }
      function onRenderTargetDispose(event) {
        var renderTarget = event.target;
        renderTarget.removeEventListener('dispose', onRenderTargetDispose);
        deallocateRenderTarget(renderTarget);
        _infoMemory.textures--;
      }
      function onMaterialDispose(event) {
        var material = event.target;
        material.removeEventListener('dispose', onMaterialDispose);
        deallocateMaterial(material);
      }
      function deallocateTexture(texture) {
        var textureProperties = properties.get(texture);
        if (texture.image && textureProperties.__image__webglTextureCube) {
          _gl.deleteTexture(textureProperties.__image__webglTextureCube);
        } else {
          if (textureProperties.__webglInit === undefined)
            return;
          _gl.deleteTexture(textureProperties.__webglTexture);
        }
        properties.delete(texture);
      }
      function deallocateRenderTarget(renderTarget) {
        var renderTargetProperties = properties.get(renderTarget);
        var textureProperties = properties.get(renderTarget.texture);
        if (!renderTarget || textureProperties.__webglTexture === undefined)
          return;
        _gl.deleteTexture(textureProperties.__webglTexture);
        if (renderTarget instanceof THREE.WebGLRenderTargetCube) {
          for (var i = 0; i < 6; i++) {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
            _gl.deleteRenderbuffer(renderTargetProperties.__webglRenderbuffer[i]);
          }
        } else {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
          _gl.deleteRenderbuffer(renderTargetProperties.__webglRenderbuffer);
        }
        properties.delete(renderTarget.texture);
        properties.delete(renderTarget);
      }
      function deallocateMaterial(material) {
        releaseMaterialProgramReference(material);
        properties.delete(material);
      }
      function releaseMaterialProgramReference(material) {
        var programInfo = properties.get(material).program;
        material.program = undefined;
        if (programInfo !== undefined) {
          programCache.releaseProgram(programInfo);
        }
      }
      this.renderBufferImmediate = function(object, program, material) {
        state.initAttributes();
        var buffers = properties.get(object);
        if (object.hasPositions && !buffers.position)
          buffers.position = _gl.createBuffer();
        if (object.hasNormals && !buffers.normal)
          buffers.normal = _gl.createBuffer();
        if (object.hasUvs && !buffers.uv)
          buffers.uv = _gl.createBuffer();
        if (object.hasColors && !buffers.color)
          buffers.color = _gl.createBuffer();
        var attributes = program.getAttributes();
        if (object.hasPositions) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
          _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
          state.enableAttribute(attributes.position);
          _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasNormals) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);
          if (material.type !== 'MeshPhongMaterial' && material.shading === THREE.FlatShading) {
            for (var i = 0,
                l = object.count * 3; i < l; i += 9) {
              var array = object.normalArray;
              var nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3;
              var ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3;
              var nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;
              array[i + 0] = nx;
              array[i + 1] = ny;
              array[i + 2] = nz;
              array[i + 3] = nx;
              array[i + 4] = ny;
              array[i + 5] = nz;
              array[i + 6] = nx;
              array[i + 7] = ny;
              array[i + 8] = nz;
            }
          }
          _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
          state.enableAttribute(attributes.normal);
          _gl.vertexAttribPointer(attributes.normal, 3, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasUvs && material.map) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
          _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
          state.enableAttribute(attributes.uv);
          _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasColors && material.vertexColors !== THREE.NoColors) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
          _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
          state.enableAttribute(attributes.color);
          _gl.vertexAttribPointer(attributes.color, 3, _gl.FLOAT, false, 0, 0);
        }
        state.disableUnusedAttributes();
        _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
        object.count = 0;
      };
      this.renderBufferDirect = function(camera, lights, fog, geometry, material, object, group) {
        setMaterial(material);
        var program = setProgram(camera, lights, fog, material, object);
        var updateBuffers = false;
        var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;
        if (geometryProgram !== _currentGeometryProgram) {
          _currentGeometryProgram = geometryProgram;
          updateBuffers = true;
        }
        var morphTargetInfluences = object.morphTargetInfluences;
        if (morphTargetInfluences !== undefined) {
          var activeInfluences = [];
          for (var i = 0,
              l = morphTargetInfluences.length; i < l; i++) {
            var influence = morphTargetInfluences[i];
            activeInfluences.push([influence, i]);
          }
          activeInfluences.sort(numericalSort);
          if (activeInfluences.length > 8) {
            activeInfluences.length = 8;
          }
          var morphAttributes = geometry.morphAttributes;
          for (var i = 0,
              l = activeInfluences.length; i < l; i++) {
            var influence = activeInfluences[i];
            morphInfluences[i] = influence[0];
            if (influence[0] !== 0) {
              var index = influence[1];
              if (material.morphTargets === true && morphAttributes.position)
                geometry.addAttribute('morphTarget' + i, morphAttributes.position[index]);
              if (material.morphNormals === true && morphAttributes.normal)
                geometry.addAttribute('morphNormal' + i, morphAttributes.normal[index]);
            } else {
              if (material.morphTargets === true)
                geometry.removeAttribute('morphTarget' + i);
              if (material.morphNormals === true)
                geometry.removeAttribute('morphNormal' + i);
            }
          }
          var uniforms = program.getUniforms();
          if (uniforms.morphTargetInfluences !== null) {
            _gl.uniform1fv(uniforms.morphTargetInfluences, morphInfluences);
          }
          updateBuffers = true;
        }
        var index = geometry.index;
        var position = geometry.attributes.position;
        if (material.wireframe === true) {
          index = objects.getWireframeAttribute(geometry);
        }
        var renderer;
        if (index !== null) {
          renderer = indexedBufferRenderer;
          renderer.setIndex(index);
        } else {
          renderer = bufferRenderer;
        }
        if (updateBuffers) {
          setupVertexAttributes(material, program, geometry);
          if (index !== null) {
            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer(index));
          }
        }
        var dataStart = 0;
        var dataCount = Infinity;
        if (index !== null) {
          dataCount = index.count;
        } else if (position !== undefined) {
          dataCount = position.count;
        }
        var rangeStart = geometry.drawRange.start;
        var rangeCount = geometry.drawRange.count;
        var groupStart = group !== null ? group.start : 0;
        var groupCount = group !== null ? group.count : Infinity;
        var drawStart = Math.max(dataStart, rangeStart, groupStart);
        var drawEnd = Math.min(dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
        var drawCount = Math.max(0, drawEnd - drawStart + 1);
        if (object instanceof THREE.Mesh) {
          if (material.wireframe === true) {
            state.setLineWidth(material.wireframeLinewidth * pixelRatio);
            renderer.setMode(_gl.LINES);
          } else {
            renderer.setMode(_gl.TRIANGLES);
          }
          if (geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0) {
            renderer.renderInstances(geometry);
          } else {
            renderer.render(drawStart, drawCount);
          }
        } else if (object instanceof THREE.Line) {
          var lineWidth = material.linewidth;
          if (lineWidth === undefined)
            lineWidth = 1;
          state.setLineWidth(lineWidth * pixelRatio);
          if (object instanceof THREE.LineSegments) {
            renderer.setMode(_gl.LINES);
          } else {
            renderer.setMode(_gl.LINE_STRIP);
          }
          renderer.render(drawStart, drawCount);
        } else if (object instanceof THREE.Points) {
          renderer.setMode(_gl.POINTS);
          renderer.render(drawStart, drawCount);
        }
      };
      function setupVertexAttributes(material, program, geometry, startIndex) {
        var extension;
        if (geometry instanceof THREE.InstancedBufferGeometry) {
          extension = extensions.get('ANGLE_instanced_arrays');
          if (extension === null) {
            console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
            return;
          }
        }
        if (startIndex === undefined)
          startIndex = 0;
        state.initAttributes();
        var geometryAttributes = geometry.attributes;
        var programAttributes = program.getAttributes();
        var materialDefaultAttributeValues = material.defaultAttributeValues;
        for (var name in programAttributes) {
          var programAttribute = programAttributes[name];
          if (programAttribute >= 0) {
            var geometryAttribute = geometryAttributes[name];
            if (geometryAttribute !== undefined) {
              var size = geometryAttribute.itemSize;
              var buffer = objects.getAttributeBuffer(geometryAttribute);
              if (geometryAttribute instanceof THREE.InterleavedBufferAttribute) {
                var data = geometryAttribute.data;
                var stride = data.stride;
                var offset = geometryAttribute.offset;
                if (data instanceof THREE.InstancedInterleavedBuffer) {
                  state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute, extension);
                  if (geometry.maxInstancedCount === undefined) {
                    geometry.maxInstancedCount = data.meshPerAttribute * data.count;
                  }
                } else {
                  state.enableAttribute(programAttribute);
                }
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                _gl.vertexAttribPointer(programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, (startIndex * stride + offset) * data.array.BYTES_PER_ELEMENT);
              } else {
                if (geometryAttribute instanceof THREE.InstancedBufferAttribute) {
                  state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute, extension);
                  if (geometry.maxInstancedCount === undefined) {
                    geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                  }
                } else {
                  state.enableAttribute(programAttribute);
                }
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                _gl.vertexAttribPointer(programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4);
              }
            } else if (materialDefaultAttributeValues !== undefined) {
              var value = materialDefaultAttributeValues[name];
              if (value !== undefined) {
                switch (value.length) {
                  case 2:
                    _gl.vertexAttrib2fv(programAttribute, value);
                    break;
                  case 3:
                    _gl.vertexAttrib3fv(programAttribute, value);
                    break;
                  case 4:
                    _gl.vertexAttrib4fv(programAttribute, value);
                    break;
                  default:
                    _gl.vertexAttrib1fv(programAttribute, value);
                }
              }
            }
          }
        }
        state.disableUnusedAttributes();
      }
      function numericalSort(a, b) {
        return b[0] - a[0];
      }
      function painterSortStable(a, b) {
        if (a.object.renderOrder !== b.object.renderOrder) {
          return a.object.renderOrder - b.object.renderOrder;
        } else if (a.material.id !== b.material.id) {
          return a.material.id - b.material.id;
        } else if (a.z !== b.z) {
          return a.z - b.z;
        } else {
          return a.id - b.id;
        }
      }
      function reversePainterSortStable(a, b) {
        if (a.object.renderOrder !== b.object.renderOrder) {
          return a.object.renderOrder - b.object.renderOrder;
        }
        if (a.z !== b.z) {
          return b.z - a.z;
        } else {
          return a.id - b.id;
        }
      }
      this.render = function(scene, camera, renderTarget, forceClear) {
        if (camera instanceof THREE.Camera === false) {
          console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
          return;
        }
        var fog = scene.fog;
        _currentGeometryProgram = '';
        _currentMaterialId = -1;
        _currentCamera = null;
        _lightsNeedUpdate = true;
        if (scene.autoUpdate === true)
          scene.updateMatrixWorld();
        if (camera.parent === null)
          camera.updateMatrixWorld();
        camera.matrixWorldInverse.getInverse(camera.matrixWorld);
        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        _frustum.setFromMatrix(_projScreenMatrix);
        lights.length = 0;
        opaqueObjectsLastIndex = -1;
        transparentObjectsLastIndex = -1;
        sprites.length = 0;
        lensFlares.length = 0;
        projectObject(scene, camera);
        opaqueObjects.length = opaqueObjectsLastIndex + 1;
        transparentObjects.length = transparentObjectsLastIndex + 1;
        if (_this.sortObjects === true) {
          opaqueObjects.sort(painterSortStable);
          transparentObjects.sort(reversePainterSortStable);
        }
        shadowMap.render(scene);
        _infoRender.calls = 0;
        _infoRender.vertices = 0;
        _infoRender.faces = 0;
        _infoRender.points = 0;
        this.setRenderTarget(renderTarget);
        if (this.autoClear || forceClear) {
          this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
        }
        if (scene.overrideMaterial) {
          var overrideMaterial = scene.overrideMaterial;
          renderObjects(opaqueObjects, camera, lights, fog, overrideMaterial);
          renderObjects(transparentObjects, camera, lights, fog, overrideMaterial);
        } else {
          state.setBlending(THREE.NoBlending);
          renderObjects(opaqueObjects, camera, lights, fog);
          renderObjects(transparentObjects, camera, lights, fog);
        }
        spritePlugin.render(scene, camera);
        lensFlarePlugin.render(scene, camera, _currentWidth, _currentHeight);
        if (renderTarget) {
          var texture = renderTarget.texture;
          var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);
          if (texture.generateMipmaps && isTargetPowerOfTwo && texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter) {
            updateRenderTargetMipmap(renderTarget);
          }
        }
        state.setDepthTest(true);
        state.setDepthWrite(true);
        state.setColorWrite(true);
      };
      function pushRenderItem(object, geometry, material, z, group) {
        var array,
            index;
        if (material.transparent) {
          array = transparentObjects;
          index = ++transparentObjectsLastIndex;
        } else {
          array = opaqueObjects;
          index = ++opaqueObjectsLastIndex;
        }
        var renderItem = array[index];
        if (renderItem !== undefined) {
          renderItem.id = object.id;
          renderItem.object = object;
          renderItem.geometry = geometry;
          renderItem.material = material;
          renderItem.z = _vector3.z;
          renderItem.group = group;
        } else {
          renderItem = {
            id: object.id,
            object: object,
            geometry: geometry,
            material: material,
            z: _vector3.z,
            group: group
          };
          array.push(renderItem);
        }
      }
      function projectObject(object, camera) {
        if (object.visible === false)
          return;
        if ((object.channels.mask & camera.channels.mask) !== 0) {
          if (object instanceof THREE.Light) {
            lights.push(object);
          } else if (object instanceof THREE.Sprite) {
            sprites.push(object);
          } else if (object instanceof THREE.LensFlare) {
            lensFlares.push(object);
          } else if (object instanceof THREE.ImmediateRenderObject) {
            if (_this.sortObjects === true) {
              _vector3.setFromMatrixPosition(object.matrixWorld);
              _vector3.applyProjection(_projScreenMatrix);
            }
            pushRenderItem(object, null, object.material, _vector3.z, null);
          } else if (object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points) {
            if (object instanceof THREE.SkinnedMesh) {
              object.skeleton.update();
            }
            if (object.frustumCulled === false || _frustum.intersectsObject(object) === true) {
              var material = object.material;
              if (material.visible === true) {
                if (_this.sortObjects === true) {
                  _vector3.setFromMatrixPosition(object.matrixWorld);
                  _vector3.applyProjection(_projScreenMatrix);
                }
                var geometry = objects.update(object);
                if (material instanceof THREE.MeshFaceMaterial) {
                  var groups = geometry.groups;
                  var materials = material.materials;
                  for (var i = 0,
                      l = groups.length; i < l; i++) {
                    var group = groups[i];
                    var groupMaterial = materials[group.materialIndex];
                    if (groupMaterial.visible === true) {
                      pushRenderItem(object, geometry, groupMaterial, _vector3.z, group);
                    }
                  }
                } else {
                  pushRenderItem(object, geometry, material, _vector3.z, null);
                }
              }
            }
          }
        }
        var children = object.children;
        for (var i = 0,
            l = children.length; i < l; i++) {
          projectObject(children[i], camera);
        }
      }
      function renderObjects(renderList, camera, lights, fog, overrideMaterial) {
        for (var i = 0,
            l = renderList.length; i < l; i++) {
          var renderItem = renderList[i];
          var object = renderItem.object;
          var geometry = renderItem.geometry;
          var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
          var group = renderItem.group;
          object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
          object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
          if (object instanceof THREE.ImmediateRenderObject) {
            setMaterial(material);
            var program = setProgram(camera, lights, fog, material, object);
            _currentGeometryProgram = '';
            object.render(function(object) {
              _this.renderBufferImmediate(object, program, material);
            });
          } else {
            _this.renderBufferDirect(camera, lights, fog, geometry, material, object, group);
          }
        }
      }
      function initMaterial(material, lights, fog, object) {
        var materialProperties = properties.get(material);
        var parameters = programCache.getParameters(material, lights, fog, object);
        var code = programCache.getProgramCode(material, parameters);
        var program = materialProperties.program;
        var programChange = true;
        if (program === undefined) {
          material.addEventListener('dispose', onMaterialDispose);
        } else if (program.code !== code) {
          releaseMaterialProgramReference(material);
        } else if (parameters.shaderID !== undefined) {
          return;
        } else {
          programChange = false;
        }
        if (programChange) {
          if (parameters.shaderID) {
            var shader = THREE.ShaderLib[parameters.shaderID];
            materialProperties.__webglShader = {
              name: material.type,
              uniforms: THREE.UniformsUtils.clone(shader.uniforms),
              vertexShader: shader.vertexShader,
              fragmentShader: shader.fragmentShader
            };
          } else {
            materialProperties.__webglShader = {
              name: material.type,
              uniforms: material.uniforms,
              vertexShader: material.vertexShader,
              fragmentShader: material.fragmentShader
            };
          }
          material.__webglShader = materialProperties.__webglShader;
          program = programCache.acquireProgram(material, parameters, code);
          materialProperties.program = program;
          material.program = program;
        }
        var attributes = program.getAttributes();
        if (material.morphTargets) {
          material.numSupportedMorphTargets = 0;
          for (var i = 0; i < _this.maxMorphTargets; i++) {
            if (attributes['morphTarget' + i] >= 0) {
              material.numSupportedMorphTargets++;
            }
          }
        }
        if (material.morphNormals) {
          material.numSupportedMorphNormals = 0;
          for (i = 0; i < _this.maxMorphNormals; i++) {
            if (attributes['morphNormal' + i] >= 0) {
              material.numSupportedMorphNormals++;
            }
          }
        }
        materialProperties.uniformsList = [];
        var uniformLocations = materialProperties.program.getUniforms();
        for (var u in materialProperties.__webglShader.uniforms) {
          var location = uniformLocations[u];
          if (location) {
            materialProperties.uniformsList.push([materialProperties.__webglShader.uniforms[u], location]);
          }
        }
      }
      function setMaterial(material) {
        setMaterialFaces(material);
        if (material.transparent === true) {
          state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha);
        } else {
          state.setBlending(THREE.NoBlending);
        }
        state.setDepthFunc(material.depthFunc);
        state.setDepthTest(material.depthTest);
        state.setDepthWrite(material.depthWrite);
        state.setColorWrite(material.colorWrite);
        state.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
      }
      function setMaterialFaces(material) {
        material.side !== THREE.DoubleSide ? state.enable(_gl.CULL_FACE) : state.disable(_gl.CULL_FACE);
        state.setFlipSided(material.side === THREE.BackSide);
      }
      function setProgram(camera, lights, fog, material, object) {
        _usedTextureUnits = 0;
        var materialProperties = properties.get(material);
        if (material.needsUpdate || !materialProperties.program) {
          initMaterial(material, lights, fog, object);
          material.needsUpdate = false;
        }
        var refreshProgram = false;
        var refreshMaterial = false;
        var refreshLights = false;
        var program = materialProperties.program,
            p_uniforms = program.getUniforms(),
            m_uniforms = materialProperties.__webglShader.uniforms;
        if (program.id !== _currentProgram) {
          _gl.useProgram(program.program);
          _currentProgram = program.id;
          refreshProgram = true;
          refreshMaterial = true;
          refreshLights = true;
        }
        if (material.id !== _currentMaterialId) {
          if (_currentMaterialId === -1)
            refreshLights = true;
          _currentMaterialId = material.id;
          refreshMaterial = true;
        }
        if (refreshProgram || camera !== _currentCamera) {
          _gl.uniformMatrix4fv(p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
          if (capabilities.logarithmicDepthBuffer) {
            _gl.uniform1f(p_uniforms.logDepthBufFC, 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
          }
          if (camera !== _currentCamera)
            _currentCamera = camera;
          if (material instanceof THREE.ShaderMaterial || material instanceof THREE.MeshPhongMaterial || material.envMap) {
            if (p_uniforms.cameraPosition !== undefined) {
              _vector3.setFromMatrixPosition(camera.matrixWorld);
              _gl.uniform3f(p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z);
            }
          }
          if (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshBasicMaterial || material instanceof THREE.ShaderMaterial || material.skinning) {
            if (p_uniforms.viewMatrix !== undefined) {
              _gl.uniformMatrix4fv(p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements);
            }
          }
        }
        if (material.skinning) {
          if (object.bindMatrix && p_uniforms.bindMatrix !== undefined) {
            _gl.uniformMatrix4fv(p_uniforms.bindMatrix, false, object.bindMatrix.elements);
          }
          if (object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined) {
            _gl.uniformMatrix4fv(p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements);
          }
          if (capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture) {
            if (p_uniforms.boneTexture !== undefined) {
              var textureUnit = getTextureUnit();
              _gl.uniform1i(p_uniforms.boneTexture, textureUnit);
              _this.setTexture(object.skeleton.boneTexture, textureUnit);
            }
            if (p_uniforms.boneTextureWidth !== undefined) {
              _gl.uniform1i(p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth);
            }
            if (p_uniforms.boneTextureHeight !== undefined) {
              _gl.uniform1i(p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight);
            }
          } else if (object.skeleton && object.skeleton.boneMatrices) {
            if (p_uniforms.boneGlobalMatrices !== undefined) {
              _gl.uniformMatrix4fv(p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices);
            }
          }
        }
        if (refreshMaterial) {
          if (fog && material.fog) {
            refreshUniformsFog(m_uniforms, fog);
          }
          if (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material.lights) {
            if (_lightsNeedUpdate) {
              refreshLights = true;
              setupLights(lights, camera);
              _lightsNeedUpdate = false;
            }
            if (refreshLights) {
              refreshUniformsLights(m_uniforms, _lights);
              markUniformsLightsNeedsUpdate(m_uniforms, true);
            } else {
              markUniformsLightsNeedsUpdate(m_uniforms, false);
            }
          }
          if (material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial) {
            refreshUniformsCommon(m_uniforms, material);
          }
          if (material instanceof THREE.LineBasicMaterial) {
            refreshUniformsLine(m_uniforms, material);
          } else if (material instanceof THREE.LineDashedMaterial) {
            refreshUniformsLine(m_uniforms, material);
            refreshUniformsDash(m_uniforms, material);
          } else if (material instanceof THREE.PointsMaterial) {
            refreshUniformsParticle(m_uniforms, material);
          } else if (material instanceof THREE.MeshPhongMaterial) {
            refreshUniformsPhong(m_uniforms, material);
          } else if (material instanceof THREE.MeshDepthMaterial) {
            m_uniforms.mNear.value = camera.near;
            m_uniforms.mFar.value = camera.far;
            m_uniforms.opacity.value = material.opacity;
          } else if (material instanceof THREE.MeshNormalMaterial) {
            m_uniforms.opacity.value = material.opacity;
          }
          if (object.receiveShadow && !material._shadowPass) {
            refreshUniformsShadow(m_uniforms, lights, camera);
          }
          loadUniformsGeneric(materialProperties.uniformsList);
        }
        loadUniformsMatrices(p_uniforms, object);
        if (p_uniforms.modelMatrix !== undefined) {
          _gl.uniformMatrix4fv(p_uniforms.modelMatrix, false, object.matrixWorld.elements);
        }
        return program;
      }
      function refreshUniformsCommon(uniforms, material) {
        uniforms.opacity.value = material.opacity;
        uniforms.diffuse.value = material.color;
        if (material.emissive) {
          uniforms.emissive.value = material.emissive;
        }
        uniforms.map.value = material.map;
        uniforms.specularMap.value = material.specularMap;
        uniforms.alphaMap.value = material.alphaMap;
        if (material.aoMap) {
          uniforms.aoMap.value = material.aoMap;
          uniforms.aoMapIntensity.value = material.aoMapIntensity;
        }
        var uvScaleMap;
        if (material.map) {
          uvScaleMap = material.map;
        } else if (material.specularMap) {
          uvScaleMap = material.specularMap;
        } else if (material.displacementMap) {
          uvScaleMap = material.displacementMap;
        } else if (material.normalMap) {
          uvScaleMap = material.normalMap;
        } else if (material.bumpMap) {
          uvScaleMap = material.bumpMap;
        } else if (material.alphaMap) {
          uvScaleMap = material.alphaMap;
        } else if (material.emissiveMap) {
          uvScaleMap = material.emissiveMap;
        }
        if (uvScaleMap !== undefined) {
          if (uvScaleMap instanceof THREE.WebGLRenderTarget)
            uvScaleMap = uvScaleMap.texture;
          var offset = uvScaleMap.offset;
          var repeat = uvScaleMap.repeat;
          uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
        }
        uniforms.envMap.value = material.envMap;
        uniforms.flipEnvMap.value = (material.envMap instanceof THREE.WebGLRenderTargetCube) ? 1 : -1;
        uniforms.reflectivity.value = material.reflectivity;
        uniforms.refractionRatio.value = material.refractionRatio;
      }
      function refreshUniformsLine(uniforms, material) {
        uniforms.diffuse.value = material.color;
        uniforms.opacity.value = material.opacity;
      }
      function refreshUniformsDash(uniforms, material) {
        uniforms.dashSize.value = material.dashSize;
        uniforms.totalSize.value = material.dashSize + material.gapSize;
        uniforms.scale.value = material.scale;
      }
      function refreshUniformsParticle(uniforms, material) {
        uniforms.psColor.value = material.color;
        uniforms.opacity.value = material.opacity;
        uniforms.size.value = material.size;
        uniforms.scale.value = _canvas.height / 2.0;
        uniforms.map.value = material.map;
        if (material.map !== null) {
          var offset = material.map.offset;
          var repeat = material.map.repeat;
          uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
        }
      }
      function refreshUniformsFog(uniforms, fog) {
        uniforms.fogColor.value = fog.color;
        if (fog instanceof THREE.Fog) {
          uniforms.fogNear.value = fog.near;
          uniforms.fogFar.value = fog.far;
        } else if (fog instanceof THREE.FogExp2) {
          uniforms.fogDensity.value = fog.density;
        }
      }
      function refreshUniformsPhong(uniforms, material) {
        uniforms.specular.value = material.specular;
        uniforms.shininess.value = Math.max(material.shininess, 1e-4);
        if (material.lightMap) {
          uniforms.lightMap.value = material.lightMap;
          uniforms.lightMapIntensity.value = material.lightMapIntensity;
        }
        if (material.emissiveMap) {
          uniforms.emissiveMap.value = material.emissiveMap;
        }
        if (material.bumpMap) {
          uniforms.bumpMap.value = material.bumpMap;
          uniforms.bumpScale.value = material.bumpScale;
        }
        if (material.normalMap) {
          uniforms.normalMap.value = material.normalMap;
          uniforms.normalScale.value.copy(material.normalScale);
        }
        if (material.displacementMap) {
          uniforms.displacementMap.value = material.displacementMap;
          uniforms.displacementScale.value = material.displacementScale;
          uniforms.displacementBias.value = material.displacementBias;
        }
      }
      function refreshUniformsLights(uniforms, lights) {
        uniforms.ambientLightColor.value = lights.ambient;
        uniforms.directionalLightColor.value = lights.directional.colors;
        uniforms.directionalLightDirection.value = lights.directional.positions;
        uniforms.pointLightColor.value = lights.point.colors;
        uniforms.pointLightPosition.value = lights.point.positions;
        uniforms.pointLightDistance.value = lights.point.distances;
        uniforms.pointLightDecay.value = lights.point.decays;
        uniforms.spotLightColor.value = lights.spot.colors;
        uniforms.spotLightPosition.value = lights.spot.positions;
        uniforms.spotLightDistance.value = lights.spot.distances;
        uniforms.spotLightDirection.value = lights.spot.directions;
        uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
        uniforms.spotLightExponent.value = lights.spot.exponents;
        uniforms.spotLightDecay.value = lights.spot.decays;
        uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
        uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
        uniforms.hemisphereLightDirection.value = lights.hemi.positions;
      }
      function markUniformsLightsNeedsUpdate(uniforms, value) {
        uniforms.ambientLightColor.needsUpdate = value;
        uniforms.directionalLightColor.needsUpdate = value;
        uniforms.directionalLightDirection.needsUpdate = value;
        uniforms.pointLightColor.needsUpdate = value;
        uniforms.pointLightPosition.needsUpdate = value;
        uniforms.pointLightDistance.needsUpdate = value;
        uniforms.pointLightDecay.needsUpdate = value;
        uniforms.spotLightColor.needsUpdate = value;
        uniforms.spotLightPosition.needsUpdate = value;
        uniforms.spotLightDistance.needsUpdate = value;
        uniforms.spotLightDirection.needsUpdate = value;
        uniforms.spotLightAngleCos.needsUpdate = value;
        uniforms.spotLightExponent.needsUpdate = value;
        uniforms.spotLightDecay.needsUpdate = value;
        uniforms.hemisphereLightSkyColor.needsUpdate = value;
        uniforms.hemisphereLightGroundColor.needsUpdate = value;
        uniforms.hemisphereLightDirection.needsUpdate = value;
      }
      function refreshUniformsShadow(uniforms, lights, camera) {
        if (uniforms.shadowMatrix) {
          var j = 0;
          for (var i = 0,
              il = lights.length; i < il; i++) {
            var light = lights[i];
            if (light.castShadow === true) {
              if (light instanceof THREE.PointLight || light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight) {
                var shadow = light.shadow;
                if (light instanceof THREE.PointLight) {
                  _vector3.setFromMatrixPosition(light.matrixWorld).negate();
                  shadow.matrix.identity().setPosition(_vector3);
                  uniforms.shadowDarkness.value[j] = -shadow.darkness;
                } else {
                  uniforms.shadowDarkness.value[j] = shadow.darkness;
                }
                uniforms.shadowMatrix.value[j] = shadow.matrix;
                uniforms.shadowMap.value[j] = shadow.map;
                uniforms.shadowMapSize.value[j] = shadow.mapSize;
                uniforms.shadowBias.value[j] = shadow.bias;
                j++;
              }
            }
          }
        }
      }
      function loadUniformsMatrices(uniforms, object) {
        _gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, object.modelViewMatrix.elements);
        if (uniforms.normalMatrix) {
          _gl.uniformMatrix3fv(uniforms.normalMatrix, false, object.normalMatrix.elements);
        }
      }
      function getTextureUnit() {
        var textureUnit = _usedTextureUnits;
        if (textureUnit >= capabilities.maxTextures) {
          console.warn('WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures);
        }
        _usedTextureUnits += 1;
        return textureUnit;
      }
      function loadUniformsGeneric(uniforms) {
        var texture,
            textureUnit;
        for (var j = 0,
            jl = uniforms.length; j < jl; j++) {
          var uniform = uniforms[j][0];
          if (uniform.needsUpdate === false)
            continue;
          var type = uniform.type;
          var value = uniform.value;
          var location = uniforms[j][1];
          switch (type) {
            case '1i':
              _gl.uniform1i(location, value);
              break;
            case '1f':
              _gl.uniform1f(location, value);
              break;
            case '2f':
              _gl.uniform2f(location, value[0], value[1]);
              break;
            case '3f':
              _gl.uniform3f(location, value[0], value[1], value[2]);
              break;
            case '4f':
              _gl.uniform4f(location, value[0], value[1], value[2], value[3]);
              break;
            case '1iv':
              _gl.uniform1iv(location, value);
              break;
            case '3iv':
              _gl.uniform3iv(location, value);
              break;
            case '1fv':
              _gl.uniform1fv(location, value);
              break;
            case '2fv':
              _gl.uniform2fv(location, value);
              break;
            case '3fv':
              _gl.uniform3fv(location, value);
              break;
            case '4fv':
              _gl.uniform4fv(location, value);
              break;
            case 'Matrix3fv':
              _gl.uniformMatrix3fv(location, false, value);
              break;
            case 'Matrix4fv':
              _gl.uniformMatrix4fv(location, false, value);
              break;
            case 'i':
              _gl.uniform1i(location, value);
              break;
            case 'f':
              _gl.uniform1f(location, value);
              break;
            case 'v2':
              _gl.uniform2f(location, value.x, value.y);
              break;
            case 'v3':
              _gl.uniform3f(location, value.x, value.y, value.z);
              break;
            case 'v4':
              _gl.uniform4f(location, value.x, value.y, value.z, value.w);
              break;
            case 'c':
              _gl.uniform3f(location, value.r, value.g, value.b);
              break;
            case 'iv1':
              _gl.uniform1iv(location, value);
              break;
            case 'iv':
              _gl.uniform3iv(location, value);
              break;
            case 'fv1':
              _gl.uniform1fv(location, value);
              break;
            case 'fv':
              _gl.uniform3fv(location, value);
              break;
            case 'v2v':
              if (uniform._array === undefined) {
                uniform._array = new Float32Array(2 * value.length);
              }
              for (var i = 0,
                  i2 = 0,
                  il = value.length; i < il; i++, i2 += 2) {
                uniform._array[i2 + 0] = value[i].x;
                uniform._array[i2 + 1] = value[i].y;
              }
              _gl.uniform2fv(location, uniform._array);
              break;
            case 'v3v':
              if (uniform._array === undefined) {
                uniform._array = new Float32Array(3 * value.length);
              }
              for (var i = 0,
                  i3 = 0,
                  il = value.length; i < il; i++, i3 += 3) {
                uniform._array[i3 + 0] = value[i].x;
                uniform._array[i3 + 1] = value[i].y;
                uniform._array[i3 + 2] = value[i].z;
              }
              _gl.uniform3fv(location, uniform._array);
              break;
            case 'v4v':
              if (uniform._array === undefined) {
                uniform._array = new Float32Array(4 * value.length);
              }
              for (var i = 0,
                  i4 = 0,
                  il = value.length; i < il; i++, i4 += 4) {
                uniform._array[i4 + 0] = value[i].x;
                uniform._array[i4 + 1] = value[i].y;
                uniform._array[i4 + 2] = value[i].z;
                uniform._array[i4 + 3] = value[i].w;
              }
              _gl.uniform4fv(location, uniform._array);
              break;
            case 'm3':
              _gl.uniformMatrix3fv(location, false, value.elements);
              break;
            case 'm3v':
              if (uniform._array === undefined) {
                uniform._array = new Float32Array(9 * value.length);
              }
              for (var i = 0,
                  il = value.length; i < il; i++) {
                value[i].flattenToArrayOffset(uniform._array, i * 9);
              }
              _gl.uniformMatrix3fv(location, false, uniform._array);
              break;
            case 'm4':
              _gl.uniformMatrix4fv(location, false, value.elements);
              break;
            case 'm4v':
              if (uniform._array === undefined) {
                uniform._array = new Float32Array(16 * value.length);
              }
              for (var i = 0,
                  il = value.length; i < il; i++) {
                value[i].flattenToArrayOffset(uniform._array, i * 16);
              }
              _gl.uniformMatrix4fv(location, false, uniform._array);
              break;
            case 't':
              texture = value;
              textureUnit = getTextureUnit();
              _gl.uniform1i(location, textureUnit);
              if (!texture)
                continue;
              if (texture instanceof THREE.CubeTexture || (Array.isArray(texture.image) && texture.image.length === 6)) {
                setCubeTexture(texture, textureUnit);
              } else if (texture instanceof THREE.WebGLRenderTargetCube) {
                setCubeTextureDynamic(texture.texture, textureUnit);
              } else if (texture instanceof THREE.WebGLRenderTarget) {
                _this.setTexture(texture.texture, textureUnit);
              } else {
                _this.setTexture(texture, textureUnit);
              }
              break;
            case 'tv':
              if (uniform._array === undefined) {
                uniform._array = [];
              }
              for (var i = 0,
                  il = uniform.value.length; i < il; i++) {
                uniform._array[i] = getTextureUnit();
              }
              _gl.uniform1iv(location, uniform._array);
              for (var i = 0,
                  il = uniform.value.length; i < il; i++) {
                texture = uniform.value[i];
                textureUnit = uniform._array[i];
                if (!texture)
                  continue;
                if (texture instanceof THREE.CubeTexture || (texture.image instanceof Array && texture.image.length === 6)) {
                  setCubeTexture(texture, textureUnit);
                } else if (texture instanceof THREE.WebGLRenderTarget) {
                  _this.setTexture(texture.texture, textureUnit);
                } else if (texture instanceof THREE.WebGLRenderTargetCube) {
                  setCubeTextureDynamic(texture.texture, textureUnit);
                } else {
                  _this.setTexture(texture, textureUnit);
                }
              }
              break;
            default:
              console.warn('THREE.WebGLRenderer: Unknown uniform type: ' + type);
          }
        }
      }
      function setColorLinear(array, offset, color, intensity) {
        array[offset + 0] = color.r * intensity;
        array[offset + 1] = color.g * intensity;
        array[offset + 2] = color.b * intensity;
      }
      function setupLights(lights, camera) {
        var l,
            ll,
            light,
            r = 0,
            g = 0,
            b = 0,
            color,
            skyColor,
            groundColor,
            intensity,
            distance,
            zlights = _lights,
            viewMatrix = camera.matrixWorldInverse,
            dirColors = zlights.directional.colors,
            dirPositions = zlights.directional.positions,
            pointColors = zlights.point.colors,
            pointPositions = zlights.point.positions,
            pointDistances = zlights.point.distances,
            pointDecays = zlights.point.decays,
            spotColors = zlights.spot.colors,
            spotPositions = zlights.spot.positions,
            spotDistances = zlights.spot.distances,
            spotDirections = zlights.spot.directions,
            spotAnglesCos = zlights.spot.anglesCos,
            spotExponents = zlights.spot.exponents,
            spotDecays = zlights.spot.decays,
            hemiSkyColors = zlights.hemi.skyColors,
            hemiGroundColors = zlights.hemi.groundColors,
            hemiPositions = zlights.hemi.positions,
            dirLength = 0,
            pointLength = 0,
            spotLength = 0,
            hemiLength = 0,
            dirCount = 0,
            pointCount = 0,
            spotCount = 0,
            hemiCount = 0,
            dirOffset = 0,
            pointOffset = 0,
            spotOffset = 0,
            hemiOffset = 0;
        for (l = 0, ll = lights.length; l < ll; l++) {
          light = lights[l];
          color = light.color;
          intensity = light.intensity;
          distance = light.distance;
          if (light instanceof THREE.AmbientLight) {
            if (!light.visible)
              continue;
            r += color.r;
            g += color.g;
            b += color.b;
          } else if (light instanceof THREE.DirectionalLight) {
            dirCount += 1;
            if (!light.visible)
              continue;
            _direction.setFromMatrixPosition(light.matrixWorld);
            _vector3.setFromMatrixPosition(light.target.matrixWorld);
            _direction.sub(_vector3);
            _direction.transformDirection(viewMatrix);
            dirOffset = dirLength * 3;
            dirPositions[dirOffset + 0] = _direction.x;
            dirPositions[dirOffset + 1] = _direction.y;
            dirPositions[dirOffset + 2] = _direction.z;
            setColorLinear(dirColors, dirOffset, color, intensity);
            dirLength += 1;
          } else if (light instanceof THREE.PointLight) {
            pointCount += 1;
            if (!light.visible)
              continue;
            pointOffset = pointLength * 3;
            setColorLinear(pointColors, pointOffset, color, intensity);
            _vector3.setFromMatrixPosition(light.matrixWorld);
            _vector3.applyMatrix4(viewMatrix);
            pointPositions[pointOffset + 0] = _vector3.x;
            pointPositions[pointOffset + 1] = _vector3.y;
            pointPositions[pointOffset + 2] = _vector3.z;
            pointDistances[pointLength] = distance;
            pointDecays[pointLength] = (light.distance === 0) ? 0.0 : light.decay;
            pointLength += 1;
          } else if (light instanceof THREE.SpotLight) {
            spotCount += 1;
            if (!light.visible)
              continue;
            spotOffset = spotLength * 3;
            setColorLinear(spotColors, spotOffset, color, intensity);
            _direction.setFromMatrixPosition(light.matrixWorld);
            _vector3.copy(_direction).applyMatrix4(viewMatrix);
            spotPositions[spotOffset + 0] = _vector3.x;
            spotPositions[spotOffset + 1] = _vector3.y;
            spotPositions[spotOffset + 2] = _vector3.z;
            spotDistances[spotLength] = distance;
            _vector3.setFromMatrixPosition(light.target.matrixWorld);
            _direction.sub(_vector3);
            _direction.transformDirection(viewMatrix);
            spotDirections[spotOffset + 0] = _direction.x;
            spotDirections[spotOffset + 1] = _direction.y;
            spotDirections[spotOffset + 2] = _direction.z;
            spotAnglesCos[spotLength] = Math.cos(light.angle);
            spotExponents[spotLength] = light.exponent;
            spotDecays[spotLength] = (light.distance === 0) ? 0.0 : light.decay;
            spotLength += 1;
          } else if (light instanceof THREE.HemisphereLight) {
            hemiCount += 1;
            if (!light.visible)
              continue;
            _direction.setFromMatrixPosition(light.matrixWorld);
            _direction.transformDirection(viewMatrix);
            hemiOffset = hemiLength * 3;
            hemiPositions[hemiOffset + 0] = _direction.x;
            hemiPositions[hemiOffset + 1] = _direction.y;
            hemiPositions[hemiOffset + 2] = _direction.z;
            skyColor = light.color;
            groundColor = light.groundColor;
            setColorLinear(hemiSkyColors, hemiOffset, skyColor, intensity);
            setColorLinear(hemiGroundColors, hemiOffset, groundColor, intensity);
            hemiLength += 1;
          }
        }
        for (l = dirLength * 3, ll = Math.max(dirColors.length, dirCount * 3); l < ll; l++)
          dirColors[l] = 0.0;
        for (l = pointLength * 3, ll = Math.max(pointColors.length, pointCount * 3); l < ll; l++)
          pointColors[l] = 0.0;
        for (l = spotLength * 3, ll = Math.max(spotColors.length, spotCount * 3); l < ll; l++)
          spotColors[l] = 0.0;
        for (l = hemiLength * 3, ll = Math.max(hemiSkyColors.length, hemiCount * 3); l < ll; l++)
          hemiSkyColors[l] = 0.0;
        for (l = hemiLength * 3, ll = Math.max(hemiGroundColors.length, hemiCount * 3); l < ll; l++)
          hemiGroundColors[l] = 0.0;
        zlights.directional.length = dirLength;
        zlights.point.length = pointLength;
        zlights.spot.length = spotLength;
        zlights.hemi.length = hemiLength;
        zlights.ambient[0] = r;
        zlights.ambient[1] = g;
        zlights.ambient[2] = b;
      }
      this.setFaceCulling = function(cullFace, frontFaceDirection) {
        if (cullFace === THREE.CullFaceNone) {
          state.disable(_gl.CULL_FACE);
        } else {
          if (frontFaceDirection === THREE.FrontFaceDirectionCW) {
            _gl.frontFace(_gl.CW);
          } else {
            _gl.frontFace(_gl.CCW);
          }
          if (cullFace === THREE.CullFaceBack) {
            _gl.cullFace(_gl.BACK);
          } else if (cullFace === THREE.CullFaceFront) {
            _gl.cullFace(_gl.FRONT);
          } else {
            _gl.cullFace(_gl.FRONT_AND_BACK);
          }
          state.enable(_gl.CULL_FACE);
        }
      };
      function setTextureParameters(textureType, texture, isImagePowerOfTwo) {
        var extension;
        if (isImagePowerOfTwo) {
          _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL(texture.wrapS));
          _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL(texture.wrapT));
          _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL(texture.magFilter));
          _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL(texture.minFilter));
        } else {
          _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
          _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
          if (texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping) {
            console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture);
          }
          _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
          _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
          if (texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter) {
            console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture);
          }
        }
        extension = extensions.get('EXT_texture_filter_anisotropic');
        if (extension) {
          if (texture.type === THREE.FloatType && extensions.get('OES_texture_float_linear') === null)
            return;
          if (texture.type === THREE.HalfFloatType && extensions.get('OES_texture_half_float_linear') === null)
            return;
          if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
            _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, _this.getMaxAnisotropy()));
            properties.get(texture).__currentAnisotropy = texture.anisotropy;
          }
        }
      }
      function uploadTexture(textureProperties, texture, slot) {
        if (textureProperties.__webglInit === undefined) {
          textureProperties.__webglInit = true;
          texture.addEventListener('dispose', onTextureDispose);
          textureProperties.__webglTexture = _gl.createTexture();
          _infoMemory.textures++;
        }
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
        texture.image = clampToMaxSize(texture.image, capabilities.maxTextureSize);
        if (textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false) {
          texture.image = makePowerOfTwo(texture.image);
        }
        var image = texture.image,
            isImagePowerOfTwo = isPowerOfTwo(image),
            glFormat = paramThreeToGL(texture.format),
            glType = paramThreeToGL(texture.type);
        setTextureParameters(_gl.TEXTURE_2D, texture, isImagePowerOfTwo);
        var mipmap,
            mipmaps = texture.mipmaps;
        if (texture instanceof THREE.DataTexture) {
          if (mipmaps.length > 0 && isImagePowerOfTwo) {
            for (var i = 0,
                il = mipmaps.length; i < il; i++) {
              mipmap = mipmaps[i];
              state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
            texture.generateMipmaps = false;
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
          }
        } else if (texture instanceof THREE.CompressedTexture) {
          for (var i = 0,
              il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat) {
              if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                state.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
        } else {
          if (mipmaps.length > 0 && isImagePowerOfTwo) {
            for (var i = 0,
                il = mipmaps.length; i < il; i++) {
              mipmap = mipmaps[i];
              state.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
            }
            texture.generateMipmaps = false;
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image);
          }
        }
        if (texture.generateMipmaps && isImagePowerOfTwo)
          _gl.generateMipmap(_gl.TEXTURE_2D);
        textureProperties.__version = texture.version;
        if (texture.onUpdate)
          texture.onUpdate(texture);
      }
      this.setTexture = function(texture, slot) {
        var textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
          var image = texture.image;
          if (image === undefined) {
            console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined', texture);
            return;
          }
          if (image.complete === false) {
            console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture);
            return;
          }
          uploadTexture(textureProperties, texture, slot);
          return;
        }
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
      };
      function clampToMaxSize(image, maxSize) {
        if (image.width > maxSize || image.height > maxSize) {
          var scale = maxSize / Math.max(image.width, image.height);
          var canvas = document.createElement('canvas');
          canvas.width = Math.floor(image.width * scale);
          canvas.height = Math.floor(image.height * scale);
          var context = canvas.getContext('2d');
          context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
          console.warn('THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
          return canvas;
        }
        return image;
      }
      function isPowerOfTwo(image) {
        return THREE.Math.isPowerOfTwo(image.width) && THREE.Math.isPowerOfTwo(image.height);
      }
      function textureNeedsPowerOfTwo(texture) {
        if (texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping)
          return true;
        if (texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter)
          return true;
        return false;
      }
      function makePowerOfTwo(image) {
        if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement) {
          var canvas = document.createElement('canvas');
          canvas.width = THREE.Math.nearestPowerOfTwo(image.width);
          canvas.height = THREE.Math.nearestPowerOfTwo(image.height);
          var context = canvas.getContext('2d');
          context.drawImage(image, 0, 0, canvas.width, canvas.height);
          console.warn('THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
          return canvas;
        }
        return image;
      }
      function setCubeTexture(texture, slot) {
        var textureProperties = properties.get(texture);
        if (texture.image.length === 6) {
          if (texture.version > 0 && textureProperties.__version !== texture.version) {
            if (!textureProperties.__image__webglTextureCube) {
              texture.addEventListener('dispose', onTextureDispose);
              textureProperties.__image__webglTextureCube = _gl.createTexture();
              _infoMemory.textures++;
            }
            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
            var isCompressed = texture instanceof THREE.CompressedTexture;
            var isDataTexture = texture.image[0] instanceof THREE.DataTexture;
            var cubeImage = [];
            for (var i = 0; i < 6; i++) {
              if (_this.autoScaleCubemaps && !isCompressed && !isDataTexture) {
                cubeImage[i] = clampToMaxSize(texture.image[i], capabilities.maxCubemapSize);
              } else {
                cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
              }
            }
            var image = cubeImage[0],
                isImagePowerOfTwo = isPowerOfTwo(image),
                glFormat = paramThreeToGL(texture.format),
                glType = paramThreeToGL(texture.type);
            setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo);
            for (var i = 0; i < 6; i++) {
              if (!isCompressed) {
                if (isDataTexture) {
                  state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
                } else {
                  state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
                }
              } else {
                var mipmap,
                    mipmaps = cubeImage[i].mipmaps;
                for (var j = 0,
                    jl = mipmaps.length; j < jl; j++) {
                  mipmap = mipmaps[j];
                  if (texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat) {
                    if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                      state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                    } else {
                      console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()");
                    }
                  } else {
                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                  }
                }
              }
            }
            if (texture.generateMipmaps && isImagePowerOfTwo) {
              _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
            }
            textureProperties.__version = texture.version;
            if (texture.onUpdate)
              texture.onUpdate(texture);
          } else {
            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
          }
        }
      }
      function setCubeTextureDynamic(texture, slot) {
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);
      }
      function setupFrameBuffer(framebuffer, renderTarget, textureTarget) {
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
      }
      function setupRenderBuffer(renderbuffer, renderTarget) {
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
        if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
        } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
        } else {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);
        }
      }
      this.setRenderTarget = function(renderTarget) {
        var isCube = (renderTarget instanceof THREE.WebGLRenderTargetCube);
        if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
          var renderTargetProperties = properties.get(renderTarget);
          var textureProperties = properties.get(renderTarget.texture);
          if (renderTarget.depthBuffer === undefined)
            renderTarget.depthBuffer = true;
          if (renderTarget.stencilBuffer === undefined)
            renderTarget.stencilBuffer = true;
          renderTarget.addEventListener('dispose', onRenderTargetDispose);
          textureProperties.__webglTexture = _gl.createTexture();
          _infoMemory.textures++;
          var isTargetPowerOfTwo = isPowerOfTwo(renderTarget),
              glFormat = paramThreeToGL(renderTarget.texture.format),
              glType = paramThreeToGL(renderTarget.texture.type);
          if (isCube) {
            renderTargetProperties.__webglFramebuffer = [];
            renderTargetProperties.__webglRenderbuffer = [];
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
            setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);
            for (var i = 0; i < 6; i++) {
              renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
              renderTargetProperties.__webglRenderbuffer[i] = _gl.createRenderbuffer();
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
              setupFrameBuffer(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
              setupRenderBuffer(renderTargetProperties.__webglRenderbuffer[i], renderTarget);
            }
            if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo)
              _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
          } else {
            renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
            if (renderTarget.shareDepthFrom) {
              renderTargetProperties.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;
            } else {
              renderTargetProperties.__webglRenderbuffer = _gl.createRenderbuffer();
            }
            state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
            setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo);
            state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
            setupFrameBuffer(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D);
            if (renderTarget.shareDepthFrom) {
              if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer);
              } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer);
              }
            } else {
              setupRenderBuffer(renderTargetProperties.__webglRenderbuffer, renderTarget);
            }
            if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo)
              _gl.generateMipmap(_gl.TEXTURE_2D);
          }
          if (isCube) {
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
          } else {
            state.bindTexture(_gl.TEXTURE_2D, null);
          }
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
        var framebuffer,
            width,
            height,
            vx,
            vy;
        if (renderTarget) {
          var renderTargetProperties = properties.get(renderTarget);
          if (isCube) {
            framebuffer = renderTargetProperties.__webglFramebuffer[renderTarget.activeCubeFace];
          } else {
            framebuffer = renderTargetProperties.__webglFramebuffer;
          }
          width = renderTarget.width;
          height = renderTarget.height;
          vx = 0;
          vy = 0;
        } else {
          framebuffer = null;
          width = _viewportWidth;
          height = _viewportHeight;
          vx = _viewportX;
          vy = _viewportY;
        }
        if (framebuffer !== _currentFramebuffer) {
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          _gl.viewport(vx, vy, width, height);
          _currentFramebuffer = framebuffer;
        }
        if (isCube) {
          var textureProperties = properties.get(renderTarget.texture);
          _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, 0);
        }
        _currentWidth = width;
        _currentHeight = height;
      };
      this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer) {
        if (renderTarget instanceof THREE.WebGLRenderTarget === false) {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
          return;
        }
        var framebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (framebuffer) {
          var restore = false;
          if (framebuffer !== _currentFramebuffer) {
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            restore = true;
          }
          try {
            var texture = renderTarget.texture;
            if (texture.format !== THREE.RGBAFormat && paramThreeToGL(texture.format) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
              console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
              return;
            }
            if (texture.type !== THREE.UnsignedByteType && paramThreeToGL(texture.type) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && !(texture.type === THREE.FloatType && extensions.get('WEBGL_color_buffer_float')) && !(texture.type === THREE.HalfFloatType && extensions.get('EXT_color_buffer_half_float'))) {
              console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
              return;
            }
            if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
              _gl.readPixels(x, y, width, height, paramThreeToGL(texture.format), paramThreeToGL(texture.type), buffer);
            } else {
              console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
            }
          } finally {
            if (restore) {
              _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
            }
          }
        }
      };
      function updateRenderTargetMipmap(renderTarget) {
        var target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
        var texture = properties.get(renderTarget.texture).__webglTexture;
        state.bindTexture(target, texture);
        _gl.generateMipmap(target);
        state.bindTexture(target, null);
      }
      function filterFallback(f) {
        if (f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter) {
          return _gl.NEAREST;
        }
        return _gl.LINEAR;
      }
      function paramThreeToGL(p) {
        var extension;
        if (p === THREE.RepeatWrapping)
          return _gl.REPEAT;
        if (p === THREE.ClampToEdgeWrapping)
          return _gl.CLAMP_TO_EDGE;
        if (p === THREE.MirroredRepeatWrapping)
          return _gl.MIRRORED_REPEAT;
        if (p === THREE.NearestFilter)
          return _gl.NEAREST;
        if (p === THREE.NearestMipMapNearestFilter)
          return _gl.NEAREST_MIPMAP_NEAREST;
        if (p === THREE.NearestMipMapLinearFilter)
          return _gl.NEAREST_MIPMAP_LINEAR;
        if (p === THREE.LinearFilter)
          return _gl.LINEAR;
        if (p === THREE.LinearMipMapNearestFilter)
          return _gl.LINEAR_MIPMAP_NEAREST;
        if (p === THREE.LinearMipMapLinearFilter)
          return _gl.LINEAR_MIPMAP_LINEAR;
        if (p === THREE.UnsignedByteType)
          return _gl.UNSIGNED_BYTE;
        if (p === THREE.UnsignedShort4444Type)
          return _gl.UNSIGNED_SHORT_4_4_4_4;
        if (p === THREE.UnsignedShort5551Type)
          return _gl.UNSIGNED_SHORT_5_5_5_1;
        if (p === THREE.UnsignedShort565Type)
          return _gl.UNSIGNED_SHORT_5_6_5;
        if (p === THREE.ByteType)
          return _gl.BYTE;
        if (p === THREE.ShortType)
          return _gl.SHORT;
        if (p === THREE.UnsignedShortType)
          return _gl.UNSIGNED_SHORT;
        if (p === THREE.IntType)
          return _gl.INT;
        if (p === THREE.UnsignedIntType)
          return _gl.UNSIGNED_INT;
        if (p === THREE.FloatType)
          return _gl.FLOAT;
        extension = extensions.get('OES_texture_half_float');
        if (extension !== null) {
          if (p === THREE.HalfFloatType)
            return extension.HALF_FLOAT_OES;
        }
        if (p === THREE.AlphaFormat)
          return _gl.ALPHA;
        if (p === THREE.RGBFormat)
          return _gl.RGB;
        if (p === THREE.RGBAFormat)
          return _gl.RGBA;
        if (p === THREE.LuminanceFormat)
          return _gl.LUMINANCE;
        if (p === THREE.LuminanceAlphaFormat)
          return _gl.LUMINANCE_ALPHA;
        if (p === THREE.AddEquation)
          return _gl.FUNC_ADD;
        if (p === THREE.SubtractEquation)
          return _gl.FUNC_SUBTRACT;
        if (p === THREE.ReverseSubtractEquation)
          return _gl.FUNC_REVERSE_SUBTRACT;
        if (p === THREE.ZeroFactor)
          return _gl.ZERO;
        if (p === THREE.OneFactor)
          return _gl.ONE;
        if (p === THREE.SrcColorFactor)
          return _gl.SRC_COLOR;
        if (p === THREE.OneMinusSrcColorFactor)
          return _gl.ONE_MINUS_SRC_COLOR;
        if (p === THREE.SrcAlphaFactor)
          return _gl.SRC_ALPHA;
        if (p === THREE.OneMinusSrcAlphaFactor)
          return _gl.ONE_MINUS_SRC_ALPHA;
        if (p === THREE.DstAlphaFactor)
          return _gl.DST_ALPHA;
        if (p === THREE.OneMinusDstAlphaFactor)
          return _gl.ONE_MINUS_DST_ALPHA;
        if (p === THREE.DstColorFactor)
          return _gl.DST_COLOR;
        if (p === THREE.OneMinusDstColorFactor)
          return _gl.ONE_MINUS_DST_COLOR;
        if (p === THREE.SrcAlphaSaturateFactor)
          return _gl.SRC_ALPHA_SATURATE;
        extension = extensions.get('WEBGL_compressed_texture_s3tc');
        if (extension !== null) {
          if (p === THREE.RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p === THREE.RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p === THREE.RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p === THREE.RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        extension = extensions.get('WEBGL_compressed_texture_pvrtc');
        if (extension !== null) {
          if (p === THREE.RGB_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (p === THREE.RGB_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (p === THREE.RGBA_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (p === THREE.RGBA_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        extension = extensions.get('EXT_blend_minmax');
        if (extension !== null) {
          if (p === THREE.MinEquation)
            return extension.MIN_EXT;
          if (p === THREE.MaxEquation)
            return extension.MAX_EXT;
        }
        return 0;
      }
      this.supportsFloatTextures = function() {
        console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
        return extensions.get('OES_texture_float');
      };
      this.supportsHalfFloatTextures = function() {
        console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
        return extensions.get('OES_texture_half_float');
      };
      this.supportsStandardDerivatives = function() {
        console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
        return extensions.get('OES_standard_derivatives');
      };
      this.supportsCompressedTextureS3TC = function() {
        console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
        return extensions.get('WEBGL_compressed_texture_s3tc');
      };
      this.supportsCompressedTexturePVRTC = function() {
        console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
        return extensions.get('WEBGL_compressed_texture_pvrtc');
      };
      this.supportsBlendMinMax = function() {
        console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
        return extensions.get('EXT_blend_minmax');
      };
      this.supportsVertexTextures = function() {
        return capabilities.vertexTextures;
      };
      this.supportsInstancedArrays = function() {
        console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
        return extensions.get('ANGLE_instanced_arrays');
      };
      this.initMaterial = function() {
        console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
      };
      this.addPrePlugin = function() {
        console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
      };
      this.addPostPlugin = function() {
        console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
      };
      this.updateShadowMap = function() {
        console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
      };
      Object.defineProperties(this, {
        shadowMapEnabled: {
          get: function() {
            return shadowMap.enabled;
          },
          set: function(value) {
            console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
            shadowMap.enabled = value;
          }
        },
        shadowMapType: {
          get: function() {
            return shadowMap.type;
          },
          set: function(value) {
            console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
            shadowMap.type = value;
          }
        },
        shadowMapCullFace: {
          get: function() {
            return shadowMap.cullFace;
          },
          set: function(value) {
            console.warn('THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.');
            shadowMap.cullFace = value;
          }
        },
        shadowMapDebug: {
          get: function() {
            return shadowMap.debug;
          },
          set: function(value) {
            console.warn('THREE.WebGLRenderer: .shadowMapDebug is now .shadowMap.debug.');
            shadowMap.debug = value;
          }
        }
      });
    };
    THREE.WebGLRenderTarget = function(width, height, options) {
      this.uuid = THREE.Math.generateUUID();
      this.width = width;
      this.height = height;
      options = options || {};
      if (options.minFilter === undefined)
        options.minFilter = THREE.LinearFilter;
      this.texture = new THREE.Texture(undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy);
      this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
      this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
      this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;
    };
    THREE.WebGLRenderTarget.prototype = {
      constructor: THREE.WebGLRenderTarget,
      get wrapS() {
        console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
        return this.texture.wrapS;
      },
      set wrapS(value) {
        console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
        this.texture.wrapS = value;
      },
      get wrapT() {
        console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
        return this.texture.wrapT;
      },
      set wrapT(value) {
        console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
        this.texture.wrapT = value;
      },
      get magFilter() {
        console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
        return this.texture.magFilter;
      },
      set magFilter(value) {
        console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
        this.texture.magFilter = value;
      },
      get minFilter() {
        console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
        return this.texture.minFilter;
      },
      set minFilter(value) {
        console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
        this.texture.minFilter = value;
      },
      get anisotropy() {
        console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
        return this.texture.anisotropy;
      },
      set anisotropy(value) {
        console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
        this.texture.anisotropy = value;
      },
      get offset() {
        console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
        return this.texture.offset;
      },
      set offset(value) {
        console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
        this.texture.offset = value;
      },
      get repeat() {
        console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
        return this.texture.repeat;
      },
      set repeat(value) {
        console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
        this.texture.repeat = value;
      },
      get format() {
        console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
        return this.texture.format;
      },
      set format(value) {
        console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
        this.texture.format = value;
      },
      get type() {
        console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
        return this.texture.type;
      },
      set type(value) {
        console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
        this.texture.type = value;
      },
      get generateMipmaps() {
        console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
        return this.texture.generateMipmaps;
      },
      set generateMipmaps(value) {
        console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
        this.texture.generateMipmaps = value;
      },
      setSize: function(width, height) {
        if (this.width !== width || this.height !== height) {
          this.width = width;
          this.height = height;
          this.dispose();
        }
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(source) {
        this.width = source.width;
        this.height = source.height;
        this.texture = source.texture.clone();
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        this.shareDepthFrom = source.shareDepthFrom;
        return this;
      },
      dispose: function() {
        this.dispatchEvent({type: 'dispose'});
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);
    THREE.WebGLRenderTargetCube = function(width, height, options) {
      THREE.WebGLRenderTarget.call(this, width, height, options);
      this.activeCubeFace = 0;
    };
    THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype);
    THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;
    THREE.WebGLBufferRenderer = function(_gl, extensions, _infoRender) {
      var mode;
      function setMode(value) {
        mode = value;
      }
      function render(start, count) {
        _gl.drawArrays(mode, start, count);
        _infoRender.calls++;
        _infoRender.vertices += count;
        if (mode === _gl.TRIANGLES)
          _infoRender.faces += count / 3;
      }
      function renderInstances(geometry) {
        var extension = extensions.get('ANGLE_instanced_arrays');
        if (extension === null) {
          console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
          return;
        }
        var position = geometry.attributes.position;
        if (position instanceof THREE.InterleavedBufferAttribute) {
          extension.drawArraysInstancedANGLE(mode, 0, position.data.count, geometry.maxInstancedCount);
        } else {
          extension.drawArraysInstancedANGLE(mode, 0, position.count, geometry.maxInstancedCount);
        }
      }
      this.setMode = setMode;
      this.render = render;
      this.renderInstances = renderInstances;
    };
    THREE.WebGLIndexedBufferRenderer = function(_gl, extensions, _infoRender) {
      var mode;
      function setMode(value) {
        mode = value;
      }
      var type,
          size;
      function setIndex(index) {
        if (index.array instanceof Uint32Array && extensions.get('OES_element_index_uint')) {
          type = _gl.UNSIGNED_INT;
          size = 4;
        } else {
          type = _gl.UNSIGNED_SHORT;
          size = 2;
        }
      }
      function render(start, count) {
        _gl.drawElements(mode, count, type, start * size);
        _infoRender.calls++;
        _infoRender.vertices += count;
        if (mode === _gl.TRIANGLES)
          _infoRender.faces += count / 3;
      }
      function renderInstances(geometry) {
        var extension = extensions.get('ANGLE_instanced_arrays');
        if (extension === null) {
          console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
          return;
        }
        var index = geometry.index;
        extension.drawElementsInstancedANGLE(mode, index.array.length, type, 0, geometry.maxInstancedCount);
      }
      this.setMode = setMode;
      this.setIndex = setIndex;
      this.render = render;
      this.renderInstances = renderInstances;
    };
    THREE.WebGLExtensions = function(gl) {
      var extensions = {};
      this.get = function(name) {
        if (extensions[name] !== undefined) {
          return extensions[name];
        }
        var extension;
        switch (name) {
          case 'EXT_texture_filter_anisotropic':
            extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
            break;
          case 'WEBGL_compressed_texture_s3tc':
            extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
            break;
          case 'WEBGL_compressed_texture_pvrtc':
            extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
            break;
          default:
            extension = gl.getExtension(name);
        }
        if (extension === null) {
          console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
        }
        extensions[name] = extension;
        return extension;
      };
    };
    THREE.WebGLCapabilities = function(gl, extensions, parameters) {
      function getMaxPrecision(precision) {
        if (precision === 'highp') {
          if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
            return 'highp';
          }
          precision = 'mediump';
        }
        if (precision === 'mediump') {
          if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
            return 'mediump';
          }
        }
        return 'lowp';
      }
      this.getMaxPrecision = getMaxPrecision;
      this.precision = parameters.precision !== undefined ? parameters.precision : 'highp', this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;
      this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
      this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
      this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
      this.maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
      this.maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
      this.maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
      this.maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
      this.maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
      this.vertexTextures = this.maxVertexTextures > 0;
      this.floatFragmentTextures = !!extensions.get('OES_texture_float');
      this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;
      var _maxPrecision = getMaxPrecision(this.precision);
      if (_maxPrecision !== this.precision) {
        console.warn('THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.');
        this.precision = _maxPrecision;
      }
      if (this.logarithmicDepthBuffer) {
        this.logarithmicDepthBuffer = !!extensions.get('EXT_frag_depth');
      }
    };
    THREE.WebGLGeometries = function(gl, properties, info) {
      var geometries = {};
      function get(object) {
        var geometry = object.geometry;
        if (geometries[geometry.id] !== undefined) {
          return geometries[geometry.id];
        }
        geometry.addEventListener('dispose', onGeometryDispose);
        var buffergeometry;
        if (geometry instanceof THREE.BufferGeometry) {
          buffergeometry = geometry;
        } else if (geometry instanceof THREE.Geometry) {
          if (geometry._bufferGeometry === undefined) {
            geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject(object);
          }
          buffergeometry = geometry._bufferGeometry;
        }
        geometries[geometry.id] = buffergeometry;
        info.memory.geometries++;
        return buffergeometry;
      }
      function onGeometryDispose(event) {
        var geometry = event.target;
        var buffergeometry = geometries[geometry.id];
        deleteAttributes(buffergeometry.attributes);
        geometry.removeEventListener('dispose', onGeometryDispose);
        delete geometries[geometry.id];
        var property = properties.get(geometry);
        if (property.wireframe)
          deleteAttribute(property.wireframe);
        info.memory.geometries--;
      }
      function getAttributeBuffer(attribute) {
        if (attribute instanceof THREE.InterleavedBufferAttribute) {
          return properties.get(attribute.data).__webglBuffer;
        }
        return properties.get(attribute).__webglBuffer;
      }
      function deleteAttribute(attribute) {
        var buffer = getAttributeBuffer(attribute);
        if (buffer !== undefined) {
          gl.deleteBuffer(buffer);
          removeAttributeBuffer(attribute);
        }
      }
      function deleteAttributes(attributes) {
        for (var name in attributes) {
          deleteAttribute(attributes[name]);
        }
      }
      function removeAttributeBuffer(attribute) {
        if (attribute instanceof THREE.InterleavedBufferAttribute) {
          properties.delete(attribute.data);
        } else {
          properties.delete(attribute);
        }
      }
      this.get = get;
    };
    THREE.WebGLObjects = function(gl, properties, info) {
      var geometries = new THREE.WebGLGeometries(gl, properties, info);
      function update(object) {
        var geometry = geometries.get(object);
        if (object.geometry instanceof THREE.Geometry) {
          geometry.updateFromObject(object);
        }
        var index = geometry.index;
        var attributes = geometry.attributes;
        if (index !== null) {
          updateAttribute(index, gl.ELEMENT_ARRAY_BUFFER);
        }
        for (var name in attributes) {
          updateAttribute(attributes[name], gl.ARRAY_BUFFER);
        }
        var morphAttributes = geometry.morphAttributes;
        for (var name in morphAttributes) {
          var array = morphAttributes[name];
          for (var i = 0,
              l = array.length; i < l; i++) {
            updateAttribute(array[i], gl.ARRAY_BUFFER);
          }
        }
        return geometry;
      }
      function updateAttribute(attribute, bufferType) {
        var data = (attribute instanceof THREE.InterleavedBufferAttribute) ? attribute.data : attribute;
        var attributeProperties = properties.get(data);
        if (attributeProperties.__webglBuffer === undefined) {
          createBuffer(attributeProperties, data, bufferType);
        } else if (attributeProperties.version !== data.version) {
          updateBuffer(attributeProperties, data, bufferType);
        }
      }
      function createBuffer(attributeProperties, data, bufferType) {
        attributeProperties.__webglBuffer = gl.createBuffer();
        gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
        var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
        gl.bufferData(bufferType, data.array, usage);
        attributeProperties.version = data.version;
      }
      function updateBuffer(attributeProperties, data, bufferType) {
        gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
        if (data.dynamic === false || data.updateRange.count === -1) {
          gl.bufferSubData(bufferType, 0, data.array);
        } else if (data.updateRange.count === 0) {
          console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');
        } else {
          gl.bufferSubData(bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT, data.array.subarray(data.updateRange.offset, data.updateRange.offset + data.updateRange.count));
          data.updateRange.count = 0;
        }
        attributeProperties.version = data.version;
      }
      function getAttributeBuffer(attribute) {
        if (attribute instanceof THREE.InterleavedBufferAttribute) {
          return properties.get(attribute.data).__webglBuffer;
        }
        return properties.get(attribute).__webglBuffer;
      }
      function getWireframeAttribute(geometry) {
        var property = properties.get(geometry);
        if (property.wireframe !== undefined) {
          return property.wireframe;
        }
        var indices = [];
        var index = geometry.index;
        var attributes = geometry.attributes;
        var position = attributes.position;
        if (index !== null) {
          var edges = {};
          var array = index.array;
          for (var i = 0,
              l = array.length; i < l; i += 3) {
            var a = array[i + 0];
            var b = array[i + 1];
            var c = array[i + 2];
            if (checkEdge(edges, a, b))
              indices.push(a, b);
            if (checkEdge(edges, b, c))
              indices.push(b, c);
            if (checkEdge(edges, c, a))
              indices.push(c, a);
          }
        } else {
          var array = attributes.position.array;
          for (var i = 0,
              l = (array.length / 3) - 1; i < l; i += 3) {
            var a = i + 0;
            var b = i + 1;
            var c = i + 2;
            indices.push(a, b, b, c, c, a);
          }
        }
        var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
        var attribute = new THREE.BufferAttribute(new TypeArray(indices), 1);
        updateAttribute(attribute, gl.ELEMENT_ARRAY_BUFFER);
        property.wireframe = attribute;
        return attribute;
      }
      function checkEdge(edges, a, b) {
        if (a > b) {
          var tmp = a;
          a = b;
          b = tmp;
        }
        var list = edges[a];
        if (list === undefined) {
          edges[a] = [b];
          return true;
        } else if (list.indexOf(b) === -1) {
          list.push(b);
          return true;
        }
        return false;
      }
      this.getAttributeBuffer = getAttributeBuffer;
      this.getWireframeAttribute = getWireframeAttribute;
      this.update = update;
    };
    THREE.WebGLProgram = (function() {
      var programIdCount = 0;
      function generateDefines(defines) {
        var chunks = [];
        for (var name in defines) {
          var value = defines[name];
          if (value === false)
            continue;
          chunks.push('#define ' + name + ' ' + value);
        }
        return chunks.join('\n');
      }
      function fetchUniformLocations(gl, program, identifiers) {
        var uniforms = {};
        var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (var i = 0; i < n; i++) {
          var info = gl.getActiveUniform(program, i);
          var name = info.name;
          var location = gl.getUniformLocation(program, name);
          var suffixPos = name.lastIndexOf('[0]');
          if (suffixPos !== -1 && suffixPos === name.length - 3) {
            uniforms[name.substr(0, suffixPos)] = location;
          }
          uniforms[name] = location;
        }
        return uniforms;
      }
      function fetchAttributeLocations(gl, program, identifiers) {
        var attributes = {};
        var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (var i = 0; i < n; i++) {
          var info = gl.getActiveAttrib(program, i);
          var name = info.name;
          attributes[name] = gl.getAttribLocation(program, name);
        }
        return attributes;
      }
      function filterEmptyLine(string) {
        return string !== '';
      }
      return function WebGLProgram(renderer, code, material, parameters) {
        var gl = renderer.context;
        var defines = material.defines;
        var vertexShader = material.__webglShader.vertexShader;
        var fragmentShader = material.__webglShader.fragmentShader;
        var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
        if (parameters.shadowMapType === THREE.PCFShadowMap) {
          shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
        } else if (parameters.shadowMapType === THREE.PCFSoftShadowMap) {
          shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
        }
        var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
        var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
        if (parameters.envMap) {
          switch (material.envMap.mapping) {
            case THREE.CubeReflectionMapping:
            case THREE.CubeRefractionMapping:
              envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
              break;
            case THREE.EquirectangularReflectionMapping:
            case THREE.EquirectangularRefractionMapping:
              envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
              break;
            case THREE.SphericalReflectionMapping:
              envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
              break;
          }
          switch (material.envMap.mapping) {
            case THREE.CubeRefractionMapping:
            case THREE.EquirectangularRefractionMapping:
              envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
              break;
          }
          switch (material.combine) {
            case THREE.MultiplyOperation:
              envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
              break;
            case THREE.MixOperation:
              envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
              break;
            case THREE.AddOperation:
              envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
              break;
          }
        }
        var gammaFactorDefine = (renderer.gammaFactor > 0) ? renderer.gammaFactor : 1.0;
        var customDefines = generateDefines(defines);
        var program = gl.createProgram();
        var prefixVertex,
            prefixFragment;
        if (material instanceof THREE.RawShaderMaterial) {
          prefixVertex = '';
          prefixFragment = '';
        } else {
          prefixVertex = ['precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', '#define SHADER_NAME ' + material.__webglShader.name, customDefines, parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', renderer.gammaInput ? '#define GAMMA_INPUT' : '', renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights, '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights, '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights, '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights, '#define MAX_SHADOWS ' + parameters.maxShadows, '#define MAX_BONES ' + parameters.maxBones, parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '', parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_COLOR', '	attribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
          prefixFragment = [parameters.bumpMap || parameters.normalMap || parameters.flatShading || material.derivatives ? '#extension GL_OES_standard_derivatives : enable' : '', parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '', 'precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', '#define SHADER_NAME ' + material.__webglShader.name, customDefines, '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights, '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights, '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights, '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights, '#define MAX_SHADOWS ' + parameters.maxShadows, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '', renderer.gammaInput ? '#define GAMMA_INPUT' : '', renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '', (parameters.useFog && parameters.fogExp) ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.metal ? '#define METAL' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '', parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', '\n'].filter(filterEmptyLine).join('\n');
        }
        var vertexGlsl = prefixVertex + vertexShader;
        var fragmentGlsl = prefixFragment + fragmentShader;
        var glVertexShader = THREE.WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
        var glFragmentShader = THREE.WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
        gl.attachShader(program, glVertexShader);
        gl.attachShader(program, glFragmentShader);
        if (material.index0AttributeName !== undefined) {
          gl.bindAttribLocation(program, 0, material.index0AttributeName);
        } else if (parameters.morphTargets === true) {
          gl.bindAttribLocation(program, 0, 'position');
        }
        gl.linkProgram(program);
        var programLog = gl.getProgramInfoLog(program);
        var vertexLog = gl.getShaderInfoLog(glVertexShader);
        var fragmentLog = gl.getShaderInfoLog(glFragmentShader);
        var runnable = true;
        var haveDiagnostics = true;
        if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
          runnable = false;
          console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog);
        } else if (programLog !== '') {
          console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
        } else if (vertexLog === '' || fragmentLog === '') {
          haveDiagnostics = false;
        }
        if (haveDiagnostics) {
          this.diagnostics = {
            runnable: runnable,
            material: material,
            programLog: programLog,
            vertexShader: {
              log: vertexLog,
              prefix: prefixVertex
            },
            fragmentShader: {
              log: fragmentLog,
              prefix: prefixFragment
            }
          };
        }
        gl.deleteShader(glVertexShader);
        gl.deleteShader(glFragmentShader);
        var cachedUniforms;
        this.getUniforms = function() {
          if (cachedUniforms === undefined) {
            cachedUniforms = fetchUniformLocations(gl, program);
          }
          return cachedUniforms;
        };
        var cachedAttributes;
        this.getAttributes = function() {
          if (cachedAttributes === undefined) {
            cachedAttributes = fetchAttributeLocations(gl, program);
          }
          return cachedAttributes;
        };
        this.destroy = function() {
          gl.deleteProgram(program);
          this.program = undefined;
        };
        Object.defineProperties(this, {
          uniforms: {get: function() {
              console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');
              return this.getUniforms();
            }},
          attributes: {get: function() {
              console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');
              return this.getAttributes();
            }}
        });
        this.id = programIdCount++;
        this.code = code;
        this.usedTimes = 1;
        this.program = program;
        this.vertexShader = glVertexShader;
        this.fragmentShader = glFragmentShader;
        return this;
      };
    })();
    THREE.WebGLPrograms = function(renderer, capabilities) {
      var programs = [];
      var shaderIDs = {
        MeshDepthMaterial: 'depth',
        MeshNormalMaterial: 'normal',
        MeshBasicMaterial: 'basic',
        MeshLambertMaterial: 'lambert',
        MeshPhongMaterial: 'phong',
        LineBasicMaterial: 'basic',
        LineDashedMaterial: 'dashed',
        PointsMaterial: 'points'
      };
      var parameterNames = ["precision", "supportsVertexTextures", "map", "envMap", "envMapMode", "lightMap", "aoMap", "emissiveMap", "bumpMap", "normalMap", "displacementMap", "specularMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "maxDirLights", "maxPointLights", "maxSpotLights", "maxHemiLights", "maxShadows", "shadowMapEnabled", "pointLightShadows", "shadowMapType", "shadowMapDebug", "alphaTest", "metal", "doubleSided", "flipSided"];
      function allocateBones(object) {
        if (capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture) {
          return 1024;
        } else {
          var nVertexUniforms = capabilities.maxVertexUniforms;
          var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
          var maxBones = nVertexMatrices;
          if (object !== undefined && object instanceof THREE.SkinnedMesh) {
            maxBones = Math.min(object.skeleton.bones.length, maxBones);
            if (maxBones < object.skeleton.bones.length) {
              console.warn('WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)');
            }
          }
          return maxBones;
        }
      }
      function allocateLights(lights) {
        var dirLights = 0;
        var pointLights = 0;
        var spotLights = 0;
        var hemiLights = 0;
        for (var l = 0,
            ll = lights.length; l < ll; l++) {
          var light = lights[l];
          if (light.visible === false)
            continue;
          if (light instanceof THREE.DirectionalLight)
            dirLights++;
          if (light instanceof THREE.PointLight)
            pointLights++;
          if (light instanceof THREE.SpotLight)
            spotLights++;
          if (light instanceof THREE.HemisphereLight)
            hemiLights++;
        }
        return {
          'directional': dirLights,
          'point': pointLights,
          'spot': spotLights,
          'hemi': hemiLights
        };
      }
      function allocateShadows(lights) {
        var maxShadows = 0;
        var pointLightShadows = 0;
        for (var l = 0,
            ll = lights.length; l < ll; l++) {
          var light = lights[l];
          if (!light.castShadow)
            continue;
          if (light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight)
            maxShadows++;
          if (light instanceof THREE.PointLight) {
            maxShadows++;
            pointLightShadows++;
          }
        }
        return {
          'maxShadows': maxShadows,
          'pointLightShadows': pointLightShadows
        };
      }
      this.getParameters = function(material, lights, fog, object) {
        var shaderID = shaderIDs[material.type];
        var maxLightCount = allocateLights(lights);
        var allocatedShadows = allocateShadows(lights);
        var maxBones = allocateBones(object);
        var precision = renderer.getPrecision();
        if (material.precision !== null) {
          precision = capabilities.getMaxPrecision(material.precision);
          if (precision !== material.precision) {
            console.warn('THREE.WebGLRenderer.initMaterial:', material.precision, 'not supported, using', precision, 'instead.');
          }
        }
        var parameters = {
          shaderID: shaderID,
          precision: precision,
          supportsVertexTextures: capabilities.vertexTextures,
          map: !!material.map,
          envMap: !!material.envMap,
          envMapMode: material.envMap && material.envMap.mapping,
          lightMap: !!material.lightMap,
          aoMap: !!material.aoMap,
          emissiveMap: !!material.emissiveMap,
          bumpMap: !!material.bumpMap,
          normalMap: !!material.normalMap,
          displacementMap: !!material.displacementMap,
          specularMap: !!material.specularMap,
          alphaMap: !!material.alphaMap,
          combine: material.combine,
          vertexColors: material.vertexColors,
          fog: fog,
          useFog: material.fog,
          fogExp: fog instanceof THREE.FogExp2,
          flatShading: material.shading === THREE.FlatShading,
          sizeAttenuation: material.sizeAttenuation,
          logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
          skinning: material.skinning,
          maxBones: maxBones,
          useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,
          morphTargets: material.morphTargets,
          morphNormals: material.morphNormals,
          maxMorphTargets: renderer.maxMorphTargets,
          maxMorphNormals: renderer.maxMorphNormals,
          maxDirLights: maxLightCount.directional,
          maxPointLights: maxLightCount.point,
          maxSpotLights: maxLightCount.spot,
          maxHemiLights: maxLightCount.hemi,
          maxShadows: allocatedShadows.maxShadows,
          pointLightShadows: allocatedShadows.pointLightShadows,
          shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && allocatedShadows.maxShadows > 0,
          shadowMapType: renderer.shadowMap.type,
          shadowMapDebug: renderer.shadowMap.debug,
          alphaTest: material.alphaTest,
          metal: material.metal,
          doubleSided: material.side === THREE.DoubleSide,
          flipSided: material.side === THREE.BackSide
        };
        return parameters;
      };
      this.getProgramCode = function(material, parameters) {
        var chunks = [];
        if (parameters.shaderID) {
          chunks.push(parameters.shaderID);
        } else {
          chunks.push(material.fragmentShader);
          chunks.push(material.vertexShader);
        }
        if (material.defines !== undefined) {
          for (var name in material.defines) {
            chunks.push(name);
            chunks.push(material.defines[name]);
          }
        }
        for (var i = 0; i < parameterNames.length; i++) {
          var parameterName = parameterNames[i];
          chunks.push(parameterName);
          chunks.push(parameters[parameterName]);
        }
        return chunks.join();
      };
      this.acquireProgram = function(material, parameters, code) {
        var program;
        for (var p = 0,
            pl = programs.length; p < pl; p++) {
          var programInfo = programs[p];
          if (programInfo.code === code) {
            program = programInfo;
            ++program.usedTimes;
            break;
          }
        }
        if (program === undefined) {
          program = new THREE.WebGLProgram(renderer, code, material, parameters);
          programs.push(program);
        }
        return program;
      };
      this.releaseProgram = function(program) {
        if (--program.usedTimes === 0) {
          var i = programs.indexOf(program);
          programs[i] = programs[programs.length - 1];
          programs.pop();
          program.destroy();
        }
      };
      this.programs = programs;
    };
    THREE.WebGLProperties = function() {
      var properties = {};
      this.get = function(object) {
        var uuid = object.uuid;
        var map = properties[uuid];
        if (map === undefined) {
          map = {};
          properties[uuid] = map;
        }
        return map;
      };
      this.delete = function(object) {
        delete properties[object.uuid];
      };
      this.clear = function() {
        properties = {};
      };
    };
    THREE.WebGLShader = (function() {
      function addLineNumbers(string) {
        var lines = string.split('\n');
        for (var i = 0; i < lines.length; i++) {
          lines[i] = (i + 1) + ': ' + lines[i];
        }
        return lines.join('\n');
      }
      return function WebGLShader(gl, type, string) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, string);
        gl.compileShader(shader);
        if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
          console.error('THREE.WebGLShader: Shader couldn\'t compile.');
        }
        if (gl.getShaderInfoLog(shader) !== '') {
          console.warn('THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog(shader), addLineNumbers(string));
        }
        return shader;
      };
    })();
    THREE.WebGLShadowMap = function(_renderer, _lights, _objects) {
      var _gl = _renderer.context,
          _state = _renderer.state,
          _frustum = new THREE.Frustum(),
          _projScreenMatrix = new THREE.Matrix4(),
          _min = new THREE.Vector3(),
          _max = new THREE.Vector3(),
          _lookTarget = new THREE.Vector3(),
          _lightPositionWorld = new THREE.Vector3(),
          _renderList = [],
          _MorphingFlag = 1,
          _SkinningFlag = 2,
          _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1,
          _depthMaterials = new Array(_NumberOfMaterialVariants),
          _distanceMaterials = new Array(_NumberOfMaterialVariants);
      var cubeDirections = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0)];
      var cubeUps = [new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1)];
      var cube2DViewPorts = [new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()];
      var _vector4 = new THREE.Vector4();
      var depthShader = THREE.ShaderLib["depthRGBA"];
      var depthUniforms = THREE.UniformsUtils.clone(depthShader.uniforms);
      var distanceShader = THREE.ShaderLib["distanceRGBA"];
      var distanceUniforms = THREE.UniformsUtils.clone(distanceShader.uniforms);
      for (var i = 0; i !== _NumberOfMaterialVariants; ++i) {
        var useMorphing = (i & _MorphingFlag) !== 0;
        var useSkinning = (i & _SkinningFlag) !== 0;
        var depthMaterial = new THREE.ShaderMaterial({
          uniforms: depthUniforms,
          vertexShader: depthShader.vertexShader,
          fragmentShader: depthShader.fragmentShader,
          morphTargets: useMorphing,
          skinning: useSkinning
        });
        depthMaterial._shadowPass = true;
        _depthMaterials[i] = depthMaterial;
        var distanceMaterial = new THREE.ShaderMaterial({
          uniforms: distanceUniforms,
          vertexShader: distanceShader.vertexShader,
          fragmentShader: distanceShader.fragmentShader,
          morphTargets: useMorphing,
          skinning: useSkinning
        });
        distanceMaterial._shadowPass = true;
        _distanceMaterials[i] = distanceMaterial;
      }
      var scope = this;
      this.enabled = false;
      this.autoUpdate = true;
      this.needsUpdate = false;
      this.type = THREE.PCFShadowMap;
      this.cullFace = THREE.CullFaceFront;
      this.render = function(scene) {
        var faceCount,
            isPointLight;
        if (scope.enabled === false)
          return;
        if (scope.autoUpdate === false && scope.needsUpdate === false)
          return;
        _gl.clearColor(1, 1, 1, 1);
        _state.disable(_gl.BLEND);
        _state.enable(_gl.CULL_FACE);
        _gl.frontFace(_gl.CCW);
        _gl.cullFace(scope.cullFace === THREE.CullFaceFront ? _gl.FRONT : _gl.BACK);
        _state.setDepthTest(true);
        _renderer.getViewport(_vector4);
        for (var i = 0,
            il = _lights.length; i < il; i++) {
          var light = _lights[i];
          if (light.castShadow === true) {
            var shadow = light.shadow;
            var shadowCamera = shadow.camera;
            var shadowMapSize = shadow.mapSize;
            if (light instanceof THREE.PointLight) {
              faceCount = 6;
              isPointLight = true;
              var vpWidth = shadowMapSize.x / 4.0;
              var vpHeight = shadowMapSize.y / 2.0;
              cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
              cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
              cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
              cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
              cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
              cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);
            } else {
              faceCount = 1;
              isPointLight = false;
            }
            if (shadow.map === null) {
              var shadowFilter = THREE.LinearFilter;
              if (scope.type === THREE.PCFSoftShadowMap) {
                shadowFilter = THREE.NearestFilter;
              }
              var pars = {
                minFilter: shadowFilter,
                magFilter: shadowFilter,
                format: THREE.RGBAFormat
              };
              shadow.map = new THREE.WebGLRenderTarget(shadowMapSize.x, shadowMapSize.y, pars);
              shadow.matrix = new THREE.Matrix4();
              if (light instanceof THREE.SpotLight) {
                shadowCamera.aspect = shadowMapSize.x / shadowMapSize.y;
              }
              shadowCamera.updateProjectionMatrix();
            }
            var shadowMap = shadow.map;
            var shadowMatrix = shadow.matrix;
            _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
            shadowCamera.position.copy(_lightPositionWorld);
            _renderer.setRenderTarget(shadowMap);
            _renderer.clear();
            for (var face = 0; face < faceCount; face++) {
              if (isPointLight) {
                _lookTarget.copy(shadowCamera.position);
                _lookTarget.add(cubeDirections[face]);
                shadowCamera.up.copy(cubeUps[face]);
                shadowCamera.lookAt(_lookTarget);
                var vpDimensions = cube2DViewPorts[face];
                _renderer.setViewport(vpDimensions.x, vpDimensions.y, vpDimensions.z, vpDimensions.w);
              } else {
                _lookTarget.setFromMatrixPosition(light.target.matrixWorld);
                shadowCamera.lookAt(_lookTarget);
              }
              shadowCamera.updateMatrixWorld();
              shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);
              shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
              shadowMatrix.multiply(shadowCamera.projectionMatrix);
              shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
              _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
              _frustum.setFromMatrix(_projScreenMatrix);
              _renderList.length = 0;
              projectObject(scene, shadowCamera);
              for (var j = 0,
                  jl = _renderList.length; j < jl; j++) {
                var object = _renderList[j];
                var geometry = _objects.update(object);
                var material = object.material;
                if (material instanceof THREE.MeshFaceMaterial) {
                  var groups = geometry.groups;
                  var materials = material.materials;
                  for (var k = 0,
                      kl = groups.length; k < kl; k++) {
                    var group = groups[k];
                    var groupMaterial = materials[group.materialIndex];
                    if (groupMaterial.visible === true) {
                      var depthMaterial = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld);
                      _renderer.renderBufferDirect(shadowCamera, _lights, null, geometry, depthMaterial, object, group);
                    }
                  }
                } else {
                  var depthMaterial = getDepthMaterial(object, material, isPointLight, _lightPositionWorld);
                  _renderer.renderBufferDirect(shadowCamera, _lights, null, geometry, depthMaterial, object, null);
                }
              }
            }
            _renderer.resetGLState();
          }
        }
        _renderer.setViewport(_vector4.x, _vector4.y, _vector4.z, _vector4.w);
        var clearColor = _renderer.getClearColor(),
            clearAlpha = _renderer.getClearAlpha();
        _renderer.setClearColor(clearColor, clearAlpha);
        _state.enable(_gl.BLEND);
        if (scope.cullFace === THREE.CullFaceFront) {
          _gl.cullFace(_gl.BACK);
        }
        _renderer.resetGLState();
        scope.needsUpdate = false;
      };
      function getDepthMaterial(object, material, isPointLight, lightPositionWorld) {
        var geometry = object.geometry;
        var newMaterial = null;
        var materialVariants = _depthMaterials;
        var customMaterial = object.customDepthMaterial;
        if (isPointLight) {
          materialVariants = _distanceMaterials;
          customMaterial = object.customDistanceMaterial;
        }
        if (!customMaterial) {
          var useMorphing = geometry.morphTargets !== undefined && geometry.morphTargets.length > 0 && material.morphTargets;
          var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;
          var variantIndex = 0;
          if (useMorphing)
            variantIndex |= _MorphingFlag;
          if (useSkinning)
            variantIndex |= _SkinningFlag;
          newMaterial = materialVariants[variantIndex];
        } else {
          newMaterial = customMaterial;
        }
        newMaterial.visible = material.visible;
        newMaterial.wireframe = material.wireframe;
        newMaterial.wireframeLinewidth = material.wireframeLinewidth;
        if (isPointLight && newMaterial.uniforms.lightPos !== undefined) {
          newMaterial.uniforms.lightPos.value.copy(lightPositionWorld);
        }
        return newMaterial;
      }
      function projectObject(object, camera) {
        if (object.visible === false)
          return;
        if (object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points) {
          if (object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject(object) === true)) {
            var material = object.material;
            if (material.visible === true) {
              object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
              _renderList.push(object);
            }
          }
        }
        var children = object.children;
        for (var i = 0,
            l = children.length; i < l; i++) {
          projectObject(children[i], camera);
        }
      }
    };
    THREE.WebGLState = function(gl, extensions, paramThreeToGL) {
      var _this = this;
      var newAttributes = new Uint8Array(16);
      var enabledAttributes = new Uint8Array(16);
      var attributeDivisors = new Uint8Array(16);
      var capabilities = {};
      var compressedTextureFormats = null;
      var currentBlending = null;
      var currentBlendEquation = null;
      var currentBlendSrc = null;
      var currentBlendDst = null;
      var currentBlendEquationAlpha = null;
      var currentBlendSrcAlpha = null;
      var currentBlendDstAlpha = null;
      var currentDepthFunc = null;
      var currentDepthWrite = null;
      var currentColorWrite = null;
      var currentFlipSided = null;
      var currentLineWidth = null;
      var currentPolygonOffsetFactor = null;
      var currentPolygonOffsetUnits = null;
      var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
      var currentTextureSlot = undefined;
      var currentBoundTextures = {};
      this.init = function() {
        gl.clearColor(0, 0, 0, 1);
        gl.clearDepth(1);
        gl.clearStencil(0);
        this.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
        gl.frontFace(gl.CCW);
        gl.cullFace(gl.BACK);
        this.enable(gl.CULL_FACE);
        this.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      };
      this.initAttributes = function() {
        for (var i = 0,
            l = newAttributes.length; i < l; i++) {
          newAttributes[i] = 0;
        }
      };
      this.enableAttribute = function(attribute) {
        newAttributes[attribute] = 1;
        if (enabledAttributes[attribute] === 0) {
          gl.enableVertexAttribArray(attribute);
          enabledAttributes[attribute] = 1;
        }
        if (attributeDivisors[attribute] !== 0) {
          var extension = extensions.get('ANGLE_instanced_arrays');
          extension.vertexAttribDivisorANGLE(attribute, 0);
          attributeDivisors[attribute] = 0;
        }
      };
      this.enableAttributeAndDivisor = function(attribute, meshPerAttribute, extension) {
        newAttributes[attribute] = 1;
        if (enabledAttributes[attribute] === 0) {
          gl.enableVertexAttribArray(attribute);
          enabledAttributes[attribute] = 1;
        }
        if (attributeDivisors[attribute] !== meshPerAttribute) {
          extension.vertexAttribDivisorANGLE(attribute, meshPerAttribute);
          attributeDivisors[attribute] = meshPerAttribute;
        }
      };
      this.disableUnusedAttributes = function() {
        for (var i = 0,
            l = enabledAttributes.length; i < l; i++) {
          if (enabledAttributes[i] !== newAttributes[i]) {
            gl.disableVertexAttribArray(i);
            enabledAttributes[i] = 0;
          }
        }
      };
      this.enable = function(id) {
        if (capabilities[id] !== true) {
          gl.enable(id);
          capabilities[id] = true;
        }
      };
      this.disable = function(id) {
        if (capabilities[id] !== false) {
          gl.disable(id);
          capabilities[id] = false;
        }
      };
      this.getCompressedTextureFormats = function() {
        if (compressedTextureFormats === null) {
          compressedTextureFormats = [];
          if (extensions.get('WEBGL_compressed_texture_pvrtc') || extensions.get('WEBGL_compressed_texture_s3tc')) {
            var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);
            for (var i = 0; i < formats.length; i++) {
              compressedTextureFormats.push(formats[i]);
            }
          }
        }
        return compressedTextureFormats;
      };
      this.setBlending = function(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha) {
        if (blending !== currentBlending) {
          if (blending === THREE.NoBlending) {
            this.disable(gl.BLEND);
          } else if (blending === THREE.AdditiveBlending) {
            this.enable(gl.BLEND);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
          } else if (blending === THREE.SubtractiveBlending) {
            this.enable(gl.BLEND);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
          } else if (blending === THREE.MultiplyBlending) {
            this.enable(gl.BLEND);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
          } else if (blending === THREE.CustomBlending) {
            this.enable(gl.BLEND);
          } else {
            this.enable(gl.BLEND);
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
          }
          currentBlending = blending;
        }
        if (blending === THREE.CustomBlending) {
          blendEquationAlpha = blendEquationAlpha || blendEquation;
          blendSrcAlpha = blendSrcAlpha || blendSrc;
          blendDstAlpha = blendDstAlpha || blendDst;
          if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
            gl.blendEquationSeparate(paramThreeToGL(blendEquation), paramThreeToGL(blendEquationAlpha));
            currentBlendEquation = blendEquation;
            currentBlendEquationAlpha = blendEquationAlpha;
          }
          if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
            gl.blendFuncSeparate(paramThreeToGL(blendSrc), paramThreeToGL(blendDst), paramThreeToGL(blendSrcAlpha), paramThreeToGL(blendDstAlpha));
            currentBlendSrc = blendSrc;
            currentBlendDst = blendDst;
            currentBlendSrcAlpha = blendSrcAlpha;
            currentBlendDstAlpha = blendDstAlpha;
          }
        } else {
          currentBlendEquation = null;
          currentBlendSrc = null;
          currentBlendDst = null;
          currentBlendEquationAlpha = null;
          currentBlendSrcAlpha = null;
          currentBlendDstAlpha = null;
        }
      };
      this.setDepthFunc = function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case THREE.NeverDepth:
                gl.depthFunc(gl.NEVER);
                break;
              case THREE.AlwaysDepth:
                gl.depthFunc(gl.ALWAYS);
                break;
              case THREE.LessDepth:
                gl.depthFunc(gl.LESS);
                break;
              case THREE.LessEqualDepth:
                gl.depthFunc(gl.LEQUAL);
                break;
              case THREE.EqualDepth:
                gl.depthFunc(gl.EQUAL);
                break;
              case THREE.GreaterEqualDepth:
                gl.depthFunc(gl.GEQUAL);
                break;
              case THREE.GreaterDepth:
                gl.depthFunc(gl.GREATER);
                break;
              case THREE.NotEqualDepth:
                gl.depthFunc(gl.NOTEQUAL);
                break;
              default:
                gl.depthFunc(gl.LEQUAL);
            }
          } else {
            gl.depthFunc(gl.LEQUAL);
          }
          currentDepthFunc = depthFunc;
        }
      };
      this.setDepthTest = function(depthTest) {
        if (depthTest) {
          this.enable(gl.DEPTH_TEST);
        } else {
          this.disable(gl.DEPTH_TEST);
        }
      };
      this.setDepthWrite = function(depthWrite) {
        if (currentDepthWrite !== depthWrite) {
          gl.depthMask(depthWrite);
          currentDepthWrite = depthWrite;
        }
      };
      this.setColorWrite = function(colorWrite) {
        if (currentColorWrite !== colorWrite) {
          gl.colorMask(colorWrite, colorWrite, colorWrite, colorWrite);
          currentColorWrite = colorWrite;
        }
      };
      this.setFlipSided = function(flipSided) {
        if (currentFlipSided !== flipSided) {
          if (flipSided) {
            gl.frontFace(gl.CW);
          } else {
            gl.frontFace(gl.CCW);
          }
          currentFlipSided = flipSided;
        }
      };
      this.setLineWidth = function(width) {
        if (width !== currentLineWidth) {
          gl.lineWidth(width);
          currentLineWidth = width;
        }
      };
      this.setPolygonOffset = function(polygonOffset, factor, units) {
        if (polygonOffset) {
          this.enable(gl.POLYGON_OFFSET_FILL);
        } else {
          this.disable(gl.POLYGON_OFFSET_FILL);
        }
        if (polygonOffset && (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units)) {
          gl.polygonOffset(factor, units);
          currentPolygonOffsetFactor = factor;
          currentPolygonOffsetUnits = units;
        }
      };
      this.setScissorTest = function(scissorTest) {
        if (scissorTest) {
          this.enable(gl.SCISSOR_TEST);
        } else {
          this.disable(gl.SCISSOR_TEST);
        }
      };
      this.activeTexture = function(webglSlot) {
        if (webglSlot === undefined)
          webglSlot = gl.TEXTURE0 + maxTextures - 1;
        if (currentTextureSlot !== webglSlot) {
          gl.activeTexture(webglSlot);
          currentTextureSlot = webglSlot;
        }
      };
      this.bindTexture = function(webglType, webglTexture) {
        if (currentTextureSlot === undefined) {
          _this.activeTexture();
        }
        var boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture === undefined) {
          boundTexture = {
            type: undefined,
            texture: undefined
          };
          currentBoundTextures[currentTextureSlot] = boundTexture;
        }
        if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
          gl.bindTexture(webglType, webglTexture);
          boundTexture.type = webglType;
          boundTexture.texture = webglTexture;
        }
      };
      this.compressedTexImage2D = function() {
        try {
          gl.compressedTexImage2D.apply(gl, arguments);
        } catch (error) {
          console.error(error);
        }
      };
      this.texImage2D = function() {
        try {
          gl.texImage2D.apply(gl, arguments);
        } catch (error) {
          console.error(error);
        }
      };
      this.reset = function() {
        for (var i = 0; i < enabledAttributes.length; i++) {
          if (enabledAttributes[i] === 1) {
            gl.disableVertexAttribArray(i);
            enabledAttributes[i] = 0;
          }
        }
        capabilities = {};
        compressedTextureFormats = null;
        currentBlending = null;
        currentDepthWrite = null;
        currentColorWrite = null;
        currentFlipSided = null;
      };
    };
    THREE.LensFlarePlugin = function(renderer, flares) {
      var gl = renderer.context;
      var state = renderer.state;
      var vertexBuffer,
          elementBuffer;
      var program,
          attributes,
          uniforms;
      var hasVertexTexture;
      var tempTexture,
          occlusionTexture;
      function init() {
        var vertices = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]);
        var faces = new Uint16Array([0, 1, 2, 0, 2, 3]);
        vertexBuffer = gl.createBuffer();
        elementBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
        tempTexture = gl.createTexture();
        occlusionTexture = gl.createTexture();
        state.bindTexture(gl.TEXTURE_2D, tempTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        hasVertexTexture = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
        var shader;
        if (hasVertexTexture) {
          shader = {
            vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if ( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
          };
        } else {
          shader = {
            vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
            fragmentShader: ["precision mediump float;", "uniform lowp int renderType;", "uniform sampler2D map;", "uniform sampler2D occlusionMap;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "void main() {", "if ( renderType == 0 ) {", "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;", "visibility = ( 1.0 - visibility / 4.0 );", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * visibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
          };
        }
        program = createProgram(shader);
        attributes = {
          vertex: gl.getAttribLocation(program, "position"),
          uv: gl.getAttribLocation(program, "uv")
        };
        uniforms = {
          renderType: gl.getUniformLocation(program, "renderType"),
          map: gl.getUniformLocation(program, "map"),
          occlusionMap: gl.getUniformLocation(program, "occlusionMap"),
          opacity: gl.getUniformLocation(program, "opacity"),
          color: gl.getUniformLocation(program, "color"),
          scale: gl.getUniformLocation(program, "scale"),
          rotation: gl.getUniformLocation(program, "rotation"),
          screenPosition: gl.getUniformLocation(program, "screenPosition")
        };
      }
      this.render = function(scene, camera, viewportWidth, viewportHeight) {
        if (flares.length === 0)
          return;
        var tempPosition = new THREE.Vector3();
        var invAspect = viewportHeight / viewportWidth,
            halfViewportWidth = viewportWidth * 0.5,
            halfViewportHeight = viewportHeight * 0.5;
        var size = 16 / viewportHeight,
            scale = new THREE.Vector2(size * invAspect, size);
        var screenPosition = new THREE.Vector3(1, 1, 0),
            screenPositionPixels = new THREE.Vector2(1, 1);
        if (program === undefined) {
          init();
        }
        gl.useProgram(program);
        state.initAttributes();
        state.enableAttribute(attributes.vertex);
        state.enableAttribute(attributes.uv);
        state.disableUnusedAttributes();
        gl.uniform1i(uniforms.occlusionMap, 0);
        gl.uniform1i(uniforms.map, 1);
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0);
        gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        state.disable(gl.CULL_FACE);
        gl.depthMask(false);
        for (var i = 0,
            l = flares.length; i < l; i++) {
          size = 16 / viewportHeight;
          scale.set(size * invAspect, size);
          var flare = flares[i];
          tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]);
          tempPosition.applyMatrix4(camera.matrixWorldInverse);
          tempPosition.applyProjection(camera.projectionMatrix);
          screenPosition.copy(tempPosition);
          screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
          screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;
          if (hasVertexTexture || (screenPositionPixels.x > 0 && screenPositionPixels.x < viewportWidth && screenPositionPixels.y > 0 && screenPositionPixels.y < viewportHeight)) {
            state.activeTexture(gl.TEXTURE0);
            state.bindTexture(gl.TEXTURE_2D, null);
            state.activeTexture(gl.TEXTURE1);
            state.bindTexture(gl.TEXTURE_2D, tempTexture);
            gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0);
            gl.uniform1i(uniforms.renderType, 0);
            gl.uniform2f(uniforms.scale, scale.x, scale.y);
            gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
            state.disable(gl.BLEND);
            state.enable(gl.DEPTH_TEST);
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            state.activeTexture(gl.TEXTURE0);
            state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
            gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0);
            gl.uniform1i(uniforms.renderType, 1);
            state.disable(gl.DEPTH_TEST);
            state.activeTexture(gl.TEXTURE1);
            state.bindTexture(gl.TEXTURE_2D, tempTexture);
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            flare.positionScreen.copy(screenPosition);
            if (flare.customUpdateCallback) {
              flare.customUpdateCallback(flare);
            } else {
              flare.updateLensFlares();
            }
            gl.uniform1i(uniforms.renderType, 2);
            state.enable(gl.BLEND);
            for (var j = 0,
                jl = flare.lensFlares.length; j < jl; j++) {
              var sprite = flare.lensFlares[j];
              if (sprite.opacity > 0.001 && sprite.scale > 0.001) {
                screenPosition.x = sprite.x;
                screenPosition.y = sprite.y;
                screenPosition.z = sprite.z;
                size = sprite.size * sprite.scale / viewportHeight;
                scale.x = size * invAspect;
                scale.y = size;
                gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
                gl.uniform2f(uniforms.scale, scale.x, scale.y);
                gl.uniform1f(uniforms.rotation, sprite.rotation);
                gl.uniform1f(uniforms.opacity, sprite.opacity);
                gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b);
                state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst);
                renderer.setTexture(sprite.texture, 1);
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
              }
            }
          }
        }
        state.enable(gl.CULL_FACE);
        state.enable(gl.DEPTH_TEST);
        gl.depthMask(true);
        renderer.resetGLState();
      };
      function createProgram(shader) {
        var program = gl.createProgram();
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        var prefix = "precision " + renderer.getPrecision() + " float;\n";
        gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);
        gl.shaderSource(vertexShader, prefix + shader.vertexShader);
        gl.compileShader(fragmentShader);
        gl.compileShader(vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.attachShader(program, vertexShader);
        gl.linkProgram(program);
        return program;
      }
    };
    THREE.SpritePlugin = function(renderer, sprites) {
      var gl = renderer.context;
      var state = renderer.state;
      var vertexBuffer,
          elementBuffer;
      var program,
          attributes,
          uniforms;
      var texture;
      var spritePosition = new THREE.Vector3();
      var spriteRotation = new THREE.Quaternion();
      var spriteScale = new THREE.Vector3();
      function init() {
        var vertices = new Float32Array([-0.5, -0.5, 0, 0, 0.5, -0.5, 1, 0, 0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1]);
        var faces = new Uint16Array([0, 1, 2, 0, 2, 3]);
        vertexBuffer = gl.createBuffer();
        elementBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
        program = createProgram();
        attributes = {
          position: gl.getAttribLocation(program, 'position'),
          uv: gl.getAttribLocation(program, 'uv')
        };
        uniforms = {
          uvOffset: gl.getUniformLocation(program, 'uvOffset'),
          uvScale: gl.getUniformLocation(program, 'uvScale'),
          rotation: gl.getUniformLocation(program, 'rotation'),
          scale: gl.getUniformLocation(program, 'scale'),
          color: gl.getUniformLocation(program, 'color'),
          map: gl.getUniformLocation(program, 'map'),
          opacity: gl.getUniformLocation(program, 'opacity'),
          modelViewMatrix: gl.getUniformLocation(program, 'modelViewMatrix'),
          projectionMatrix: gl.getUniformLocation(program, 'projectionMatrix'),
          fogType: gl.getUniformLocation(program, 'fogType'),
          fogDensity: gl.getUniformLocation(program, 'fogDensity'),
          fogNear: gl.getUniformLocation(program, 'fogNear'),
          fogFar: gl.getUniformLocation(program, 'fogFar'),
          fogColor: gl.getUniformLocation(program, 'fogColor'),
          alphaTest: gl.getUniformLocation(program, 'alphaTest')
        };
        var canvas = document.createElement('canvas');
        canvas.width = 8;
        canvas.height = 8;
        var context = canvas.getContext('2d');
        context.fillStyle = 'white';
        context.fillRect(0, 0, 8, 8);
        texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
      }
      this.render = function(scene, camera) {
        if (sprites.length === 0)
          return;
        if (program === undefined) {
          init();
        }
        gl.useProgram(program);
        state.initAttributes();
        state.enableAttribute(attributes.position);
        state.enableAttribute(attributes.uv);
        state.disableUnusedAttributes();
        state.disable(gl.CULL_FACE);
        state.enable(gl.BLEND);
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);
        gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
        state.activeTexture(gl.TEXTURE0);
        gl.uniform1i(uniforms.map, 0);
        var oldFogType = 0;
        var sceneFogType = 0;
        var fog = scene.fog;
        if (fog) {
          gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
          if (fog instanceof THREE.Fog) {
            gl.uniform1f(uniforms.fogNear, fog.near);
            gl.uniform1f(uniforms.fogFar, fog.far);
            gl.uniform1i(uniforms.fogType, 1);
            oldFogType = 1;
            sceneFogType = 1;
          } else if (fog instanceof THREE.FogExp2) {
            gl.uniform1f(uniforms.fogDensity, fog.density);
            gl.uniform1i(uniforms.fogType, 2);
            oldFogType = 2;
            sceneFogType = 2;
          }
        } else {
          gl.uniform1i(uniforms.fogType, 0);
          oldFogType = 0;
          sceneFogType = 0;
        }
        for (var i = 0,
            l = sprites.length; i < l; i++) {
          var sprite = sprites[i];
          sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
          sprite.z = -sprite.modelViewMatrix.elements[14];
        }
        sprites.sort(painterSortStable);
        var scale = [];
        for (var i = 0,
            l = sprites.length; i < l; i++) {
          var sprite = sprites[i];
          var material = sprite.material;
          gl.uniform1f(uniforms.alphaTest, material.alphaTest);
          gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements);
          sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale);
          scale[0] = spriteScale.x;
          scale[1] = spriteScale.y;
          var fogType = 0;
          if (scene.fog && material.fog) {
            fogType = sceneFogType;
          }
          if (oldFogType !== fogType) {
            gl.uniform1i(uniforms.fogType, fogType);
            oldFogType = fogType;
          }
          if (material.map !== null) {
            gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
            gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);
          } else {
            gl.uniform2f(uniforms.uvOffset, 0, 0);
            gl.uniform2f(uniforms.uvScale, 1, 1);
          }
          gl.uniform1f(uniforms.opacity, material.opacity);
          gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);
          gl.uniform1f(uniforms.rotation, material.rotation);
          gl.uniform2fv(uniforms.scale, scale);
          state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
          state.setDepthTest(material.depthTest);
          state.setDepthWrite(material.depthWrite);
          if (material.map && material.map.image && material.map.image.width) {
            renderer.setTexture(material.map, 0);
          } else {
            renderer.setTexture(texture, 0);
          }
          gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        }
        state.enable(gl.CULL_FACE);
        renderer.resetGLState();
      };
      function createProgram() {
        var program = gl.createProgram();
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(vertexShader, ['precision ' + renderer.getPrecision() + ' float;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform float rotation;', 'uniform vec2 scale;', 'uniform vec2 uvOffset;', 'uniform vec2 uvScale;', 'attribute vec2 position;', 'attribute vec2 uv;', 'varying vec2 vUV;', 'void main() {', 'vUV = uvOffset + uv * uvScale;', 'vec2 alignedPosition = position * scale;', 'vec2 rotatedPosition;', 'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;', 'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;', 'vec4 finalPosition;', 'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );', 'finalPosition.xy += rotatedPosition;', 'finalPosition = projectionMatrix * finalPosition;', 'gl_Position = finalPosition;', '}'].join('\n'));
        gl.shaderSource(fragmentShader, ['precision ' + renderer.getPrecision() + ' float;', 'uniform vec3 color;', 'uniform sampler2D map;', 'uniform float opacity;', 'uniform int fogType;', 'uniform vec3 fogColor;', 'uniform float fogDensity;', 'uniform float fogNear;', 'uniform float fogFar;', 'uniform float alphaTest;', 'varying vec2 vUV;', 'void main() {', 'vec4 texture = texture2D( map, vUV );', 'if ( texture.a < alphaTest ) discard;', 'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );', 'if ( fogType > 0 ) {', 'float depth = gl_FragCoord.z / gl_FragCoord.w;', 'float fogFactor = 0.0;', 'if ( fogType == 1 ) {', 'fogFactor = smoothstep( fogNear, fogFar, depth );', '} else {', 'const float LOG2 = 1.442695;', 'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );', 'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );', '}', 'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );', '}', '}'].join('\n'));
        gl.compileShader(vertexShader);
        gl.compileShader(fragmentShader);
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        return program;
      }
      function painterSortStable(a, b) {
        if (a.z !== b.z) {
          return b.z - a.z;
        } else {
          return b.id - a.id;
        }
      }
    };
    THREE.CurveUtils = {
      tangentQuadraticBezier: function(t, p0, p1, p2) {
        return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
      },
      tangentCubicBezier: function(t, p0, p1, p2, p3) {
        return -3 * p0 * (1 - t) * (1 - t) + 3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) + 6 * t * p2 * (1 - t) - 3 * t * t * p2 + 3 * t * t * p3;
      },
      tangentSpline: function(t, p0, p1, p2, p3) {
        var h00 = 6 * t * t - 6 * t;
        var h10 = 3 * t * t - 4 * t + 1;
        var h01 = -6 * t * t + 6 * t;
        var h11 = 3 * t * t - 2 * t;
        return h00 + h10 + h01 + h11;
      },
      interpolate: function(p0, p1, p2, p3, t) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
      }
    };
    THREE.GeometryUtils = {
      merge: function(geometry1, geometry2, materialIndexOffset) {
        console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
        var matrix;
        if (geometry2 instanceof THREE.Mesh) {
          geometry2.matrixAutoUpdate && geometry2.updateMatrix();
          matrix = geometry2.matrix;
          geometry2 = geometry2.geometry;
        }
        geometry1.merge(geometry2, matrix, materialIndexOffset);
      },
      center: function(geometry) {
        console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
        return geometry.center();
      }
    };
    THREE.ImageUtils = {
      crossOrigin: undefined,
      loadTexture: function(url, mapping, onLoad, onError) {
        console.warn('THREE.ImageUtils.loadTexture is being deprecated. Use THREE.TextureLoader() instead.');
        var loader = new THREE.TextureLoader();
        loader.setCrossOrigin(this.crossOrigin);
        var texture = loader.load(url, onLoad, undefined, onError);
        if (mapping)
          texture.mapping = mapping;
        return texture;
      },
      loadTextureCube: function(urls, mapping, onLoad, onError) {
        console.warn('THREE.ImageUtils.loadTextureCube is being deprecated. Use THREE.CubeTextureLoader() instead.');
        var loader = new THREE.CubeTextureLoader();
        loader.setCrossOrigin(this.crossOrigin);
        var texture = loader.load(urls, onLoad, undefined, onError);
        if (mapping)
          texture.mapping = mapping;
        return texture;
      },
      loadCompressedTexture: function() {
        console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
      },
      loadCompressedTextureCube: function() {
        console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
      }
    };
    THREE.SceneUtils = {
      createMultiMaterialObject: function(geometry, materials) {
        var group = new THREE.Group();
        for (var i = 0,
            l = materials.length; i < l; i++) {
          group.add(new THREE.Mesh(geometry, materials[i]));
        }
        return group;
      },
      detach: function(child, parent, scene) {
        child.applyMatrix(parent.matrixWorld);
        parent.remove(child);
        scene.add(child);
      },
      attach: function(child, scene, parent) {
        var matrixWorldInverse = new THREE.Matrix4();
        matrixWorldInverse.getInverse(parent.matrixWorld);
        child.applyMatrix(matrixWorldInverse);
        scene.remove(child);
        parent.add(child);
      }
    };
    THREE.ShapeUtils = {
      area: function(contour) {
        var n = contour.length;
        var a = 0.0;
        for (var p = n - 1,
            q = 0; q < n; p = q++) {
          a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
        }
        return a * 0.5;
      },
      triangulate: (function() {
        function snip(contour, u, v, w, n, verts) {
          var p;
          var ax,
              ay,
              bx,
              by;
          var cx,
              cy,
              px,
              py;
          ax = contour[verts[u]].x;
          ay = contour[verts[u]].y;
          bx = contour[verts[v]].x;
          by = contour[verts[v]].y;
          cx = contour[verts[w]].x;
          cy = contour[verts[w]].y;
          if (Number.EPSILON > (((bx - ax) * (cy - ay)) - ((by - ay) * (cx - ax))))
            return false;
          var aX,
              aY,
              bX,
              bY,
              cX,
              cY;
          var apx,
              apy,
              bpx,
              bpy,
              cpx,
              cpy;
          var cCROSSap,
              bCROSScp,
              aCROSSbp;
          aX = cx - bx;
          aY = cy - by;
          bX = ax - cx;
          bY = ay - cy;
          cX = bx - ax;
          cY = by - ay;
          for (p = 0; p < n; p++) {
            px = contour[verts[p]].x;
            py = contour[verts[p]].y;
            if (((px === ax) && (py === ay)) || ((px === bx) && (py === by)) || ((px === cx) && (py === cy)))
              continue;
            apx = px - ax;
            apy = py - ay;
            bpx = px - bx;
            bpy = py - by;
            cpx = px - cx;
            cpy = py - cy;
            aCROSSbp = aX * bpy - aY * bpx;
            cCROSSap = cX * apy - cY * apx;
            bCROSScp = bX * cpy - bY * cpx;
            if ((aCROSSbp >= -Number.EPSILON) && (bCROSScp >= -Number.EPSILON) && (cCROSSap >= -Number.EPSILON))
              return false;
          }
          return true;
        }
        return function(contour, indices) {
          var n = contour.length;
          if (n < 3)
            return null;
          var result = [],
              verts = [],
              vertIndices = [];
          var u,
              v,
              w;
          if (THREE.ShapeUtils.area(contour) > 0.0) {
            for (v = 0; v < n; v++)
              verts[v] = v;
          } else {
            for (v = 0; v < n; v++)
              verts[v] = (n - 1) - v;
          }
          var nv = n;
          var count = 2 * nv;
          for (v = nv - 1; nv > 2; ) {
            if ((count--) <= 0) {
              console.warn('THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()');
              if (indices)
                return vertIndices;
              return result;
            }
            u = v;
            if (nv <= u)
              u = 0;
            v = u + 1;
            if (nv <= v)
              v = 0;
            w = v + 1;
            if (nv <= w)
              w = 0;
            if (snip(contour, u, v, w, nv, verts)) {
              var a,
                  b,
                  c,
                  s,
                  t;
              a = verts[u];
              b = verts[v];
              c = verts[w];
              result.push([contour[a], contour[b], contour[c]]);
              vertIndices.push([verts[u], verts[v], verts[w]]);
              for (s = v, t = v + 1; t < nv; s++, t++) {
                verts[s] = verts[t];
              }
              nv--;
              count = 2 * nv;
            }
          }
          if (indices)
            return vertIndices;
          return result;
        };
      })(),
      triangulateShape: function(contour, holes) {
        function point_in_segment_2D_colin(inSegPt1, inSegPt2, inOtherPt) {
          if (inSegPt1.x !== inSegPt2.x) {
            if (inSegPt1.x < inSegPt2.x) {
              return ((inSegPt1.x <= inOtherPt.x) && (inOtherPt.x <= inSegPt2.x));
            } else {
              return ((inSegPt2.x <= inOtherPt.x) && (inOtherPt.x <= inSegPt1.x));
            }
          } else {
            if (inSegPt1.y < inSegPt2.y) {
              return ((inSegPt1.y <= inOtherPt.y) && (inOtherPt.y <= inSegPt2.y));
            } else {
              return ((inSegPt2.y <= inOtherPt.y) && (inOtherPt.y <= inSegPt1.y));
            }
          }
        }
        function intersect_segments_2D(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs) {
          var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,
              seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
          var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,
              seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
          var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
          var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
          var limit = seg1dy * seg2dx - seg1dx * seg2dy;
          var perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
          if (Math.abs(limit) > Number.EPSILON) {
            var perpSeg2;
            if (limit > 0) {
              if ((perpSeg1 < 0) || (perpSeg1 > limit))
                return [];
              perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
              if ((perpSeg2 < 0) || (perpSeg2 > limit))
                return [];
            } else {
              if ((perpSeg1 > 0) || (perpSeg1 < limit))
                return [];
              perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
              if ((perpSeg2 > 0) || (perpSeg2 < limit))
                return [];
            }
            if (perpSeg2 === 0) {
              if ((inExcludeAdjacentSegs) && ((perpSeg1 === 0) || (perpSeg1 === limit)))
                return [];
              return [inSeg1Pt1];
            }
            if (perpSeg2 === limit) {
              if ((inExcludeAdjacentSegs) && ((perpSeg1 === 0) || (perpSeg1 === limit)))
                return [];
              return [inSeg1Pt2];
            }
            if (perpSeg1 === 0)
              return [inSeg2Pt1];
            if (perpSeg1 === limit)
              return [inSeg2Pt2];
            var factorSeg1 = perpSeg2 / limit;
            return [{
              x: inSeg1Pt1.x + factorSeg1 * seg1dx,
              y: inSeg1Pt1.y + factorSeg1 * seg1dy
            }];
          } else {
            if ((perpSeg1 !== 0) || (seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy))
              return [];
            var seg1Pt = ((seg1dx === 0) && (seg1dy === 0));
            var seg2Pt = ((seg2dx === 0) && (seg2dy === 0));
            if (seg1Pt && seg2Pt) {
              if ((inSeg1Pt1.x !== inSeg2Pt1.x) || (inSeg1Pt1.y !== inSeg2Pt1.y))
                return [];
              return [inSeg1Pt1];
            }
            if (seg1Pt) {
              if (!point_in_segment_2D_colin(inSeg2Pt1, inSeg2Pt2, inSeg1Pt1))
                return [];
              return [inSeg1Pt1];
            }
            if (seg2Pt) {
              if (!point_in_segment_2D_colin(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1))
                return [];
              return [inSeg2Pt1];
            }
            var seg1min,
                seg1max,
                seg1minVal,
                seg1maxVal;
            var seg2min,
                seg2max,
                seg2minVal,
                seg2maxVal;
            if (seg1dx !== 0) {
              if (inSeg1Pt1.x < inSeg1Pt2.x) {
                seg1min = inSeg1Pt1;
                seg1minVal = inSeg1Pt1.x;
                seg1max = inSeg1Pt2;
                seg1maxVal = inSeg1Pt2.x;
              } else {
                seg1min = inSeg1Pt2;
                seg1minVal = inSeg1Pt2.x;
                seg1max = inSeg1Pt1;
                seg1maxVal = inSeg1Pt1.x;
              }
              if (inSeg2Pt1.x < inSeg2Pt2.x) {
                seg2min = inSeg2Pt1;
                seg2minVal = inSeg2Pt1.x;
                seg2max = inSeg2Pt2;
                seg2maxVal = inSeg2Pt2.x;
              } else {
                seg2min = inSeg2Pt2;
                seg2minVal = inSeg2Pt2.x;
                seg2max = inSeg2Pt1;
                seg2maxVal = inSeg2Pt1.x;
              }
            } else {
              if (inSeg1Pt1.y < inSeg1Pt2.y) {
                seg1min = inSeg1Pt1;
                seg1minVal = inSeg1Pt1.y;
                seg1max = inSeg1Pt2;
                seg1maxVal = inSeg1Pt2.y;
              } else {
                seg1min = inSeg1Pt2;
                seg1minVal = inSeg1Pt2.y;
                seg1max = inSeg1Pt1;
                seg1maxVal = inSeg1Pt1.y;
              }
              if (inSeg2Pt1.y < inSeg2Pt2.y) {
                seg2min = inSeg2Pt1;
                seg2minVal = inSeg2Pt1.y;
                seg2max = inSeg2Pt2;
                seg2maxVal = inSeg2Pt2.y;
              } else {
                seg2min = inSeg2Pt2;
                seg2minVal = inSeg2Pt2.y;
                seg2max = inSeg2Pt1;
                seg2maxVal = inSeg2Pt1.y;
              }
            }
            if (seg1minVal <= seg2minVal) {
              if (seg1maxVal < seg2minVal)
                return [];
              if (seg1maxVal === seg2minVal) {
                if (inExcludeAdjacentSegs)
                  return [];
                return [seg2min];
              }
              if (seg1maxVal <= seg2maxVal)
                return [seg2min, seg1max];
              return [seg2min, seg2max];
            } else {
              if (seg1minVal > seg2maxVal)
                return [];
              if (seg1minVal === seg2maxVal) {
                if (inExcludeAdjacentSegs)
                  return [];
                return [seg1min];
              }
              if (seg1maxVal <= seg2maxVal)
                return [seg1min, seg1max];
              return [seg1min, seg2max];
            }
          }
        }
        function isPointInsideAngle(inVertex, inLegFromPt, inLegToPt, inOtherPt) {
          var legFromPtX = inLegFromPt.x - inVertex.x,
              legFromPtY = inLegFromPt.y - inVertex.y;
          var legToPtX = inLegToPt.x - inVertex.x,
              legToPtY = inLegToPt.y - inVertex.y;
          var otherPtX = inOtherPt.x - inVertex.x,
              otherPtY = inOtherPt.y - inVertex.y;
          var from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX;
          var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;
          if (Math.abs(from2toAngle) > Number.EPSILON) {
            var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
            if (from2toAngle > 0) {
              return ((from2otherAngle >= 0) && (other2toAngle >= 0));
            } else {
              return ((from2otherAngle >= 0) || (other2toAngle >= 0));
            }
          } else {
            return (from2otherAngle > 0);
          }
        }
        function removeHoles(contour, holes) {
          var shape = contour.concat();
          var hole;
          function isCutLineInsideAngles(inShapeIdx, inHoleIdx) {
            var lastShapeIdx = shape.length - 1;
            var prevShapeIdx = inShapeIdx - 1;
            if (prevShapeIdx < 0)
              prevShapeIdx = lastShapeIdx;
            var nextShapeIdx = inShapeIdx + 1;
            if (nextShapeIdx > lastShapeIdx)
              nextShapeIdx = 0;
            var insideAngle = isPointInsideAngle(shape[inShapeIdx], shape[prevShapeIdx], shape[nextShapeIdx], hole[inHoleIdx]);
            if (!insideAngle) {
              return false;
            }
            var lastHoleIdx = hole.length - 1;
            var prevHoleIdx = inHoleIdx - 1;
            if (prevHoleIdx < 0)
              prevHoleIdx = lastHoleIdx;
            var nextHoleIdx = inHoleIdx + 1;
            if (nextHoleIdx > lastHoleIdx)
              nextHoleIdx = 0;
            insideAngle = isPointInsideAngle(hole[inHoleIdx], hole[prevHoleIdx], hole[nextHoleIdx], shape[inShapeIdx]);
            if (!insideAngle) {
              return false;
            }
            return true;
          }
          function intersectsShapeEdge(inShapePt, inHolePt) {
            var sIdx,
                nextIdx,
                intersection;
            for (sIdx = 0; sIdx < shape.length; sIdx++) {
              nextIdx = sIdx + 1;
              nextIdx %= shape.length;
              intersection = intersect_segments_2D(inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true);
              if (intersection.length > 0)
                return true;
            }
            return false;
          }
          var indepHoles = [];
          function intersectsHoleEdge(inShapePt, inHolePt) {
            var ihIdx,
                chkHole,
                hIdx,
                nextIdx,
                intersection;
            for (ihIdx = 0; ihIdx < indepHoles.length; ihIdx++) {
              chkHole = holes[indepHoles[ihIdx]];
              for (hIdx = 0; hIdx < chkHole.length; hIdx++) {
                nextIdx = hIdx + 1;
                nextIdx %= chkHole.length;
                intersection = intersect_segments_2D(inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true);
                if (intersection.length > 0)
                  return true;
              }
            }
            return false;
          }
          var holeIndex,
              shapeIndex,
              shapePt,
              holePt,
              holeIdx,
              cutKey,
              failedCuts = [],
              tmpShape1,
              tmpShape2,
              tmpHole1,
              tmpHole2;
          for (var h = 0,
              hl = holes.length; h < hl; h++) {
            indepHoles.push(h);
          }
          var minShapeIndex = 0;
          var counter = indepHoles.length * 2;
          while (indepHoles.length > 0) {
            counter--;
            if (counter < 0) {
              console.log("Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!");
              break;
            }
            for (shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++) {
              shapePt = shape[shapeIndex];
              holeIndex = -1;
              for (var h = 0; h < indepHoles.length; h++) {
                holeIdx = indepHoles[h];
                cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
                if (failedCuts[cutKey] !== undefined)
                  continue;
                hole = holes[holeIdx];
                for (var h2 = 0; h2 < hole.length; h2++) {
                  holePt = hole[h2];
                  if (!isCutLineInsideAngles(shapeIndex, h2))
                    continue;
                  if (intersectsShapeEdge(shapePt, holePt))
                    continue;
                  if (intersectsHoleEdge(shapePt, holePt))
                    continue;
                  holeIndex = h2;
                  indepHoles.splice(h, 1);
                  tmpShape1 = shape.slice(0, shapeIndex + 1);
                  tmpShape2 = shape.slice(shapeIndex);
                  tmpHole1 = hole.slice(holeIndex);
                  tmpHole2 = hole.slice(0, holeIndex + 1);
                  shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);
                  minShapeIndex = shapeIndex;
                  break;
                }
                if (holeIndex >= 0)
                  break;
                failedCuts[cutKey] = true;
              }
              if (holeIndex >= 0)
                break;
            }
          }
          return shape;
        }
        var i,
            il,
            f,
            face,
            key,
            index,
            allPointsMap = {};
        var allpoints = contour.concat();
        for (var h = 0,
            hl = holes.length; h < hl; h++) {
          Array.prototype.push.apply(allpoints, holes[h]);
        }
        for (i = 0, il = allpoints.length; i < il; i++) {
          key = allpoints[i].x + ":" + allpoints[i].y;
          if (allPointsMap[key] !== undefined) {
            console.warn("THREE.Shape: Duplicate point", key);
          }
          allPointsMap[key] = i;
        }
        var shapeWithoutHoles = removeHoles(contour, holes);
        var triangles = THREE.ShapeUtils.triangulate(shapeWithoutHoles, false);
        for (i = 0, il = triangles.length; i < il; i++) {
          face = triangles[i];
          for (f = 0; f < 3; f++) {
            key = face[f].x + ":" + face[f].y;
            index = allPointsMap[key];
            if (index !== undefined) {
              face[f] = index;
            }
          }
        }
        return triangles.concat();
      },
      isClockWise: function(pts) {
        return THREE.ShapeUtils.area(pts) < 0;
      },
      b2: (function() {
        function b2p0(t, p) {
          var k = 1 - t;
          return k * k * p;
        }
        function b2p1(t, p) {
          return 2 * (1 - t) * t * p;
        }
        function b2p2(t, p) {
          return t * t * p;
        }
        return function(t, p0, p1, p2) {
          return b2p0(t, p0) + b2p1(t, p1) + b2p2(t, p2);
        };
      })(),
      b3: (function() {
        function b3p0(t, p) {
          var k = 1 - t;
          return k * k * k * p;
        }
        function b3p1(t, p) {
          var k = 1 - t;
          return 3 * k * k * t * p;
        }
        function b3p2(t, p) {
          var k = 1 - t;
          return 3 * k * t * t * p;
        }
        function b3p3(t, p) {
          return t * t * t * p;
        }
        return function(t, p0, p1, p2, p3) {
          return b3p0(t, p0) + b3p1(t, p1) + b3p2(t, p2) + b3p3(t, p3);
        };
      })()
    };
    THREE.Audio = function(listener) {
      THREE.Object3D.call(this);
      this.type = 'Audio';
      this.context = listener.context;
      this.source = this.context.createBufferSource();
      this.source.onended = this.onEnded.bind(this);
      this.gain = this.context.createGain();
      this.gain.connect(this.context.destination);
      this.panner = this.context.createPanner();
      this.panner.connect(this.gain);
      this.autoplay = false;
      this.startTime = 0;
      this.playbackRate = 1;
      this.isPlaying = false;
    };
    THREE.Audio.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Audio.prototype.constructor = THREE.Audio;
    THREE.Audio.prototype.load = function(file) {
      var scope = this;
      var request = new XMLHttpRequest();
      request.open('GET', file, true);
      request.responseType = 'arraybuffer';
      request.onload = function(e) {
        scope.context.decodeAudioData(this.response, function(buffer) {
          scope.source.buffer = buffer;
          if (scope.autoplay)
            scope.play();
        });
      };
      request.send();
      return this;
    };
    THREE.Audio.prototype.play = function() {
      if (this.isPlaying === true) {
        console.warn('THREE.Audio: Audio is already playing.');
        return;
      }
      var source = this.context.createBufferSource();
      source.buffer = this.source.buffer;
      source.loop = this.source.loop;
      source.onended = this.source.onended;
      source.start(0, this.startTime);
      source.playbackRate.value = this.playbackRate;
      this.isPlaying = true;
      this.source = source;
      this.connect();
    };
    THREE.Audio.prototype.pause = function() {
      this.source.stop();
      this.startTime = this.context.currentTime;
    };
    THREE.Audio.prototype.stop = function() {
      this.source.stop();
      this.startTime = 0;
    };
    THREE.Audio.prototype.connect = function() {
      if (this.filter !== undefined) {
        this.source.connect(this.filter);
        this.filter.connect(this.panner);
      } else {
        this.source.connect(this.panner);
      }
    };
    THREE.Audio.prototype.disconnect = function() {
      if (this.filter !== undefined) {
        this.source.disconnect(this.filter);
        this.filter.disconnect(this.panner);
      } else {
        this.source.disconnect(this.panner);
      }
    };
    THREE.Audio.prototype.setFilter = function(value) {
      if (this.isPlaying === true) {
        this.disconnect();
        this.filter = value;
        this.connect();
      } else {
        this.filter = value;
      }
    };
    THREE.Audio.prototype.getFilter = function() {
      return this.filter;
    };
    THREE.Audio.prototype.setPlaybackRate = function(value) {
      this.playbackRate = value;
      if (this.isPlaying === true) {
        this.source.playbackRate.value = this.playbackRate;
      }
    };
    THREE.Audio.prototype.getPlaybackRate = function() {
      return this.playbackRate;
    };
    THREE.Audio.prototype.onEnded = function() {
      this.isPlaying = false;
    };
    THREE.Audio.prototype.setLoop = function(value) {
      this.source.loop = value;
    };
    THREE.Audio.prototype.getLoop = function() {
      return this.source.loop;
    };
    THREE.Audio.prototype.setRefDistance = function(value) {
      this.panner.refDistance = value;
    };
    THREE.Audio.prototype.getRefDistance = function() {
      return this.panner.refDistance;
    };
    THREE.Audio.prototype.setRolloffFactor = function(value) {
      this.panner.rolloffFactor = value;
    };
    THREE.Audio.prototype.getRolloffFactor = function() {
      return this.panner.rolloffFactor;
    };
    THREE.Audio.prototype.setVolume = function(value) {
      this.gain.gain.value = value;
    };
    THREE.Audio.prototype.getVolume = function() {
      return this.gain.gain.value;
    };
    THREE.Audio.prototype.updateMatrixWorld = (function() {
      var position = new THREE.Vector3();
      return function updateMatrixWorld(force) {
        THREE.Object3D.prototype.updateMatrixWorld.call(this, force);
        position.setFromMatrixPosition(this.matrixWorld);
        this.panner.setPosition(position.x, position.y, position.z);
      };
    })();
    THREE.AudioListener = function() {
      THREE.Object3D.call(this);
      this.type = 'AudioListener';
      this.context = new (window.AudioContext || window.webkitAudioContext)();
    };
    THREE.AudioListener.prototype = Object.create(THREE.Object3D.prototype);
    THREE.AudioListener.prototype.constructor = THREE.AudioListener;
    THREE.AudioListener.prototype.updateMatrixWorld = (function() {
      var position = new THREE.Vector3();
      var quaternion = new THREE.Quaternion();
      var scale = new THREE.Vector3();
      var orientation = new THREE.Vector3();
      return function updateMatrixWorld(force) {
        THREE.Object3D.prototype.updateMatrixWorld.call(this, force);
        var listener = this.context.listener;
        var up = this.up;
        this.matrixWorld.decompose(position, quaternion, scale);
        orientation.set(0, 0, -1).applyQuaternion(quaternion);
        listener.setPosition(position.x, position.y, position.z);
        listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
      };
    })();
    THREE.Curve = function() {};
    THREE.Curve.prototype = {
      constructor: THREE.Curve,
      getPoint: function(t) {
        console.warn("THREE.Curve: Warning, getPoint() not implemented!");
        return null;
      },
      getPointAt: function(u) {
        var t = this.getUtoTmapping(u);
        return this.getPoint(t);
      },
      getPoints: function(divisions) {
        if (!divisions)
          divisions = 5;
        var d,
            pts = [];
        for (d = 0; d <= divisions; d++) {
          pts.push(this.getPoint(d / divisions));
        }
        return pts;
      },
      getSpacedPoints: function(divisions) {
        if (!divisions)
          divisions = 5;
        var d,
            pts = [];
        for (d = 0; d <= divisions; d++) {
          pts.push(this.getPointAt(d / divisions));
        }
        return pts;
      },
      getLength: function() {
        var lengths = this.getLengths();
        return lengths[lengths.length - 1];
      },
      getLengths: function(divisions) {
        if (!divisions)
          divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions) : 200;
        if (this.cacheArcLengths && (this.cacheArcLengths.length === divisions + 1) && !this.needsUpdate) {
          return this.cacheArcLengths;
        }
        this.needsUpdate = false;
        var cache = [];
        var current,
            last = this.getPoint(0);
        var p,
            sum = 0;
        cache.push(0);
        for (p = 1; p <= divisions; p++) {
          current = this.getPoint(p / divisions);
          sum += current.distanceTo(last);
          cache.push(sum);
          last = current;
        }
        this.cacheArcLengths = cache;
        return cache;
      },
      updateArcLengths: function() {
        this.needsUpdate = true;
        this.getLengths();
      },
      getUtoTmapping: function(u, distance) {
        var arcLengths = this.getLengths();
        var i = 0,
            il = arcLengths.length;
        var targetArcLength;
        if (distance) {
          targetArcLength = distance;
        } else {
          targetArcLength = u * arcLengths[il - 1];
        }
        var low = 0,
            high = il - 1,
            comparison;
        while (low <= high) {
          i = Math.floor(low + (high - low) / 2);
          comparison = arcLengths[i] - targetArcLength;
          if (comparison < 0) {
            low = i + 1;
          } else if (comparison > 0) {
            high = i - 1;
          } else {
            high = i;
            break;
          }
        }
        i = high;
        if (arcLengths[i] === targetArcLength) {
          var t = i / (il - 1);
          return t;
        }
        var lengthBefore = arcLengths[i];
        var lengthAfter = arcLengths[i + 1];
        var segmentLength = lengthAfter - lengthBefore;
        var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
        var t = (i + segmentFraction) / (il - 1);
        return t;
      },
      getTangent: function(t) {
        var delta = 0.0001;
        var t1 = t - delta;
        var t2 = t + delta;
        if (t1 < 0)
          t1 = 0;
        if (t2 > 1)
          t2 = 1;
        var pt1 = this.getPoint(t1);
        var pt2 = this.getPoint(t2);
        var vec = pt2.clone().sub(pt1);
        return vec.normalize();
      },
      getTangentAt: function(u) {
        var t = this.getUtoTmapping(u);
        return this.getTangent(t);
      }
    };
    THREE.Curve.Utils = THREE.CurveUtils;
    THREE.Curve.create = function(constructor, getPointFunc) {
      constructor.prototype = Object.create(THREE.Curve.prototype);
      constructor.prototype.constructor = constructor;
      constructor.prototype.getPoint = getPointFunc;
      return constructor;
    };
    THREE.CurvePath = function() {
      this.curves = [];
      this.autoClose = false;
    };
    THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype);
    THREE.CurvePath.prototype.constructor = THREE.CurvePath;
    THREE.CurvePath.prototype.add = function(curve) {
      this.curves.push(curve);
    };
    THREE.CurvePath.prototype.closePath = function() {
      var startPoint = this.curves[0].getPoint(0);
      var endPoint = this.curves[this.curves.length - 1].getPoint(1);
      if (!startPoint.equals(endPoint)) {
        this.curves.push(new THREE.LineCurve(endPoint, startPoint));
      }
    };
    THREE.CurvePath.prototype.getPoint = function(t) {
      var d = t * this.getLength();
      var curveLengths = this.getCurveLengths();
      var i = 0;
      while (i < curveLengths.length) {
        if (curveLengths[i] >= d) {
          var diff = curveLengths[i] - d;
          var curve = this.curves[i];
          var u = 1 - diff / curve.getLength();
          return curve.getPointAt(u);
        }
        i++;
      }
      return null;
    };
    THREE.CurvePath.prototype.getLength = function() {
      var lens = this.getCurveLengths();
      return lens[lens.length - 1];
    };
    THREE.CurvePath.prototype.getCurveLengths = function() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
        return this.cacheLengths;
      }
      var lengths = [],
          sums = 0;
      for (var i = 0,
          l = this.curves.length; i < l; i++) {
        sums += this.curves[i].getLength();
        lengths.push(sums);
      }
      this.cacheLengths = lengths;
      return lengths;
    };
    THREE.CurvePath.prototype.createPointsGeometry = function(divisions) {
      var pts = this.getPoints(divisions, true);
      return this.createGeometry(pts);
    };
    THREE.CurvePath.prototype.createSpacedPointsGeometry = function(divisions) {
      var pts = this.getSpacedPoints(divisions, true);
      return this.createGeometry(pts);
    };
    THREE.CurvePath.prototype.createGeometry = function(points) {
      var geometry = new THREE.Geometry();
      for (var i = 0,
          l = points.length; i < l; i++) {
        var point = points[i];
        geometry.vertices.push(new THREE.Vector3(point.x, point.y, point.z || 0));
      }
      return geometry;
    };
    THREE.Path = function(points) {
      THREE.CurvePath.call(this);
      this.actions = [];
      if (points) {
        this.fromPoints(points);
      }
    };
    THREE.Path.prototype = Object.create(THREE.CurvePath.prototype);
    THREE.Path.prototype.constructor = THREE.Path;
    THREE.Path.prototype.fromPoints = function(vectors) {
      this.moveTo(vectors[0].x, vectors[0].y);
      for (var i = 1,
          l = vectors.length; i < l; i++) {
        this.lineTo(vectors[i].x, vectors[i].y);
      }
    };
    THREE.Path.prototype.moveTo = function(x, y) {
      this.actions.push({
        action: 'moveTo',
        args: [x, y]
      });
    };
    THREE.Path.prototype.lineTo = function(x, y) {
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      var curve = new THREE.LineCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(x, y));
      this.curves.push(curve);
      this.actions.push({
        action: 'lineTo',
        args: [x, y]
      });
    };
    THREE.Path.prototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      var curve = new THREE.QuadraticBezierCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(aCPx, aCPy), new THREE.Vector2(aX, aY));
      this.curves.push(curve);
      this.actions.push({
        action: 'quadraticCurveTo',
        args: [aCPx, aCPy, aX, aY]
      });
    };
    THREE.Path.prototype.bezierCurveTo = function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      var curve = new THREE.CubicBezierCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(aCP1x, aCP1y), new THREE.Vector2(aCP2x, aCP2y), new THREE.Vector2(aX, aY));
      this.curves.push(curve);
      this.actions.push({
        action: 'bezierCurveTo',
        args: [aCP1x, aCP1y, aCP2x, aCP2y, aX, aY]
      });
    };
    THREE.Path.prototype.splineThru = function(pts) {
      var args = Array.prototype.slice.call(arguments);
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      var npts = [new THREE.Vector2(x0, y0)];
      Array.prototype.push.apply(npts, pts);
      var curve = new THREE.SplineCurve(npts);
      this.curves.push(curve);
      this.actions.push({
        action: 'splineThru',
        args: args
      });
    };
    THREE.Path.prototype.arc = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
    };
    THREE.Path.prototype.absarc = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    };
    THREE.Path.prototype.ellipse = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    };
    THREE.Path.prototype.absellipse = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
      var args = [aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation || 0];
      var curve = new THREE.EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
      this.curves.push(curve);
      var lastPoint = curve.getPoint(1);
      args.push(lastPoint.x);
      args.push(lastPoint.y);
      this.actions.push({
        action: 'ellipse',
        args: args
      });
    };
    THREE.Path.prototype.getSpacedPoints = function(divisions, closedPath) {
      if (!divisions)
        divisions = 40;
      var points = [];
      for (var i = 0; i < divisions; i++) {
        points.push(this.getPoint(i / divisions));
      }
      return points;
    };
    THREE.Path.prototype.getPoints = function(divisions, closedPath) {
      divisions = divisions || 12;
      var b2 = THREE.ShapeUtils.b2;
      var b3 = THREE.ShapeUtils.b3;
      var points = [];
      var cpx,
          cpy,
          cpx2,
          cpy2,
          cpx1,
          cpy1,
          cpx0,
          cpy0,
          laste,
          tx,
          ty;
      for (var i = 0,
          l = this.actions.length; i < l; i++) {
        var item = this.actions[i];
        var action = item.action;
        var args = item.args;
        switch (action) {
          case 'moveTo':
            points.push(new THREE.Vector2(args[0], args[1]));
            break;
          case 'lineTo':
            points.push(new THREE.Vector2(args[0], args[1]));
            break;
          case 'quadraticCurveTo':
            cpx = args[2];
            cpy = args[3];
            cpx1 = args[0];
            cpy1 = args[1];
            if (points.length > 0) {
              laste = points[points.length - 1];
              cpx0 = laste.x;
              cpy0 = laste.y;
            } else {
              laste = this.actions[i - 1].args;
              cpx0 = laste[laste.length - 2];
              cpy0 = laste[laste.length - 1];
            }
            for (var j = 1; j <= divisions; j++) {
              var t = j / divisions;
              tx = b2(t, cpx0, cpx1, cpx);
              ty = b2(t, cpy0, cpy1, cpy);
              points.push(new THREE.Vector2(tx, ty));
            }
            break;
          case 'bezierCurveTo':
            cpx = args[4];
            cpy = args[5];
            cpx1 = args[0];
            cpy1 = args[1];
            cpx2 = args[2];
            cpy2 = args[3];
            if (points.length > 0) {
              laste = points[points.length - 1];
              cpx0 = laste.x;
              cpy0 = laste.y;
            } else {
              laste = this.actions[i - 1].args;
              cpx0 = laste[laste.length - 2];
              cpy0 = laste[laste.length - 1];
            }
            for (var j = 1; j <= divisions; j++) {
              var t = j / divisions;
              tx = b3(t, cpx0, cpx1, cpx2, cpx);
              ty = b3(t, cpy0, cpy1, cpy2, cpy);
              points.push(new THREE.Vector2(tx, ty));
            }
            break;
          case 'splineThru':
            laste = this.actions[i - 1].args;
            var last = new THREE.Vector2(laste[laste.length - 2], laste[laste.length - 1]);
            var spts = [last];
            var n = divisions * args[0].length;
            spts = spts.concat(args[0]);
            var spline = new THREE.SplineCurve(spts);
            for (var j = 1; j <= n; j++) {
              points.push(spline.getPointAt(j / n));
            }
            break;
          case 'arc':
            var aX = args[0],
                aY = args[1],
                aRadius = args[2],
                aStartAngle = args[3],
                aEndAngle = args[4],
                aClockwise = !!args[5];
            var deltaAngle = aEndAngle - aStartAngle;
            var angle;
            var tdivisions = divisions * 2;
            for (var j = 1; j <= tdivisions; j++) {
              var t = j / tdivisions;
              if (!aClockwise) {
                t = 1 - t;
              }
              angle = aStartAngle + t * deltaAngle;
              tx = aX + aRadius * Math.cos(angle);
              ty = aY + aRadius * Math.sin(angle);
              points.push(new THREE.Vector2(tx, ty));
            }
            break;
          case 'ellipse':
            var aX = args[0],
                aY = args[1],
                xRadius = args[2],
                yRadius = args[3],
                aStartAngle = args[4],
                aEndAngle = args[5],
                aClockwise = !!args[6],
                aRotation = args[7];
            var deltaAngle = aEndAngle - aStartAngle;
            var angle;
            var tdivisions = divisions * 2;
            var cos,
                sin;
            if (aRotation !== 0) {
              cos = Math.cos(aRotation);
              sin = Math.sin(aRotation);
            }
            for (var j = 1; j <= tdivisions; j++) {
              var t = j / tdivisions;
              if (!aClockwise) {
                t = 1 - t;
              }
              angle = aStartAngle + t * deltaAngle;
              tx = aX + xRadius * Math.cos(angle);
              ty = aY + yRadius * Math.sin(angle);
              if (aRotation !== 0) {
                var x = tx,
                    y = ty;
                tx = (x - aX) * cos - (y - aY) * sin + aX;
                ty = (x - aX) * sin + (y - aY) * cos + aY;
              }
              points.push(new THREE.Vector2(tx, ty));
            }
            break;
        }
      }
      var lastPoint = points[points.length - 1];
      if (Math.abs(lastPoint.x - points[0].x) < Number.EPSILON && Math.abs(lastPoint.y - points[0].y) < Number.EPSILON)
        points.splice(points.length - 1, 1);
      if (closedPath) {
        points.push(points[0]);
      }
      return points;
    };
    THREE.Path.prototype.toShapes = function(isCCW, noHoles) {
      function extractSubpaths(inActions) {
        var subPaths = [],
            lastPath = new THREE.Path();
        for (var i = 0,
            l = inActions.length; i < l; i++) {
          var item = inActions[i];
          var args = item.args;
          var action = item.action;
          if (action === 'moveTo') {
            if (lastPath.actions.length !== 0) {
              subPaths.push(lastPath);
              lastPath = new THREE.Path();
            }
          }
          lastPath[action].apply(lastPath, args);
        }
        if (lastPath.actions.length !== 0) {
          subPaths.push(lastPath);
        }
        return subPaths;
      }
      function toShapesNoHoles(inSubpaths) {
        var shapes = [];
        for (var i = 0,
            l = inSubpaths.length; i < l; i++) {
          var tmpPath = inSubpaths[i];
          var tmpShape = new THREE.Shape();
          tmpShape.actions = tmpPath.actions;
          tmpShape.curves = tmpPath.curves;
          shapes.push(tmpShape);
        }
        return shapes;
      }
      function isPointInsidePolygon(inPt, inPolygon) {
        var polyLen = inPolygon.length;
        var inside = false;
        for (var p = polyLen - 1,
            q = 0; q < polyLen; p = q++) {
          var edgeLowPt = inPolygon[p];
          var edgeHighPt = inPolygon[q];
          var edgeDx = edgeHighPt.x - edgeLowPt.x;
          var edgeDy = edgeHighPt.y - edgeLowPt.y;
          if (Math.abs(edgeDy) > Number.EPSILON) {
            if (edgeDy < 0) {
              edgeLowPt = inPolygon[q];
              edgeDx = -edgeDx;
              edgeHighPt = inPolygon[p];
              edgeDy = -edgeDy;
            }
            if ((inPt.y < edgeLowPt.y) || (inPt.y > edgeHighPt.y))
              continue;
            if (inPt.y === edgeLowPt.y) {
              if (inPt.x === edgeLowPt.x)
                return true;
            } else {
              var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
              if (perpEdge === 0)
                return true;
              if (perpEdge < 0)
                continue;
              inside = !inside;
            }
          } else {
            if (inPt.y !== edgeLowPt.y)
              continue;
            if (((edgeHighPt.x <= inPt.x) && (inPt.x <= edgeLowPt.x)) || ((edgeLowPt.x <= inPt.x) && (inPt.x <= edgeHighPt.x)))
              return true;
          }
        }
        return inside;
      }
      var isClockWise = THREE.ShapeUtils.isClockWise;
      var subPaths = extractSubpaths(this.actions);
      if (subPaths.length === 0)
        return [];
      if (noHoles === true)
        return toShapesNoHoles(subPaths);
      var solid,
          tmpPath,
          tmpShape,
          shapes = [];
      if (subPaths.length === 1) {
        tmpPath = subPaths[0];
        tmpShape = new THREE.Shape();
        tmpShape.actions = tmpPath.actions;
        tmpShape.curves = tmpPath.curves;
        shapes.push(tmpShape);
        return shapes;
      }
      var holesFirst = !isClockWise(subPaths[0].getPoints());
      holesFirst = isCCW ? !holesFirst : holesFirst;
      var betterShapeHoles = [];
      var newShapes = [];
      var newShapeHoles = [];
      var mainIdx = 0;
      var tmpPoints;
      newShapes[mainIdx] = undefined;
      newShapeHoles[mainIdx] = [];
      for (var i = 0,
          l = subPaths.length; i < l; i++) {
        tmpPath = subPaths[i];
        tmpPoints = tmpPath.getPoints();
        solid = isClockWise(tmpPoints);
        solid = isCCW ? !solid : solid;
        if (solid) {
          if ((!holesFirst) && (newShapes[mainIdx]))
            mainIdx++;
          newShapes[mainIdx] = {
            s: new THREE.Shape(),
            p: tmpPoints
          };
          newShapes[mainIdx].s.actions = tmpPath.actions;
          newShapes[mainIdx].s.curves = tmpPath.curves;
          if (holesFirst)
            mainIdx++;
          newShapeHoles[mainIdx] = [];
        } else {
          newShapeHoles[mainIdx].push({
            h: tmpPath,
            p: tmpPoints[0]
          });
        }
      }
      if (!newShapes[0])
        return toShapesNoHoles(subPaths);
      if (newShapes.length > 1) {
        var ambiguous = false;
        var toChange = [];
        for (var sIdx = 0,
            sLen = newShapes.length; sIdx < sLen; sIdx++) {
          betterShapeHoles[sIdx] = [];
        }
        for (var sIdx = 0,
            sLen = newShapes.length; sIdx < sLen; sIdx++) {
          var sho = newShapeHoles[sIdx];
          for (var hIdx = 0; hIdx < sho.length; hIdx++) {
            var ho = sho[hIdx];
            var hole_unassigned = true;
            for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
              if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                if (sIdx !== s2Idx)
                  toChange.push({
                    froms: sIdx,
                    tos: s2Idx,
                    hole: hIdx
                  });
                if (hole_unassigned) {
                  hole_unassigned = false;
                  betterShapeHoles[s2Idx].push(ho);
                } else {
                  ambiguous = true;
                }
              }
            }
            if (hole_unassigned) {
              betterShapeHoles[sIdx].push(ho);
            }
          }
        }
        if (toChange.length > 0) {
          if (!ambiguous)
            newShapeHoles = betterShapeHoles;
        }
      }
      var tmpHoles;
      for (var i = 0,
          il = newShapes.length; i < il; i++) {
        tmpShape = newShapes[i].s;
        shapes.push(tmpShape);
        tmpHoles = newShapeHoles[i];
        for (var j = 0,
            jl = tmpHoles.length; j < jl; j++) {
          tmpShape.holes.push(tmpHoles[j].h);
        }
      }
      return shapes;
    };
    THREE.Shape = function() {
      THREE.Path.apply(this, arguments);
      this.holes = [];
    };
    THREE.Shape.prototype = Object.create(THREE.Path.prototype);
    THREE.Shape.prototype.constructor = THREE.Shape;
    THREE.Shape.prototype.extrude = function(options) {
      return new THREE.ExtrudeGeometry(this, options);
    };
    THREE.Shape.prototype.makeGeometry = function(options) {
      return new THREE.ShapeGeometry(this, options);
    };
    THREE.Shape.prototype.getPointsHoles = function(divisions) {
      var holesPts = [];
      for (var i = 0,
          l = this.holes.length; i < l; i++) {
        holesPts[i] = this.holes[i].getPoints(divisions);
      }
      return holesPts;
    };
    THREE.Shape.prototype.extractAllPoints = function(divisions) {
      return {
        shape: this.getPoints(divisions),
        holes: this.getPointsHoles(divisions)
      };
    };
    THREE.Shape.prototype.extractPoints = function(divisions) {
      return this.extractAllPoints(divisions);
    };
    THREE.Shape.Utils = THREE.ShapeUtils;
    THREE.LineCurve = function(v1, v2) {
      this.v1 = v1;
      this.v2 = v2;
    };
    THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.LineCurve.prototype.constructor = THREE.LineCurve;
    THREE.LineCurve.prototype.getPoint = function(t) {
      var point = this.v2.clone().sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
      return point;
    };
    THREE.LineCurve.prototype.getPointAt = function(u) {
      return this.getPoint(u);
    };
    THREE.LineCurve.prototype.getTangent = function(t) {
      var tangent = this.v2.clone().sub(this.v1);
      return tangent.normalize();
    };
    THREE.QuadraticBezierCurve = function(v0, v1, v2) {
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
    };
    THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;
    THREE.QuadraticBezierCurve.prototype.getPoint = function(t) {
      var b2 = THREE.ShapeUtils.b2;
      return new THREE.Vector2(b2(t, this.v0.x, this.v1.x, this.v2.x), b2(t, this.v0.y, this.v1.y, this.v2.y));
    };
    THREE.QuadraticBezierCurve.prototype.getTangent = function(t) {
      var tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;
      return new THREE.Vector2(tangentQuadraticBezier(t, this.v0.x, this.v1.x, this.v2.x), tangentQuadraticBezier(t, this.v0.y, this.v1.y, this.v2.y)).normalize();
    };
    THREE.CubicBezierCurve = function(v0, v1, v2, v3) {
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
      this.v3 = v3;
    };
    THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;
    THREE.CubicBezierCurve.prototype.getPoint = function(t) {
      var b3 = THREE.ShapeUtils.b3;
      return new THREE.Vector2(b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y));
    };
    THREE.CubicBezierCurve.prototype.getTangent = function(t) {
      var tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;
      return new THREE.Vector2(tangentCubicBezier(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), tangentCubicBezier(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y)).normalize();
    };
    THREE.SplineCurve = function(points) {
      this.points = (points == undefined) ? [] : points;
    };
    THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;
    THREE.SplineCurve.prototype.getPoint = function(t) {
      var points = this.points;
      var point = (points.length - 1) * t;
      var intPoint = Math.floor(point);
      var weight = point - intPoint;
      var point0 = points[intPoint === 0 ? intPoint : intPoint - 1];
      var point1 = points[intPoint];
      var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
      var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
      var interpolate = THREE.CurveUtils.interpolate;
      return new THREE.Vector2(interpolate(point0.x, point1.x, point2.x, point3.x, weight), interpolate(point0.y, point1.y, point2.y, point3.y, weight));
    };
    THREE.EllipseCurve = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
      this.aX = aX;
      this.aY = aY;
      this.xRadius = xRadius;
      this.yRadius = yRadius;
      this.aStartAngle = aStartAngle;
      this.aEndAngle = aEndAngle;
      this.aClockwise = aClockwise;
      this.aRotation = aRotation || 0;
    };
    THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;
    THREE.EllipseCurve.prototype.getPoint = function(t) {
      var deltaAngle = this.aEndAngle - this.aStartAngle;
      if (deltaAngle < 0)
        deltaAngle += Math.PI * 2;
      if (deltaAngle > Math.PI * 2)
        deltaAngle -= Math.PI * 2;
      var angle;
      if (this.aClockwise === true) {
        angle = this.aEndAngle + (1 - t) * (Math.PI * 2 - deltaAngle);
      } else {
        angle = this.aStartAngle + t * deltaAngle;
      }
      var x = this.aX + this.xRadius * Math.cos(angle);
      var y = this.aY + this.yRadius * Math.sin(angle);
      if (this.aRotation !== 0) {
        var cos = Math.cos(this.aRotation);
        var sin = Math.sin(this.aRotation);
        var tx = x,
            ty = y;
        x = (tx - this.aX) * cos - (ty - this.aY) * sin + this.aX;
        y = (tx - this.aX) * sin + (ty - this.aY) * cos + this.aY;
      }
      return new THREE.Vector2(x, y);
    };
    THREE.ArcCurve = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      THREE.EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    };
    THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype);
    THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;
    THREE.LineCurve3 = THREE.Curve.create(function(v1, v2) {
      this.v1 = v1;
      this.v2 = v2;
    }, function(t) {
      var vector = new THREE.Vector3();
      vector.subVectors(this.v2, this.v1);
      vector.multiplyScalar(t);
      vector.add(this.v1);
      return vector;
    });
    THREE.QuadraticBezierCurve3 = THREE.Curve.create(function(v0, v1, v2) {
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
    }, function(t) {
      var b2 = THREE.ShapeUtils.b2;
      return new THREE.Vector3(b2(t, this.v0.x, this.v1.x, this.v2.x), b2(t, this.v0.y, this.v1.y, this.v2.y), b2(t, this.v0.z, this.v1.z, this.v2.z));
    });
    THREE.CubicBezierCurve3 = THREE.Curve.create(function(v0, v1, v2, v3) {
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
      this.v3 = v3;
    }, function(t) {
      var b3 = THREE.ShapeUtils.b3;
      return new THREE.Vector3(b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y), b3(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z));
    });
    THREE.SplineCurve3 = THREE.Curve.create(function(points) {
      console.warn('THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3');
      this.points = (points == undefined) ? [] : points;
    }, function(t) {
      var points = this.points;
      var point = (points.length - 1) * t;
      var intPoint = Math.floor(point);
      var weight = point - intPoint;
      var point0 = points[intPoint == 0 ? intPoint : intPoint - 1];
      var point1 = points[intPoint];
      var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
      var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
      var interpolate = THREE.CurveUtils.interpolate;
      return new THREE.Vector3(interpolate(point0.x, point1.x, point2.x, point3.x, weight), interpolate(point0.y, point1.y, point2.y, point3.y, weight), interpolate(point0.z, point1.z, point2.z, point3.z, weight));
    });
    THREE.CatmullRomCurve3 = (function() {
      var tmp = new THREE.Vector3(),
          px = new CubicPoly(),
          py = new CubicPoly(),
          pz = new CubicPoly();
      function CubicPoly() {}
      CubicPoly.prototype.init = function(x0, x1, t0, t1) {
        this.c0 = x0;
        this.c1 = t0;
        this.c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
        this.c3 = 2 * x0 - 2 * x1 + t0 + t1;
      };
      CubicPoly.prototype.initNonuniformCatmullRom = function(x0, x1, x2, x3, dt0, dt1, dt2) {
        var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
        var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
        t1 *= dt1;
        t2 *= dt1;
        this.init(x1, x2, t1, t2);
      };
      CubicPoly.prototype.initCatmullRom = function(x0, x1, x2, x3, tension) {
        this.init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
      };
      CubicPoly.prototype.calc = function(t) {
        var t2 = t * t;
        var t3 = t2 * t;
        return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;
      };
      return THREE.Curve.create(function(p) {
        this.points = p || [];
      }, function(t) {
        var points = this.points,
            point,
            intPoint,
            weight,
            l;
        l = points.length;
        if (l < 2)
          console.log('duh, you need at least 2 points');
        point = (l - 1) * t;
        intPoint = Math.floor(point);
        weight = point - intPoint;
        if (weight === 0 && intPoint === l - 1) {
          intPoint = l - 2;
          weight = 1;
        }
        var p0,
            p1,
            p2,
            p3;
        if (intPoint === 0) {
          tmp.subVectors(points[0], points[1]).add(points[0]);
          p0 = tmp;
        } else {
          p0 = points[intPoint - 1];
        }
        p1 = points[intPoint];
        p2 = points[intPoint + 1];
        if (intPoint + 2 < l) {
          p3 = points[intPoint + 2];
        } else {
          tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 2]);
          p3 = tmp;
        }
        if (this.type === undefined || this.type === 'centripetal' || this.type === 'chordal') {
          var pow = this.type === 'chordal' ? 0.5 : 0.25;
          var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
          var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
          var dt2 = Math.pow(p2.distanceToSquared(p3), pow);
          if (dt1 < 1e-4)
            dt1 = 1.0;
          if (dt0 < 1e-4)
            dt0 = dt1;
          if (dt2 < 1e-4)
            dt2 = dt1;
          px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
          py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
          pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
        } else if (this.type === 'catmullrom') {
          var tension = this.tension !== undefined ? this.tension : 0.5;
          px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, tension);
          py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, tension);
          pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, tension);
        }
        var v = new THREE.Vector3(px.calc(weight), py.calc(weight), pz.calc(weight));
        return v;
      });
    })();
    THREE.ClosedSplineCurve3 = THREE.Curve.create(function(points) {
      this.points = (points == undefined) ? [] : points;
    }, function(t) {
      var points = this.points;
      var point = (points.length - 0) * t;
      var intPoint = Math.floor(point);
      var weight = point - intPoint;
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length;
      var point0 = points[(intPoint - 1) % points.length];
      var point1 = points[(intPoint) % points.length];
      var point2 = points[(intPoint + 1) % points.length];
      var point3 = points[(intPoint + 2) % points.length];
      var interpolate = THREE.CurveUtils.interpolate;
      return new THREE.Vector3(interpolate(point0.x, point1.x, point2.x, point3.x, weight), interpolate(point0.y, point1.y, point2.y, point3.y, weight), interpolate(point0.z, point1.z, point2.z, point3.z, weight));
    });
    THREE.BoxGeometry = function(width, height, depth, widthSegments, heightSegments, depthSegments) {
      THREE.Geometry.call(this);
      this.type = 'BoxGeometry';
      this.parameters = {
        width: width,
        height: height,
        depth: depth,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        depthSegments: depthSegments
      };
      this.widthSegments = widthSegments || 1;
      this.heightSegments = heightSegments || 1;
      this.depthSegments = depthSegments || 1;
      var scope = this;
      var width_half = width / 2;
      var height_half = height / 2;
      var depth_half = depth / 2;
      buildPlane('z', 'y', -1, -1, depth, height, width_half, 0);
      buildPlane('z', 'y', 1, -1, depth, height, -width_half, 1);
      buildPlane('x', 'z', 1, 1, width, depth, height_half, 2);
      buildPlane('x', 'z', 1, -1, width, depth, -height_half, 3);
      buildPlane('x', 'y', 1, -1, width, height, depth_half, 4);
      buildPlane('x', 'y', -1, -1, width, height, -depth_half, 5);
      function buildPlane(u, v, udir, vdir, width, height, depth, materialIndex) {
        var w,
            ix,
            iy,
            gridX = scope.widthSegments,
            gridY = scope.heightSegments,
            width_half = width / 2,
            height_half = height / 2,
            offset = scope.vertices.length;
        if ((u === 'x' && v === 'y') || (u === 'y' && v === 'x')) {
          w = 'z';
        } else if ((u === 'x' && v === 'z') || (u === 'z' && v === 'x')) {
          w = 'y';
          gridY = scope.depthSegments;
        } else if ((u === 'z' && v === 'y') || (u === 'y' && v === 'z')) {
          w = 'x';
          gridX = scope.depthSegments;
        }
        var gridX1 = gridX + 1,
            gridY1 = gridY + 1,
            segment_width = width / gridX,
            segment_height = height / gridY,
            normal = new THREE.Vector3();
        normal[w] = depth > 0 ? 1 : -1;
        for (iy = 0; iy < gridY1; iy++) {
          for (ix = 0; ix < gridX1; ix++) {
            var vector = new THREE.Vector3();
            vector[u] = (ix * segment_width - width_half) * udir;
            vector[v] = (iy * segment_height - height_half) * vdir;
            vector[w] = depth;
            scope.vertices.push(vector);
          }
        }
        for (iy = 0; iy < gridY; iy++) {
          for (ix = 0; ix < gridX; ix++) {
            var a = ix + gridX1 * iy;
            var b = ix + gridX1 * (iy + 1);
            var c = (ix + 1) + gridX1 * (iy + 1);
            var d = (ix + 1) + gridX1 * iy;
            var uva = new THREE.Vector2(ix / gridX, 1 - iy / gridY);
            var uvb = new THREE.Vector2(ix / gridX, 1 - (iy + 1) / gridY);
            var uvc = new THREE.Vector2((ix + 1) / gridX, 1 - (iy + 1) / gridY);
            var uvd = new THREE.Vector2((ix + 1) / gridX, 1 - iy / gridY);
            var face = new THREE.Face3(a + offset, b + offset, d + offset);
            face.normal.copy(normal);
            face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
            face.materialIndex = materialIndex;
            scope.faces.push(face);
            scope.faceVertexUvs[0].push([uva, uvb, uvd]);
            face = new THREE.Face3(b + offset, c + offset, d + offset);
            face.normal.copy(normal);
            face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
            face.materialIndex = materialIndex;
            scope.faces.push(face);
            scope.faceVertexUvs[0].push([uvb.clone(), uvc, uvd.clone()]);
          }
        }
      }
      this.mergeVertices();
    };
    THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;
    THREE.BoxGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.BoxGeometry(parameters.width, parameters.height, parameters.depth, parameters.widthSegments, parameters.heightSegments, parameters.depthSegments);
    };
    THREE.CubeGeometry = THREE.BoxGeometry;
    THREE.CircleGeometry = function(radius, segments, thetaStart, thetaLength) {
      THREE.Geometry.call(this);
      this.type = 'CircleGeometry';
      this.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      this.fromBufferGeometry(new THREE.CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
    };
    THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;
    THREE.CircleGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.CircleGeometry(parameters.radius, parameters.segments, parameters.thetaStart, parameters.thetaLength);
    };
    THREE.CircleBufferGeometry = function(radius, segments, thetaStart, thetaLength) {
      THREE.BufferGeometry.call(this);
      this.type = 'CircleBufferGeometry';
      this.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      radius = radius || 50;
      segments = segments !== undefined ? Math.max(3, segments) : 8;
      thetaStart = thetaStart !== undefined ? thetaStart : 0;
      thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
      var vertices = segments + 2;
      var positions = new Float32Array(vertices * 3);
      var normals = new Float32Array(vertices * 3);
      var uvs = new Float32Array(vertices * 2);
      normals[2] = 1.0;
      uvs[0] = 0.5;
      uvs[1] = 0.5;
      for (var s = 0,
          i = 3,
          ii = 2; s <= segments; s++, i += 3, ii += 2) {
        var segment = thetaStart + s / segments * thetaLength;
        positions[i] = radius * Math.cos(segment);
        positions[i + 1] = radius * Math.sin(segment);
        normals[i + 2] = 1;
        uvs[ii] = (positions[i] / radius + 1) / 2;
        uvs[ii + 1] = (positions[i + 1] / radius + 1) / 2;
      }
      var indices = [];
      for (var i = 1; i <= segments; i++) {
        indices.push(i, i + 1, 0);
      }
      this.setIndex(new THREE.BufferAttribute(new Uint16Array(indices), 1));
      this.addAttribute('position', new THREE.BufferAttribute(positions, 3));
      this.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
      this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
      this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
    };
    THREE.CircleBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;
    THREE.CircleBufferGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.CircleBufferGeometry(parameters.radius, parameters.segments, parameters.thetaStart, parameters.thetaLength);
    };
    THREE.CylinderGeometry = function(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
      THREE.Geometry.call(this);
      this.type = 'CylinderGeometry';
      this.parameters = {
        radiusTop: radiusTop,
        radiusBottom: radiusBottom,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      radiusTop = radiusTop !== undefined ? radiusTop : 20;
      radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
      height = height !== undefined ? height : 100;
      radialSegments = radialSegments || 8;
      heightSegments = heightSegments || 1;
      openEnded = openEnded !== undefined ? openEnded : false;
      thetaStart = thetaStart !== undefined ? thetaStart : 0;
      thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;
      var heightHalf = height / 2;
      var x,
          y,
          vertices = [],
          uvs = [];
      for (y = 0; y <= heightSegments; y++) {
        var verticesRow = [];
        var uvsRow = [];
        var v = y / heightSegments;
        var radius = v * (radiusBottom - radiusTop) + radiusTop;
        for (x = 0; x <= radialSegments; x++) {
          var u = x / radialSegments;
          var vertex = new THREE.Vector3();
          vertex.x = radius * Math.sin(u * thetaLength + thetaStart);
          vertex.y = -v * height + heightHalf;
          vertex.z = radius * Math.cos(u * thetaLength + thetaStart);
          this.vertices.push(vertex);
          verticesRow.push(this.vertices.length - 1);
          uvsRow.push(new THREE.Vector2(u, 1 - v));
        }
        vertices.push(verticesRow);
        uvs.push(uvsRow);
      }
      var tanTheta = (radiusBottom - radiusTop) / height;
      var na,
          nb;
      for (x = 0; x < radialSegments; x++) {
        if (radiusTop !== 0) {
          na = this.vertices[vertices[0][x]].clone();
          nb = this.vertices[vertices[0][x + 1]].clone();
        } else {
          na = this.vertices[vertices[1][x]].clone();
          nb = this.vertices[vertices[1][x + 1]].clone();
        }
        na.setY(Math.sqrt(na.x * na.x + na.z * na.z) * tanTheta).normalize();
        nb.setY(Math.sqrt(nb.x * nb.x + nb.z * nb.z) * tanTheta).normalize();
        for (y = 0; y < heightSegments; y++) {
          var v1 = vertices[y][x];
          var v2 = vertices[y + 1][x];
          var v3 = vertices[y + 1][x + 1];
          var v4 = vertices[y][x + 1];
          var n1 = na.clone();
          var n2 = na.clone();
          var n3 = nb.clone();
          var n4 = nb.clone();
          var uv1 = uvs[y][x].clone();
          var uv2 = uvs[y + 1][x].clone();
          var uv3 = uvs[y + 1][x + 1].clone();
          var uv4 = uvs[y][x + 1].clone();
          this.faces.push(new THREE.Face3(v1, v2, v4, [n1, n2, n4]));
          this.faceVertexUvs[0].push([uv1, uv2, uv4]);
          this.faces.push(new THREE.Face3(v2, v3, v4, [n2.clone(), n3, n4.clone()]));
          this.faceVertexUvs[0].push([uv2.clone(), uv3, uv4.clone()]);
        }
      }
      if (openEnded === false && radiusTop > 0) {
        this.vertices.push(new THREE.Vector3(0, heightHalf, 0));
        for (x = 0; x < radialSegments; x++) {
          var v1 = vertices[0][x];
          var v2 = vertices[0][x + 1];
          var v3 = this.vertices.length - 1;
          var n1 = new THREE.Vector3(0, 1, 0);
          var n2 = new THREE.Vector3(0, 1, 0);
          var n3 = new THREE.Vector3(0, 1, 0);
          var uv1 = uvs[0][x].clone();
          var uv2 = uvs[0][x + 1].clone();
          var uv3 = new THREE.Vector2(uv2.x, 0);
          this.faces.push(new THREE.Face3(v1, v2, v3, [n1, n2, n3], undefined, 1));
          this.faceVertexUvs[0].push([uv1, uv2, uv3]);
        }
      }
      if (openEnded === false && radiusBottom > 0) {
        this.vertices.push(new THREE.Vector3(0, -heightHalf, 0));
        for (x = 0; x < radialSegments; x++) {
          var v1 = vertices[heightSegments][x + 1];
          var v2 = vertices[heightSegments][x];
          var v3 = this.vertices.length - 1;
          var n1 = new THREE.Vector3(0, -1, 0);
          var n2 = new THREE.Vector3(0, -1, 0);
          var n3 = new THREE.Vector3(0, -1, 0);
          var uv1 = uvs[heightSegments][x + 1].clone();
          var uv2 = uvs[heightSegments][x].clone();
          var uv3 = new THREE.Vector2(uv2.x, 1);
          this.faces.push(new THREE.Face3(v1, v2, v3, [n1, n2, n3], undefined, 2));
          this.faceVertexUvs[0].push([uv1, uv2, uv3]);
        }
      }
      this.computeFaceNormals();
    };
    THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;
    THREE.CylinderGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.CylinderGeometry(parameters.radiusTop, parameters.radiusBottom, parameters.height, parameters.radialSegments, parameters.heightSegments, parameters.openEnded, parameters.thetaStart, parameters.thetaLength);
    };
    THREE.EdgesGeometry = function(geometry, thresholdAngle) {
      THREE.BufferGeometry.call(this);
      thresholdAngle = (thresholdAngle !== undefined) ? thresholdAngle : 1;
      var thresholdDot = Math.cos(THREE.Math.degToRad(thresholdAngle));
      var edge = [0, 0],
          hash = {};
      function sortFunction(a, b) {
        return a - b;
      }
      var keys = ['a', 'b', 'c'];
      var geometry2;
      if (geometry instanceof THREE.BufferGeometry) {
        geometry2 = new THREE.Geometry();
        geometry2.fromBufferGeometry(geometry);
      } else {
        geometry2 = geometry.clone();
      }
      geometry2.mergeVertices();
      geometry2.computeFaceNormals();
      var vertices = geometry2.vertices;
      var faces = geometry2.faces;
      for (var i = 0,
          l = faces.length; i < l; i++) {
        var face = faces[i];
        for (var j = 0; j < 3; j++) {
          edge[0] = face[keys[j]];
          edge[1] = face[keys[(j + 1) % 3]];
          edge.sort(sortFunction);
          var key = edge.toString();
          if (hash[key] === undefined) {
            hash[key] = {
              vert1: edge[0],
              vert2: edge[1],
              face1: i,
              face2: undefined
            };
          } else {
            hash[key].face2 = i;
          }
        }
      }
      var coords = [];
      for (var key in hash) {
        var h = hash[key];
        if (h.face2 === undefined || faces[h.face1].normal.dot(faces[h.face2].normal) <= thresholdDot) {
          var vertex = vertices[h.vert1];
          coords.push(vertex.x);
          coords.push(vertex.y);
          coords.push(vertex.z);
          vertex = vertices[h.vert2];
          coords.push(vertex.x);
          coords.push(vertex.y);
          coords.push(vertex.z);
        }
      }
      this.addAttribute('position', new THREE.BufferAttribute(new Float32Array(coords), 3));
    };
    THREE.EdgesGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;
    THREE.ExtrudeGeometry = function(shapes, options) {
      if (typeof(shapes) === "undefined") {
        shapes = [];
        return;
      }
      THREE.Geometry.call(this);
      this.type = 'ExtrudeGeometry';
      shapes = Array.isArray(shapes) ? shapes : [shapes];
      this.addShapeList(shapes, options);
      this.computeFaceNormals();
    };
    THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;
    THREE.ExtrudeGeometry.prototype.addShapeList = function(shapes, options) {
      var sl = shapes.length;
      for (var s = 0; s < sl; s++) {
        var shape = shapes[s];
        this.addShape(shape, options);
      }
    };
    THREE.ExtrudeGeometry.prototype.addShape = function(shape, options) {
      var amount = options.amount !== undefined ? options.amount : 100;
      var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
      var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
      var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
      var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
      var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
      var steps = options.steps !== undefined ? options.steps : 1;
      var extrudePath = options.extrudePath;
      var extrudePts,
          extrudeByPath = false;
      var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
      var splineTube,
          binormal,
          normal,
          position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);
        binormal = new THREE.Vector3();
        normal = new THREE.Vector3();
        position2 = new THREE.Vector3();
      }
      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
      }
      var ahole,
          h,
          hl;
      var scope = this;
      var shapesOffset = this.vertices.length;
      var shapePoints = shape.extractPoints(curveSegments);
      var vertices = shapePoints.shape;
      var holes = shapePoints.holes;
      var reverse = !THREE.ShapeUtils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];
          if (THREE.ShapeUtils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
          }
        }
        reverse = false;
      }
      var faces = THREE.ShapeUtils.triangulateShape(vertices, holes);
      var contour = vertices;
      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt, vec, size) {
        if (!vec)
          console.error("THREE.ExtrudeGeometry: vec does not exist");
        return vec.clone().multiplyScalar(size).add(pt);
      }
      var b,
          bs,
          t,
          z,
          vert,
          vlen = vertices.length,
          face,
          flen = faces.length;
      function getBevelVec(inPt, inPrev, inNext) {
        var v_trans_x,
            v_trans_y,
            shrink_by = 1;
        var v_prev_x = inPt.x - inPrev.x,
            v_prev_y = inPt.y - inPrev.y;
        var v_next_x = inNext.x - inPt.x,
            v_next_y = inNext.y - inPt.y;
        var v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y);
        var collinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);
        if (Math.abs(collinear0) > Number.EPSILON) {
          var v_prev_len = Math.sqrt(v_prev_lensq);
          var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
          var ptPrevShift_x = (inPrev.x - v_prev_y / v_prev_len);
          var ptPrevShift_y = (inPrev.y + v_prev_x / v_prev_len);
          var ptNextShift_x = (inNext.x - v_next_y / v_next_len);
          var ptNextShift_y = (inNext.y + v_next_x / v_next_len);
          var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt.x);
          v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt.y);
          var v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);
          if (v_trans_lensq <= 2) {
            return new THREE.Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          var direction_eq = false;
          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new THREE.Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      var contourMovements = [];
      for (var i = 0,
          il = contour.length,
          j = il - 1,
          k = i + 1; i < il; i++, j++, k++) {
        if (j === il)
          j = 0;
        if (k === il)
          k = 0;
        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
      }
      var holesMovements = [],
          oneHoleMovements,
          verticesMovements = contourMovements.concat();
      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        oneHoleMovements = [];
        for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
          if (j === il)
            j = 0;
          if (k === il)
            k = 0;
          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }
      for (b = 0; b < bevelSegments; b++) {
        t = b / bevelSegments;
        z = bevelThickness * (1 - t);
        bs = bevelSize * (Math.sin(t * Math.PI / 2));
        for (i = 0, il = contour.length; i < il; i++) {
          vert = scalePt2(contour[i], contourMovements[i], bs);
          v(vert.x, vert.y, -z);
        }
        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (i = 0, il = ahole.length; i < il; i++) {
            vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
            v(vert.x, vert.y, -z);
          }
        }
      }
      bs = bevelSize;
      for (i = 0; i < vlen; i++) {
        vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
        if (!extrudeByPath) {
          v(vert.x, vert.y, 0);
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      }
      var s;
      for (s = 1; s <= steps; s++) {
        for (i = 0; i < vlen; i++) {
          vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
          if (!extrudeByPath) {
            v(vert.x, vert.y, amount / steps * s);
          } else {
            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
      }
      for (b = bevelSegments - 1; b >= 0; b--) {
        t = b / bevelSegments;
        z = bevelThickness * (1 - t);
        bs = bevelSize * Math.sin(t * Math.PI / 2);
        for (i = 0, il = contour.length; i < il; i++) {
          vert = scalePt2(contour[i], contourMovements[i], bs);
          v(vert.x, vert.y, amount + z);
        }
        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (i = 0, il = ahole.length; i < il; i++) {
            vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
            if (!extrudeByPath) {
              v(vert.x, vert.y, amount + z);
            } else {
              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
            }
          }
        }
      }
      buildLidFaces();
      buildSideFaces();
      function buildLidFaces() {
        if (bevelEnabled) {
          var layer = 0;
          var offset = vlen * layer;
          for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }
          layer = steps + bevelSegments * 2;
          offset = vlen * layer;
          for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
          }
        } else {
          for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[2], face[1], face[0]);
          }
          for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }
      }
      function buildSideFaces() {
        var layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }
      }
      function sidewalls(contour, layeroffset) {
        var j,
            k;
        i = contour.length;
        while (--i >= 0) {
          j = i;
          k = i - 1;
          if (k < 0)
            k = contour.length - 1;
          var s = 0,
              sl = steps + bevelSegments * 2;
          for (s = 0; s < sl; s++) {
            var slen1 = vlen * s;
            var slen2 = vlen * (s + 1);
            var a = layeroffset + j + slen1,
                b = layeroffset + k + slen1,
                c = layeroffset + k + slen2,
                d = layeroffset + j + slen2;
            f4(a, b, c, d, contour, s, sl, j, k);
          }
        }
      }
      function v(x, y, z) {
        scope.vertices.push(new THREE.Vector3(x, y, z));
      }
      function f3(a, b, c) {
        a += shapesOffset;
        b += shapesOffset;
        c += shapesOffset;
        scope.faces.push(new THREE.Face3(a, b, c, null, null, 0));
        var uvs = uvgen.generateTopUV(scope, a, b, c);
        scope.faceVertexUvs[0].push(uvs);
      }
      function f4(a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2) {
        a += shapesOffset;
        b += shapesOffset;
        c += shapesOffset;
        d += shapesOffset;
        scope.faces.push(new THREE.Face3(a, b, d, null, null, 1));
        scope.faces.push(new THREE.Face3(b, c, d, null, null, 1));
        var uvs = uvgen.generateSideWallUV(scope, a, b, c, d);
        scope.faceVertexUvs[0].push([uvs[0], uvs[1], uvs[3]]);
        scope.faceVertexUvs[0].push([uvs[1], uvs[2], uvs[3]]);
      }
    };
    THREE.ExtrudeGeometry.WorldUVGenerator = {
      generateTopUV: function(geometry, indexA, indexB, indexC) {
        var vertices = geometry.vertices;
        var a = vertices[indexA];
        var b = vertices[indexB];
        var c = vertices[indexC];
        return [new THREE.Vector2(a.x, a.y), new THREE.Vector2(b.x, b.y), new THREE.Vector2(c.x, c.y)];
      },
      generateSideWallUV: function(geometry, indexA, indexB, indexC, indexD) {
        var vertices = geometry.vertices;
        var a = vertices[indexA];
        var b = vertices[indexB];
        var c = vertices[indexC];
        var d = vertices[indexD];
        if (Math.abs(a.y - b.y) < 0.01) {
          return [new THREE.Vector2(a.x, 1 - a.z), new THREE.Vector2(b.x, 1 - b.z), new THREE.Vector2(c.x, 1 - c.z), new THREE.Vector2(d.x, 1 - d.z)];
        } else {
          return [new THREE.Vector2(a.y, 1 - a.z), new THREE.Vector2(b.y, 1 - b.z), new THREE.Vector2(c.y, 1 - c.z), new THREE.Vector2(d.y, 1 - d.z)];
        }
      }
    };
    THREE.ShapeGeometry = function(shapes, options) {
      THREE.Geometry.call(this);
      this.type = 'ShapeGeometry';
      if (Array.isArray(shapes) === false)
        shapes = [shapes];
      this.addShapeList(shapes, options);
      this.computeFaceNormals();
    };
    THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;
    THREE.ShapeGeometry.prototype.addShapeList = function(shapes, options) {
      for (var i = 0,
          l = shapes.length; i < l; i++) {
        this.addShape(shapes[i], options);
      }
      return this;
    };
    THREE.ShapeGeometry.prototype.addShape = function(shape, options) {
      if (options === undefined)
        options = {};
      var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
      var material = options.material;
      var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;
      var i,
          l,
          hole;
      var shapesOffset = this.vertices.length;
      var shapePoints = shape.extractPoints(curveSegments);
      var vertices = shapePoints.shape;
      var holes = shapePoints.holes;
      var reverse = !THREE.ShapeUtils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (i = 0, l = holes.length; i < l; i++) {
          hole = holes[i];
          if (THREE.ShapeUtils.isClockWise(hole)) {
            holes[i] = hole.reverse();
          }
        }
        reverse = false;
      }
      var faces = THREE.ShapeUtils.triangulateShape(vertices, holes);
      for (i = 0, l = holes.length; i < l; i++) {
        hole = holes[i];
        vertices = vertices.concat(hole);
      }
      var vert,
          vlen = vertices.length;
      var face,
          flen = faces.length;
      for (i = 0; i < vlen; i++) {
        vert = vertices[i];
        this.vertices.push(new THREE.Vector3(vert.x, vert.y, 0));
      }
      for (i = 0; i < flen; i++) {
        face = faces[i];
        var a = face[0] + shapesOffset;
        var b = face[1] + shapesOffset;
        var c = face[2] + shapesOffset;
        this.faces.push(new THREE.Face3(a, b, c, null, null, material));
        this.faceVertexUvs[0].push(uvgen.generateTopUV(this, a, b, c));
      }
    };
    THREE.LatheGeometry = function(points, segments, phiStart, phiLength) {
      THREE.Geometry.call(this);
      this.type = 'LatheGeometry';
      this.parameters = {
        points: points,
        segments: segments,
        phiStart: phiStart,
        phiLength: phiLength
      };
      segments = segments || 12;
      phiStart = phiStart || 0;
      phiLength = phiLength || 2 * Math.PI;
      var inversePointLength = 1.0 / (points.length - 1);
      var inverseSegments = 1.0 / segments;
      for (var i = 0,
          il = segments; i <= il; i++) {
        var phi = phiStart + i * inverseSegments * phiLength;
        var c = Math.cos(phi),
            s = Math.sin(phi);
        for (var j = 0,
            jl = points.length; j < jl; j++) {
          var pt = points[j];
          var vertex = new THREE.Vector3();
          vertex.x = c * pt.x - s * pt.y;
          vertex.y = s * pt.x + c * pt.y;
          vertex.z = pt.z;
          this.vertices.push(vertex);
        }
      }
      var np = points.length;
      for (var i = 0,
          il = segments; i < il; i++) {
        for (var j = 0,
            jl = points.length - 1; j < jl; j++) {
          var base = j + np * i;
          var a = base;
          var b = base + np;
          var c = base + 1 + np;
          var d = base + 1;
          var u0 = i * inverseSegments;
          var v0 = j * inversePointLength;
          var u1 = u0 + inverseSegments;
          var v1 = v0 + inversePointLength;
          this.faces.push(new THREE.Face3(a, b, d));
          this.faceVertexUvs[0].push([new THREE.Vector2(u0, v0), new THREE.Vector2(u1, v0), new THREE.Vector2(u0, v1)]);
          this.faces.push(new THREE.Face3(b, c, d));
          this.faceVertexUvs[0].push([new THREE.Vector2(u1, v0), new THREE.Vector2(u1, v1), new THREE.Vector2(u0, v1)]);
        }
      }
      this.mergeVertices();
      this.computeFaceNormals();
      this.computeVertexNormals();
    };
    THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;
    THREE.PlaneGeometry = function(width, height, widthSegments, heightSegments) {
      THREE.Geometry.call(this);
      this.type = 'PlaneGeometry';
      this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
      };
      this.fromBufferGeometry(new THREE.PlaneBufferGeometry(width, height, widthSegments, heightSegments));
    };
    THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;
    THREE.PlaneGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.PlaneGeometry(parameters.width, parameters.height, parameters.widthSegments, parameters.heightSegments);
    };
    THREE.PlaneBufferGeometry = function(width, height, widthSegments, heightSegments) {
      THREE.BufferGeometry.call(this);
      this.type = 'PlaneBufferGeometry';
      this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
      };
      var width_half = width / 2;
      var height_half = height / 2;
      var gridX = Math.floor(widthSegments) || 1;
      var gridY = Math.floor(heightSegments) || 1;
      var gridX1 = gridX + 1;
      var gridY1 = gridY + 1;
      var segment_width = width / gridX;
      var segment_height = height / gridY;
      var vertices = new Float32Array(gridX1 * gridY1 * 3);
      var normals = new Float32Array(gridX1 * gridY1 * 3);
      var uvs = new Float32Array(gridX1 * gridY1 * 2);
      var offset = 0;
      var offset2 = 0;
      for (var iy = 0; iy < gridY1; iy++) {
        var y = iy * segment_height - height_half;
        for (var ix = 0; ix < gridX1; ix++) {
          var x = ix * segment_width - width_half;
          vertices[offset] = x;
          vertices[offset + 1] = -y;
          normals[offset + 2] = 1;
          uvs[offset2] = ix / gridX;
          uvs[offset2 + 1] = 1 - (iy / gridY);
          offset += 3;
          offset2 += 2;
        }
      }
      offset = 0;
      var indices = new ((vertices.length / 3) > 65535 ? Uint32Array : Uint16Array)(gridX * gridY * 6);
      for (var iy = 0; iy < gridY; iy++) {
        for (var ix = 0; ix < gridX; ix++) {
          var a = ix + gridX1 * iy;
          var b = ix + gridX1 * (iy + 1);
          var c = (ix + 1) + gridX1 * (iy + 1);
          var d = (ix + 1) + gridX1 * iy;
          indices[offset] = a;
          indices[offset + 1] = b;
          indices[offset + 2] = d;
          indices[offset + 3] = b;
          indices[offset + 4] = c;
          indices[offset + 5] = d;
          offset += 6;
        }
      }
      this.setIndex(new THREE.BufferAttribute(indices, 1));
      this.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
      this.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
      this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
    };
    THREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;
    THREE.PlaneBufferGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.PlaneBufferGeometry(parameters.width, parameters.height, parameters.widthSegments, parameters.heightSegments);
    };
    THREE.RingGeometry = function(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
      THREE.Geometry.call(this);
      this.type = 'RingGeometry';
      this.parameters = {
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        thetaSegments: thetaSegments,
        phiSegments: phiSegments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      innerRadius = innerRadius || 0;
      outerRadius = outerRadius || 50;
      thetaStart = thetaStart !== undefined ? thetaStart : 0;
      thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
      thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
      phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 8;
      var i,
          o,
          uvs = [],
          radius = innerRadius,
          radiusStep = ((outerRadius - innerRadius) / phiSegments);
      for (i = 0; i < phiSegments + 1; i++) {
        for (o = 0; o < thetaSegments + 1; o++) {
          var vertex = new THREE.Vector3();
          var segment = thetaStart + o / thetaSegments * thetaLength;
          vertex.x = radius * Math.cos(segment);
          vertex.y = radius * Math.sin(segment);
          this.vertices.push(vertex);
          uvs.push(new THREE.Vector2((vertex.x / outerRadius + 1) / 2, (vertex.y / outerRadius + 1) / 2));
        }
        radius += radiusStep;
      }
      var n = new THREE.Vector3(0, 0, 1);
      for (i = 0; i < phiSegments; i++) {
        var thetaSegment = i * (thetaSegments + 1);
        for (o = 0; o < thetaSegments; o++) {
          var segment = o + thetaSegment;
          var v1 = segment;
          var v2 = segment + thetaSegments + 1;
          var v3 = segment + thetaSegments + 2;
          this.faces.push(new THREE.Face3(v1, v2, v3, [n.clone(), n.clone(), n.clone()]));
          this.faceVertexUvs[0].push([uvs[v1].clone(), uvs[v2].clone(), uvs[v3].clone()]);
          v1 = segment;
          v2 = segment + thetaSegments + 2;
          v3 = segment + 1;
          this.faces.push(new THREE.Face3(v1, v2, v3, [n.clone(), n.clone(), n.clone()]));
          this.faceVertexUvs[0].push([uvs[v1].clone(), uvs[v2].clone(), uvs[v3].clone()]);
        }
      }
      this.computeFaceNormals();
      this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
    };
    THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;
    THREE.RingGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.RingGeometry(parameters.innerRadius, parameters.outerRadius, parameters.thetaSegments, parameters.phiSegments, parameters.thetaStart, parameters.thetaLength);
    };
    THREE.SphereGeometry = function(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
      THREE.Geometry.call(this);
      this.type = 'SphereGeometry';
      this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      this.fromBufferGeometry(new THREE.SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
    };
    THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;
    THREE.SphereGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.SphereGeometry(parameters.radius, parameters.widthSegments, parameters.heightSegments, parameters.phiStart, parameters.phiLength, parameters.thetaStart, parameters.thetaLength);
    };
    THREE.SphereBufferGeometry = function(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
      THREE.BufferGeometry.call(this);
      this.type = 'SphereBufferGeometry';
      this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      radius = radius || 50;
      widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
      heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
      phiStart = phiStart !== undefined ? phiStart : 0;
      phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
      thetaStart = thetaStart !== undefined ? thetaStart : 0;
      thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
      var thetaEnd = thetaStart + thetaLength;
      var vertexCount = ((widthSegments + 1) * (heightSegments + 1));
      var positions = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
      var normals = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
      var uvs = new THREE.BufferAttribute(new Float32Array(vertexCount * 2), 2);
      var index = 0,
          vertices = [],
          normal = new THREE.Vector3();
      for (var y = 0; y <= heightSegments; y++) {
        var verticesRow = [];
        var v = y / heightSegments;
        for (var x = 0; x <= widthSegments; x++) {
          var u = x / widthSegments;
          var px = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
          var py = radius * Math.cos(thetaStart + v * thetaLength);
          var pz = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
          normal.set(px, py, pz).normalize();
          positions.setXYZ(index, px, py, pz);
          normals.setXYZ(index, normal.x, normal.y, normal.z);
          uvs.setXY(index, u, 1 - v);
          verticesRow.push(index);
          index++;
        }
        vertices.push(verticesRow);
      }
      var indices = [];
      for (var y = 0; y < heightSegments; y++) {
        for (var x = 0; x < widthSegments; x++) {
          var v1 = vertices[y][x + 1];
          var v2 = vertices[y][x];
          var v3 = vertices[y + 1][x];
          var v4 = vertices[y + 1][x + 1];
          if (y !== 0 || thetaStart > 0)
            indices.push(v1, v2, v4);
          if (y !== heightSegments - 1 || thetaEnd < Math.PI)
            indices.push(v2, v3, v4);
        }
      }
      this.setIndex(new (positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute)(indices, 1));
      this.addAttribute('position', positions);
      this.addAttribute('normal', normals);
      this.addAttribute('uv', uvs);
      this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
    };
    THREE.SphereBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;
    THREE.SphereBufferGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.SphereBufferGeometry(parameters.radius, parameters.widthSegments, parameters.heightSegments, parameters.phiStart, parameters.phiLength, parameters.thetaStart, parameters.thetaLength);
    };
    THREE.TorusGeometry = function(radius, tube, radialSegments, tubularSegments, arc) {
      THREE.Geometry.call(this);
      this.type = 'TorusGeometry';
      this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        arc: arc
      };
      radius = radius || 100;
      tube = tube || 40;
      radialSegments = radialSegments || 8;
      tubularSegments = tubularSegments || 6;
      arc = arc || Math.PI * 2;
      var center = new THREE.Vector3(),
          uvs = [],
          normals = [];
      for (var j = 0; j <= radialSegments; j++) {
        for (var i = 0; i <= tubularSegments; i++) {
          var u = i / tubularSegments * arc;
          var v = j / radialSegments * Math.PI * 2;
          center.x = radius * Math.cos(u);
          center.y = radius * Math.sin(u);
          var vertex = new THREE.Vector3();
          vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
          vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
          vertex.z = tube * Math.sin(v);
          this.vertices.push(vertex);
          uvs.push(new THREE.Vector2(i / tubularSegments, j / radialSegments));
          normals.push(vertex.clone().sub(center).normalize());
        }
      }
      for (var j = 1; j <= radialSegments; j++) {
        for (var i = 1; i <= tubularSegments; i++) {
          var a = (tubularSegments + 1) * j + i - 1;
          var b = (tubularSegments + 1) * (j - 1) + i - 1;
          var c = (tubularSegments + 1) * (j - 1) + i;
          var d = (tubularSegments + 1) * j + i;
          var face = new THREE.Face3(a, b, d, [normals[a].clone(), normals[b].clone(), normals[d].clone()]);
          this.faces.push(face);
          this.faceVertexUvs[0].push([uvs[a].clone(), uvs[b].clone(), uvs[d].clone()]);
          face = new THREE.Face3(b, c, d, [normals[b].clone(), normals[c].clone(), normals[d].clone()]);
          this.faces.push(face);
          this.faceVertexUvs[0].push([uvs[b].clone(), uvs[c].clone(), uvs[d].clone()]);
        }
      }
      this.computeFaceNormals();
    };
    THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;
    THREE.TorusGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.TorusGeometry(parameters.radius, parameters.tube, parameters.radialSegments, parameters.tubularSegments, parameters.arc);
    };
    THREE.TorusKnotGeometry = function(radius, tube, radialSegments, tubularSegments, p, q, heightScale) {
      THREE.Geometry.call(this);
      this.type = 'TorusKnotGeometry';
      this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        p: p,
        q: q,
        heightScale: heightScale
      };
      radius = radius || 100;
      tube = tube || 40;
      radialSegments = radialSegments || 64;
      tubularSegments = tubularSegments || 8;
      p = p || 2;
      q = q || 3;
      heightScale = heightScale || 1;
      var grid = new Array(radialSegments);
      var tang = new THREE.Vector3();
      var n = new THREE.Vector3();
      var bitan = new THREE.Vector3();
      for (var i = 0; i < radialSegments; ++i) {
        grid[i] = new Array(tubularSegments);
        var u = i / radialSegments * 2 * p * Math.PI;
        var p1 = getPos(u, q, p, radius, heightScale);
        var p2 = getPos(u + 0.01, q, p, radius, heightScale);
        tang.subVectors(p2, p1);
        n.addVectors(p2, p1);
        bitan.crossVectors(tang, n);
        n.crossVectors(bitan, tang);
        bitan.normalize();
        n.normalize();
        for (var j = 0; j < tubularSegments; ++j) {
          var v = j / tubularSegments * 2 * Math.PI;
          var cx = -tube * Math.cos(v);
          var cy = tube * Math.sin(v);
          var pos = new THREE.Vector3();
          pos.x = p1.x + cx * n.x + cy * bitan.x;
          pos.y = p1.y + cx * n.y + cy * bitan.y;
          pos.z = p1.z + cx * n.z + cy * bitan.z;
          grid[i][j] = this.vertices.push(pos) - 1;
        }
      }
      for (var i = 0; i < radialSegments; ++i) {
        for (var j = 0; j < tubularSegments; ++j) {
          var ip = (i + 1) % radialSegments;
          var jp = (j + 1) % tubularSegments;
          var a = grid[i][j];
          var b = grid[ip][j];
          var c = grid[ip][jp];
          var d = grid[i][jp];
          var uva = new THREE.Vector2(i / radialSegments, j / tubularSegments);
          var uvb = new THREE.Vector2((i + 1) / radialSegments, j / tubularSegments);
          var uvc = new THREE.Vector2((i + 1) / radialSegments, (j + 1) / tubularSegments);
          var uvd = new THREE.Vector2(i / radialSegments, (j + 1) / tubularSegments);
          this.faces.push(new THREE.Face3(a, b, d));
          this.faceVertexUvs[0].push([uva, uvb, uvd]);
          this.faces.push(new THREE.Face3(b, c, d));
          this.faceVertexUvs[0].push([uvb.clone(), uvc, uvd.clone()]);
        }
      }
      this.computeFaceNormals();
      this.computeVertexNormals();
      function getPos(u, in_q, in_p, radius, heightScale) {
        var cu = Math.cos(u);
        var su = Math.sin(u);
        var quOverP = in_q / in_p * u;
        var cs = Math.cos(quOverP);
        var tx = radius * (2 + cs) * 0.5 * cu;
        var ty = radius * (2 + cs) * su * 0.5;
        var tz = heightScale * radius * Math.sin(quOverP) * 0.5;
        return new THREE.Vector3(tx, ty, tz);
      }
    };
    THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;
    THREE.TorusKnotGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.TorusKnotGeometry(parameters.radius, parameters.tube, parameters.radialSegments, parameters.tubularSegments, parameters.p, parameters.q, parameters.heightScale);
    };
    THREE.TubeGeometry = function(path, segments, radius, radialSegments, closed, taper) {
      THREE.Geometry.call(this);
      this.type = 'TubeGeometry';
      this.parameters = {
        path: path,
        segments: segments,
        radius: radius,
        radialSegments: radialSegments,
        closed: closed,
        taper: taper
      };
      segments = segments || 64;
      radius = radius || 1;
      radialSegments = radialSegments || 8;
      closed = closed || false;
      taper = taper || THREE.TubeGeometry.NoTaper;
      var grid = [];
      var scope = this,
          tangent,
          normal,
          binormal,
          numpoints = segments + 1,
          u,
          v,
          r,
          cx,
          cy,
          pos,
          pos2 = new THREE.Vector3(),
          i,
          j,
          ip,
          jp,
          a,
          b,
          c,
          d,
          uva,
          uvb,
          uvc,
          uvd;
      var frames = new THREE.TubeGeometry.FrenetFrames(path, segments, closed),
          tangents = frames.tangents,
          normals = frames.normals,
          binormals = frames.binormals;
      this.tangents = tangents;
      this.normals = normals;
      this.binormals = binormals;
      function vert(x, y, z) {
        return scope.vertices.push(new THREE.Vector3(x, y, z)) - 1;
      }
      for (i = 0; i < numpoints; i++) {
        grid[i] = [];
        u = i / (numpoints - 1);
        pos = path.getPointAt(u);
        tangent = tangents[i];
        normal = normals[i];
        binormal = binormals[i];
        r = radius * taper(u);
        for (j = 0; j < radialSegments; j++) {
          v = j / radialSegments * 2 * Math.PI;
          cx = -r * Math.cos(v);
          cy = r * Math.sin(v);
          pos2.copy(pos);
          pos2.x += cx * normal.x + cy * binormal.x;
          pos2.y += cx * normal.y + cy * binormal.y;
          pos2.z += cx * normal.z + cy * binormal.z;
          grid[i][j] = vert(pos2.x, pos2.y, pos2.z);
        }
      }
      for (i = 0; i < segments; i++) {
        for (j = 0; j < radialSegments; j++) {
          ip = (closed) ? (i + 1) % segments : i + 1;
          jp = (j + 1) % radialSegments;
          a = grid[i][j];
          b = grid[ip][j];
          c = grid[ip][jp];
          d = grid[i][jp];
          uva = new THREE.Vector2(i / segments, j / radialSegments);
          uvb = new THREE.Vector2((i + 1) / segments, j / radialSegments);
          uvc = new THREE.Vector2((i + 1) / segments, (j + 1) / radialSegments);
          uvd = new THREE.Vector2(i / segments, (j + 1) / radialSegments);
          this.faces.push(new THREE.Face3(a, b, d));
          this.faceVertexUvs[0].push([uva, uvb, uvd]);
          this.faces.push(new THREE.Face3(b, c, d));
          this.faceVertexUvs[0].push([uvb.clone(), uvc, uvd.clone()]);
        }
      }
      this.computeFaceNormals();
      this.computeVertexNormals();
    };
    THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;
    THREE.TubeGeometry.prototype.clone = function() {
      return new this.constructor(this.parameters.path, this.parameters.segments, this.parameters.radius, this.parameters.radialSegments, this.parameters.closed, this.parameters.taper);
    };
    THREE.TubeGeometry.NoTaper = function(u) {
      return 1;
    };
    THREE.TubeGeometry.SinusoidalTaper = function(u) {
      return Math.sin(Math.PI * u);
    };
    THREE.TubeGeometry.FrenetFrames = function(path, segments, closed) {
      var normal = new THREE.Vector3(),
          tangents = [],
          normals = [],
          binormals = [],
          vec = new THREE.Vector3(),
          mat = new THREE.Matrix4(),
          numpoints = segments + 1,
          theta,
          smallest,
          tx,
          ty,
          tz,
          i,
          u;
      this.tangents = tangents;
      this.normals = normals;
      this.binormals = binormals;
      for (i = 0; i < numpoints; i++) {
        u = i / (numpoints - 1);
        tangents[i] = path.getTangentAt(u);
        tangents[i].normalize();
      }
      initialNormal3();
      function initialNormal3() {
        normals[0] = new THREE.Vector3();
        binormals[0] = new THREE.Vector3();
        smallest = Number.MAX_VALUE;
        tx = Math.abs(tangents[0].x);
        ty = Math.abs(tangents[0].y);
        tz = Math.abs(tangents[0].z);
        if (tx <= smallest) {
          smallest = tx;
          normal.set(1, 0, 0);
        }
        if (ty <= smallest) {
          smallest = ty;
          normal.set(0, 1, 0);
        }
        if (tz <= smallest) {
          normal.set(0, 0, 1);
        }
        vec.crossVectors(tangents[0], normal).normalize();
        normals[0].crossVectors(tangents[0], vec);
        binormals[0].crossVectors(tangents[0], normals[0]);
      }
      for (i = 1; i < numpoints; i++) {
        normals[i] = normals[i - 1].clone();
        binormals[i] = binormals[i - 1].clone();
        vec.crossVectors(tangents[i - 1], tangents[i]);
        if (vec.length() > Number.EPSILON) {
          vec.normalize();
          theta = Math.acos(THREE.Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
          normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
        }
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
      if (closed) {
        theta = Math.acos(THREE.Math.clamp(normals[0].dot(normals[numpoints - 1]), -1, 1));
        theta /= (numpoints - 1);
        if (tangents[0].dot(vec.crossVectors(normals[0], normals[numpoints - 1])) > 0) {
          theta = -theta;
        }
        for (i = 1; i < numpoints; i++) {
          normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
          binormals[i].crossVectors(tangents[i], normals[i]);
        }
      }
    };
    THREE.PolyhedronGeometry = function(vertices, indices, radius, detail) {
      THREE.Geometry.call(this);
      this.type = 'PolyhedronGeometry';
      this.parameters = {
        vertices: vertices,
        indices: indices,
        radius: radius,
        detail: detail
      };
      radius = radius || 1;
      detail = detail || 0;
      var that = this;
      for (var i = 0,
          l = vertices.length; i < l; i += 3) {
        prepare(new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]));
      }
      var p = this.vertices;
      var faces = [];
      for (var i = 0,
          j = 0,
          l = indices.length; i < l; i += 3, j++) {
        var v1 = p[indices[i]];
        var v2 = p[indices[i + 1]];
        var v3 = p[indices[i + 2]];
        faces[j] = new THREE.Face3(v1.index, v2.index, v3.index, [v1.clone(), v2.clone(), v3.clone()], undefined, j);
      }
      var centroid = new THREE.Vector3();
      for (var i = 0,
          l = faces.length; i < l; i++) {
        subdivide(faces[i], detail);
      }
      for (var i = 0,
          l = this.faceVertexUvs[0].length; i < l; i++) {
        var uvs = this.faceVertexUvs[0][i];
        var x0 = uvs[0].x;
        var x1 = uvs[1].x;
        var x2 = uvs[2].x;
        var max = Math.max(x0, x1, x2);
        var min = Math.min(x0, x1, x2);
        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2)
            uvs[0].x += 1;
          if (x1 < 0.2)
            uvs[1].x += 1;
          if (x2 < 0.2)
            uvs[2].x += 1;
        }
      }
      for (var i = 0,
          l = this.vertices.length; i < l; i++) {
        this.vertices[i].multiplyScalar(radius);
      }
      this.mergeVertices();
      this.computeFaceNormals();
      this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
      function prepare(vector) {
        var vertex = vector.normalize().clone();
        vertex.index = that.vertices.push(vertex) - 1;
        var u = azimuth(vector) / 2 / Math.PI + 0.5;
        var v = inclination(vector) / Math.PI + 0.5;
        vertex.uv = new THREE.Vector2(u, 1 - v);
        return vertex;
      }
      function make(v1, v2, v3, materialIndex) {
        var face = new THREE.Face3(v1.index, v2.index, v3.index, [v1.clone(), v2.clone(), v3.clone()], undefined, materialIndex);
        that.faces.push(face);
        centroid.copy(v1).add(v2).add(v3).divideScalar(3);
        var azi = azimuth(centroid);
        that.faceVertexUvs[0].push([correctUV(v1.uv, v1, azi), correctUV(v2.uv, v2, azi), correctUV(v3.uv, v3, azi)]);
      }
      function subdivide(face, detail) {
        var cols = Math.pow(2, detail);
        var a = prepare(that.vertices[face.a]);
        var b = prepare(that.vertices[face.b]);
        var c = prepare(that.vertices[face.c]);
        var v = [];
        var materialIndex = face.materialIndex;
        for (var i = 0; i <= cols; i++) {
          v[i] = [];
          var aj = prepare(a.clone().lerp(c, i / cols));
          var bj = prepare(b.clone().lerp(c, i / cols));
          var rows = cols - i;
          for (var j = 0; j <= rows; j++) {
            if (j === 0 && i === cols) {
              v[i][j] = aj;
            } else {
              v[i][j] = prepare(aj.clone().lerp(bj, j / rows));
            }
          }
        }
        for (var i = 0; i < cols; i++) {
          for (var j = 0; j < 2 * (cols - i) - 1; j++) {
            var k = Math.floor(j / 2);
            if (j % 2 === 0) {
              make(v[i][k + 1], v[i + 1][k], v[i][k], materialIndex);
            } else {
              make(v[i][k + 1], v[i + 1][k + 1], v[i + 1][k], materialIndex);
            }
          }
        }
      }
      function azimuth(vector) {
        return Math.atan2(vector.z, -vector.x);
      }
      function inclination(vector) {
        return Math.atan2(-vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)));
      }
      function correctUV(uv, vector, azimuth) {
        if ((azimuth < 0) && (uv.x === 1))
          uv = new THREE.Vector2(uv.x - 1, uv.y);
        if ((vector.x === 0) && (vector.z === 0))
          uv = new THREE.Vector2(azimuth / 2 / Math.PI + 0.5, uv.y);
        return uv.clone();
      }
    };
    THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;
    THREE.PolyhedronGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.PolyhedronGeometry(parameters.vertices, parameters.indices, parameters.radius, parameters.detail);
    };
    THREE.DodecahedronGeometry = function(radius, detail) {
      var t = (1 + Math.sqrt(5)) / 2;
      var r = 1 / t;
      var vertices = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
      var indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
      THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
      this.type = 'DodecahedronGeometry';
      this.parameters = {
        radius: radius,
        detail: detail
      };
    };
    THREE.DodecahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
    THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;
    THREE.DodecahedronGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.DodecahedronGeometry(parameters.radius, parameters.detail);
    };
    THREE.IcosahedronGeometry = function(radius, detail) {
      var t = (1 + Math.sqrt(5)) / 2;
      var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
      var indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
      THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
      this.type = 'IcosahedronGeometry';
      this.parameters = {
        radius: radius,
        detail: detail
      };
    };
    THREE.IcosahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
    THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;
    THREE.IcosahedronGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.IcosahedronGeometry(parameters.radius, parameters.detail);
    };
    THREE.OctahedronGeometry = function(radius, detail) {
      var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
      var indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
      THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
      this.type = 'OctahedronGeometry';
      this.parameters = {
        radius: radius,
        detail: detail
      };
    };
    THREE.OctahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
    THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;
    THREE.OctahedronGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.OctahedronGeometry(parameters.radius, parameters.detail);
    };
    THREE.TetrahedronGeometry = function(radius, detail) {
      var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
      var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
      THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
      this.type = 'TetrahedronGeometry';
      this.parameters = {
        radius: radius,
        detail: detail
      };
    };
    THREE.TetrahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
    THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;
    THREE.TetrahedronGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.TetrahedronGeometry(parameters.radius, parameters.detail);
    };
    THREE.ParametricGeometry = function(func, slices, stacks) {
      THREE.Geometry.call(this);
      this.type = 'ParametricGeometry';
      this.parameters = {
        func: func,
        slices: slices,
        stacks: stacks
      };
      var verts = this.vertices;
      var faces = this.faces;
      var uvs = this.faceVertexUvs[0];
      var i,
          j,
          p;
      var u,
          v;
      var sliceCount = slices + 1;
      for (i = 0; i <= stacks; i++) {
        v = i / stacks;
        for (j = 0; j <= slices; j++) {
          u = j / slices;
          p = func(u, v);
          verts.push(p);
        }
      }
      var a,
          b,
          c,
          d;
      var uva,
          uvb,
          uvc,
          uvd;
      for (i = 0; i < stacks; i++) {
        for (j = 0; j < slices; j++) {
          a = i * sliceCount + j;
          b = i * sliceCount + j + 1;
          c = (i + 1) * sliceCount + j + 1;
          d = (i + 1) * sliceCount + j;
          uva = new THREE.Vector2(j / slices, i / stacks);
          uvb = new THREE.Vector2((j + 1) / slices, i / stacks);
          uvc = new THREE.Vector2((j + 1) / slices, (i + 1) / stacks);
          uvd = new THREE.Vector2(j / slices, (i + 1) / stacks);
          faces.push(new THREE.Face3(a, b, d));
          uvs.push([uva, uvb, uvd]);
          faces.push(new THREE.Face3(b, c, d));
          uvs.push([uvb.clone(), uvc, uvd.clone()]);
        }
      }
      this.computeFaceNormals();
      this.computeVertexNormals();
    };
    THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;
    THREE.WireframeGeometry = function(geometry) {
      THREE.BufferGeometry.call(this);
      var edge = [0, 0],
          hash = {};
      function sortFunction(a, b) {
        return a - b;
      }
      var keys = ['a', 'b', 'c'];
      if (geometry instanceof THREE.Geometry) {
        var vertices = geometry.vertices;
        var faces = geometry.faces;
        var numEdges = 0;
        var edges = new Uint32Array(6 * faces.length);
        for (var i = 0,
            l = faces.length; i < l; i++) {
          var face = faces[i];
          for (var j = 0; j < 3; j++) {
            edge[0] = face[keys[j]];
            edge[1] = face[keys[(j + 1) % 3]];
            edge.sort(sortFunction);
            var key = edge.toString();
            if (hash[key] === undefined) {
              edges[2 * numEdges] = edge[0];
              edges[2 * numEdges + 1] = edge[1];
              hash[key] = true;
              numEdges++;
            }
          }
        }
        var coords = new Float32Array(numEdges * 2 * 3);
        for (var i = 0,
            l = numEdges; i < l; i++) {
          for (var j = 0; j < 2; j++) {
            var vertex = vertices[edges[2 * i + j]];
            var index = 6 * i + 3 * j;
            coords[index + 0] = vertex.x;
            coords[index + 1] = vertex.y;
            coords[index + 2] = vertex.z;
          }
        }
        this.addAttribute('position', new THREE.BufferAttribute(coords, 3));
      } else if (geometry instanceof THREE.BufferGeometry) {
        if (geometry.index !== null) {
          var indices = geometry.index.array;
          var vertices = geometry.attributes.position;
          var drawcalls = geometry.drawcalls;
          var numEdges = 0;
          if (drawcalls.length === 0) {
            geometry.addGroup(0, indices.length);
          }
          var edges = new Uint32Array(2 * indices.length);
          for (var o = 0,
              ol = drawcalls.length; o < ol; ++o) {
            var drawcall = drawcalls[o];
            var start = drawcall.start;
            var count = drawcall.count;
            for (var i = start,
                il = start + count; i < il; i += 3) {
              for (var j = 0; j < 3; j++) {
                edge[0] = indices[i + j];
                edge[1] = indices[i + (j + 1) % 3];
                edge.sort(sortFunction);
                var key = edge.toString();
                if (hash[key] === undefined) {
                  edges[2 * numEdges] = edge[0];
                  edges[2 * numEdges + 1] = edge[1];
                  hash[key] = true;
                  numEdges++;
                }
              }
            }
          }
          var coords = new Float32Array(numEdges * 2 * 3);
          for (var i = 0,
              l = numEdges; i < l; i++) {
            for (var j = 0; j < 2; j++) {
              var index = 6 * i + 3 * j;
              var index2 = edges[2 * i + j];
              coords[index + 0] = vertices.getX(index2);
              coords[index + 1] = vertices.getY(index2);
              coords[index + 2] = vertices.getZ(index2);
            }
          }
          this.addAttribute('position', new THREE.BufferAttribute(coords, 3));
        } else {
          var vertices = geometry.attributes.position.array;
          var numEdges = vertices.length / 3;
          var numTris = numEdges / 3;
          var coords = new Float32Array(numEdges * 2 * 3);
          for (var i = 0,
              l = numTris; i < l; i++) {
            for (var j = 0; j < 3; j++) {
              var index = 18 * i + 6 * j;
              var index1 = 9 * i + 3 * j;
              coords[index + 0] = vertices[index1];
              coords[index + 1] = vertices[index1 + 1];
              coords[index + 2] = vertices[index1 + 2];
              var index2 = 9 * i + 3 * ((j + 1) % 3);
              coords[index + 3] = vertices[index2];
              coords[index + 4] = vertices[index2 + 1];
              coords[index + 5] = vertices[index2 + 2];
            }
          }
          this.addAttribute('position', new THREE.BufferAttribute(coords, 3));
        }
      }
    };
    THREE.WireframeGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;
    THREE.AxisHelper = function(size) {
      size = size || 1;
      var vertices = new Float32Array([0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size]);
      var colors = new Float32Array([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1]);
      var geometry = new THREE.BufferGeometry();
      geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
      geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));
      var material = new THREE.LineBasicMaterial({vertexColors: THREE.VertexColors});
      THREE.LineSegments.call(this, geometry, material);
    };
    THREE.AxisHelper.prototype = Object.create(THREE.LineSegments.prototype);
    THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;
    THREE.ArrowHelper = (function() {
      var lineGeometry = new THREE.Geometry();
      lineGeometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));
      var coneGeometry = new THREE.CylinderGeometry(0, 0.5, 1, 5, 1);
      coneGeometry.translate(0, -0.5, 0);
      return function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
        THREE.Object3D.call(this);
        if (color === undefined)
          color = 0xffff00;
        if (length === undefined)
          length = 1;
        if (headLength === undefined)
          headLength = 0.2 * length;
        if (headWidth === undefined)
          headWidth = 0.2 * headLength;
        this.position.copy(origin);
        if (headLength < length) {
          this.line = new THREE.Line(lineGeometry, new THREE.LineBasicMaterial({color: color}));
          this.line.matrixAutoUpdate = false;
          this.add(this.line);
        }
        this.cone = new THREE.Mesh(coneGeometry, new THREE.MeshBasicMaterial({color: color}));
        this.cone.matrixAutoUpdate = false;
        this.add(this.cone);
        this.setDirection(dir);
        this.setLength(length, headLength, headWidth);
      };
    }());
    THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);
    THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;
    THREE.ArrowHelper.prototype.setDirection = (function() {
      var axis = new THREE.Vector3();
      var radians;
      return function setDirection(dir) {
        if (dir.y > 0.99999) {
          this.quaternion.set(0, 0, 0, 1);
        } else if (dir.y < -0.99999) {
          this.quaternion.set(1, 0, 0, 0);
        } else {
          axis.set(dir.z, 0, -dir.x).normalize();
          radians = Math.acos(dir.y);
          this.quaternion.setFromAxisAngle(axis, radians);
        }
      };
    }());
    THREE.ArrowHelper.prototype.setLength = function(length, headLength, headWidth) {
      if (headLength === undefined)
        headLength = 0.2 * length;
      if (headWidth === undefined)
        headWidth = 0.2 * headLength;
      if (headLength < length) {
        this.line.scale.set(1, length - headLength, 1);
        this.line.updateMatrix();
      }
      this.cone.scale.set(headWidth, headLength, headWidth);
      this.cone.position.y = length;
      this.cone.updateMatrix();
    };
    THREE.ArrowHelper.prototype.setColor = function(color) {
      if (this.line !== undefined)
        this.line.material.color.set(color);
      this.cone.material.color.set(color);
    };
    THREE.BoxHelper = function(object) {
      var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
      var positions = new Float32Array(8 * 3);
      var geometry = new THREE.BufferGeometry();
      geometry.setIndex(new THREE.BufferAttribute(indices, 1));
      geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
      THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({color: 0xffff00}));
      if (object !== undefined) {
        this.update(object);
      }
    };
    THREE.BoxHelper.prototype = Object.create(THREE.LineSegments.prototype);
    THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;
    THREE.BoxHelper.prototype.update = (function() {
      var box = new THREE.Box3();
      return function(object) {
        box.setFromObject(object);
        if (box.empty())
          return;
        var min = box.min;
        var max = box.max;
        var position = this.geometry.attributes.position;
        var array = position.array;
        array[0] = max.x;
        array[1] = max.y;
        array[2] = max.z;
        array[3] = min.x;
        array[4] = max.y;
        array[5] = max.z;
        array[6] = min.x;
        array[7] = min.y;
        array[8] = max.z;
        array[9] = max.x;
        array[10] = min.y;
        array[11] = max.z;
        array[12] = max.x;
        array[13] = max.y;
        array[14] = min.z;
        array[15] = min.x;
        array[16] = max.y;
        array[17] = min.z;
        array[18] = min.x;
        array[19] = min.y;
        array[20] = min.z;
        array[21] = max.x;
        array[22] = min.y;
        array[23] = min.z;
        position.needsUpdate = true;
        this.geometry.computeBoundingSphere();
      };
    })();
    THREE.BoundingBoxHelper = function(object, hex) {
      var color = (hex !== undefined) ? hex : 0x888888;
      this.object = object;
      this.box = new THREE.Box3();
      THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
        color: color,
        wireframe: true
      }));
    };
    THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);
    THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;
    THREE.BoundingBoxHelper.prototype.update = function() {
      this.box.setFromObject(this.object);
      this.box.size(this.scale);
      this.box.center(this.position);
    };
    THREE.CameraHelper = function(camera) {
      var geometry = new THREE.Geometry();
      var material = new THREE.LineBasicMaterial({
        color: 0xffffff,
        vertexColors: THREE.FaceColors
      });
      var pointMap = {};
      var hexFrustum = 0xffaa00;
      var hexCone = 0xff0000;
      var hexUp = 0x00aaff;
      var hexTarget = 0xffffff;
      var hexCross = 0x333333;
      addLine("n1", "n2", hexFrustum);
      addLine("n2", "n4", hexFrustum);
      addLine("n4", "n3", hexFrustum);
      addLine("n3", "n1", hexFrustum);
      addLine("f1", "f2", hexFrustum);
      addLine("f2", "f4", hexFrustum);
      addLine("f4", "f3", hexFrustum);
      addLine("f3", "f1", hexFrustum);
      addLine("n1", "f1", hexFrustum);
      addLine("n2", "f2", hexFrustum);
      addLine("n3", "f3", hexFrustum);
      addLine("n4", "f4", hexFrustum);
      addLine("p", "n1", hexCone);
      addLine("p", "n2", hexCone);
      addLine("p", "n3", hexCone);
      addLine("p", "n4", hexCone);
      addLine("u1", "u2", hexUp);
      addLine("u2", "u3", hexUp);
      addLine("u3", "u1", hexUp);
      addLine("c", "t", hexTarget);
      addLine("p", "c", hexCross);
      addLine("cn1", "cn2", hexCross);
      addLine("cn3", "cn4", hexCross);
      addLine("cf1", "cf2", hexCross);
      addLine("cf3", "cf4", hexCross);
      function addLine(a, b, hex) {
        addPoint(a, hex);
        addPoint(b, hex);
      }
      function addPoint(id, hex) {
        geometry.vertices.push(new THREE.Vector3());
        geometry.colors.push(new THREE.Color(hex));
        if (pointMap[id] === undefined) {
          pointMap[id] = [];
        }
        pointMap[id].push(geometry.vertices.length - 1);
      }
      THREE.LineSegments.call(this, geometry, material);
      this.camera = camera;
      this.camera.updateProjectionMatrix();
      this.matrix = camera.matrixWorld;
      this.matrixAutoUpdate = false;
      this.pointMap = pointMap;
      this.update();
    };
    THREE.CameraHelper.prototype = Object.create(THREE.LineSegments.prototype);
    THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;
    THREE.CameraHelper.prototype.update = function() {
      var geometry,
          pointMap;
      var vector = new THREE.Vector3();
      var camera = new THREE.Camera();
      function setPoint(point, x, y, z) {
        vector.set(x, y, z).unproject(camera);
        var points = pointMap[point];
        if (points !== undefined) {
          for (var i = 0,
              il = points.length; i < il; i++) {
            geometry.vertices[points[i]].copy(vector);
          }
        }
      }
      return function() {
        geometry = this.geometry;
        pointMap = this.pointMap;
        var w = 1,
            h = 1;
        camera.projectionMatrix.copy(this.camera.projectionMatrix);
        setPoint("c", 0, 0, -1);
        setPoint("t", 0, 0, 1);
        setPoint("n1", -w, -h, -1);
        setPoint("n2", w, -h, -1);
        setPoint("n3", -w, h, -1);
        setPoint("n4", w, h, -1);
        setPoint("f1", -w, -h, 1);
        setPoint("f2", w, -h, 1);
        setPoint("f3", -w, h, 1);
        setPoint("f4", w, h, 1);
        setPoint("u1", w * 0.7, h * 1.1, -1);
        setPoint("u2", -w * 0.7, h * 1.1, -1);
        setPoint("u3", 0, h * 2, -1);
        setPoint("cf1", -w, 0, 1);
        setPoint("cf2", w, 0, 1);
        setPoint("cf3", 0, -h, 1);
        setPoint("cf4", 0, h, 1);
        setPoint("cn1", -w, 0, -1);
        setPoint("cn2", w, 0, -1);
        setPoint("cn3", 0, -h, -1);
        setPoint("cn4", 0, h, -1);
        geometry.verticesNeedUpdate = true;
      };
    }();
    THREE.DirectionalLightHelper = function(light, size) {
      THREE.Object3D.call(this);
      this.light = light;
      this.light.updateMatrixWorld();
      this.matrix = light.matrixWorld;
      this.matrixAutoUpdate = false;
      size = size || 1;
      var geometry = new THREE.Geometry();
      geometry.vertices.push(new THREE.Vector3(-size, size, 0), new THREE.Vector3(size, size, 0), new THREE.Vector3(size, -size, 0), new THREE.Vector3(-size, -size, 0), new THREE.Vector3(-size, size, 0));
      var material = new THREE.LineBasicMaterial({fog: false});
      material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      this.lightPlane = new THREE.Line(geometry, material);
      this.add(this.lightPlane);
      geometry = new THREE.Geometry();
      geometry.vertices.push(new THREE.Vector3(), new THREE.Vector3());
      material = new THREE.LineBasicMaterial({fog: false});
      material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      this.targetLine = new THREE.Line(geometry, material);
      this.add(this.targetLine);
      this.update();
    };
    THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);
    THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;
    THREE.DirectionalLightHelper.prototype.dispose = function() {
      this.lightPlane.geometry.dispose();
      this.lightPlane.material.dispose();
      this.targetLine.geometry.dispose();
      this.targetLine.material.dispose();
    };
    THREE.DirectionalLightHelper.prototype.update = function() {
      var v1 = new THREE.Vector3();
      var v2 = new THREE.Vector3();
      var v3 = new THREE.Vector3();
      return function() {
        v1.setFromMatrixPosition(this.light.matrixWorld);
        v2.setFromMatrixPosition(this.light.target.matrixWorld);
        v3.subVectors(v2, v1);
        this.lightPlane.lookAt(v3);
        this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        this.targetLine.geometry.vertices[1].copy(v3);
        this.targetLine.geometry.verticesNeedUpdate = true;
        this.targetLine.material.color.copy(this.lightPlane.material.color);
      };
    }();
    THREE.EdgesHelper = function(object, hex, thresholdAngle) {
      var color = (hex !== undefined) ? hex : 0xffffff;
      THREE.LineSegments.call(this, new THREE.EdgesGeometry(object.geometry, thresholdAngle), new THREE.LineBasicMaterial({color: color}));
      this.matrix = object.matrixWorld;
      this.matrixAutoUpdate = false;
    };
    THREE.EdgesHelper.prototype = Object.create(THREE.LineSegments.prototype);
    THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;
    THREE.FaceNormalsHelper = function(object, size, hex, linewidth) {
      this.object = object;
      this.size = (size !== undefined) ? size : 1;
      var color = (hex !== undefined) ? hex : 0xffff00;
      var width = (linewidth !== undefined) ? linewidth : 1;
      var nNormals = 0;
      var objGeometry = this.object.geometry;
      if (objGeometry instanceof THREE.Geometry) {
        nNormals = objGeometry.faces.length;
      } else {
        console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');
      }
      var geometry = new THREE.BufferGeometry();
      var positions = new THREE.Float32Attribute(nNormals * 2 * 3, 3);
      geometry.addAttribute('position', positions);
      THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({
        color: color,
        linewidth: width
      }));
      this.matrixAutoUpdate = false;
      this.update();
    };
    THREE.FaceNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype);
    THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;
    THREE.FaceNormalsHelper.prototype.update = (function() {
      var v1 = new THREE.Vector3();
      var v2 = new THREE.Vector3();
      var normalMatrix = new THREE.Matrix3();
      return function update() {
        this.object.updateMatrixWorld(true);
        normalMatrix.getNormalMatrix(this.object.matrixWorld);
        var matrixWorld = this.object.matrixWorld;
        var position = this.geometry.attributes.position;
        var objGeometry = this.object.geometry;
        var vertices = objGeometry.vertices;
        var faces = objGeometry.faces;
        var idx = 0;
        for (var i = 0,
            l = faces.length; i < l; i++) {
          var face = faces[i];
          var normal = face.normal;
          v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);
          v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
          position.setXYZ(idx, v1.x, v1.y, v1.z);
          idx = idx + 1;
          position.setXYZ(idx, v2.x, v2.y, v2.z);
          idx = idx + 1;
        }
        position.needsUpdate = true;
        return this;
      };
    }());
    THREE.GridHelper = function(size, step) {
      var geometry = new THREE.Geometry();
      var material = new THREE.LineBasicMaterial({vertexColors: THREE.VertexColors});
      this.color1 = new THREE.Color(0x444444);
      this.color2 = new THREE.Color(0x888888);
      for (var i = -size; i <= size; i += step) {
        geometry.vertices.push(new THREE.Vector3(-size, 0, i), new THREE.Vector3(size, 0, i), new THREE.Vector3(i, 0, -size), new THREE.Vector3(i, 0, size));
        var color = i === 0 ? this.color1 : this.color2;
        geometry.colors.push(color, color, color, color);
      }
      THREE.LineSegments.call(this, geometry, material);
    };
    THREE.GridHelper.prototype = Object.create(THREE.LineSegments.prototype);
    THREE.GridHelper.prototype.constructor = THREE.GridHelper;
    THREE.GridHelper.prototype.setColors = function(colorCenterLine, colorGrid) {
      this.color1.set(colorCenterLine);
      this.color2.set(colorGrid);
      this.geometry.colorsNeedUpdate = true;
    };
    THREE.HemisphereLightHelper = function(light, sphereSize) {
      THREE.Object3D.call(this);
      this.light = light;
      this.light.updateMatrixWorld();
      this.matrix = light.matrixWorld;
      this.matrixAutoUpdate = false;
      this.colors = [new THREE.Color(), new THREE.Color()];
      var geometry = new THREE.SphereGeometry(sphereSize, 4, 2);
      geometry.rotateX(-Math.PI / 2);
      for (var i = 0,
          il = 8; i < il; i++) {
        geometry.faces[i].color = this.colors[i < 4 ? 0 : 1];
      }
      var material = new THREE.MeshBasicMaterial({
        vertexColors: THREE.FaceColors,
        wireframe: true
      });
      this.lightSphere = new THREE.Mesh(geometry, material);
      this.add(this.lightSphere);
      this.update();
    };
    THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);
    THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;
    THREE.HemisphereLightHelper.prototype.dispose = function() {
      this.lightSphere.geometry.dispose();
      this.lightSphere.material.dispose();
    };
    THREE.HemisphereLightHelper.prototype.update = function() {
      var vector = new THREE.Vector3();
      return function() {
        this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
        this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
        this.lightSphere.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
        this.lightSphere.geometry.colorsNeedUpdate = true;
      };
    }();
    THREE.PointLightHelper = function(light, sphereSize) {
      this.light = light;
      this.light.updateMatrixWorld();
      var geometry = new THREE.SphereGeometry(sphereSize, 4, 2);
      var material = new THREE.MeshBasicMaterial({
        wireframe: true,
        fog: false
      });
      material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      THREE.Mesh.call(this, geometry, material);
      this.matrix = this.light.matrixWorld;
      this.matrixAutoUpdate = false;
    };
    THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);
    THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;
    THREE.PointLightHelper.prototype.dispose = function() {
      this.geometry.dispose();
      this.material.dispose();
    };
    THREE.PointLightHelper.prototype.update = function() {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    };
    THREE.SkeletonHelper = function(object) {
      this.bones = this.getBoneList(object);
      var geometry = new THREE.Geometry();
      for (var i = 0; i < this.bones.length; i++) {
        var bone = this.bones[i];
        if (bone.parent instanceof THREE.Bone) {
          geometry.vertices.push(new THREE.Vector3());
          geometry.vertices.push(new THREE.Vector3());
          geometry.colors.push(new THREE.Color(0, 0, 1));
          geometry.colors.push(new THREE.Color(0, 1, 0));
        }
      }
      geometry.dynamic = true;
      var material = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors,
        depthTest: false,
        depthWrite: false,
        transparent: true
      });
      THREE.LineSegments.call(this, geometry, material);
      this.root = object;
      this.matrix = object.matrixWorld;
      this.matrixAutoUpdate = false;
      this.update();
    };
    THREE.SkeletonHelper.prototype = Object.create(THREE.LineSegments.prototype);
    THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;
    THREE.SkeletonHelper.prototype.getBoneList = function(object) {
      var boneList = [];
      if (object instanceof THREE.Bone) {
        boneList.push(object);
      }
      for (var i = 0; i < object.children.length; i++) {
        boneList.push.apply(boneList, this.getBoneList(object.children[i]));
      }
      return boneList;
    };
    THREE.SkeletonHelper.prototype.update = function() {
      var geometry = this.geometry;
      var matrixWorldInv = new THREE.Matrix4().getInverse(this.root.matrixWorld);
      var boneMatrix = new THREE.Matrix4();
      var j = 0;
      for (var i = 0; i < this.bones.length; i++) {
        var bone = this.bones[i];
        if (bone.parent instanceof THREE.Bone) {
          boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
          geometry.vertices[j].setFromMatrixPosition(boneMatrix);
          boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
          geometry.vertices[j + 1].setFromMatrixPosition(boneMatrix);
          j += 2;
        }
      }
      geometry.verticesNeedUpdate = true;
      geometry.computeBoundingSphere();
    };
    THREE.SpotLightHelper = function(light) {
      THREE.Object3D.call(this);
      this.light = light;
      this.light.updateMatrixWorld();
      this.matrix = light.matrixWorld;
      this.matrixAutoUpdate = false;
      var geometry = new THREE.CylinderGeometry(0, 1, 1, 8, 1, true);
      geometry.translate(0, -0.5, 0);
      geometry.rotateX(-Math.PI / 2);
      var material = new THREE.MeshBasicMaterial({
        wireframe: true,
        fog: false
      });
      this.cone = new THREE.Mesh(geometry, material);
      this.add(this.cone);
      this.update();
    };
    THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);
    THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;
    THREE.SpotLightHelper.prototype.dispose = function() {
      this.cone.geometry.dispose();
      this.cone.material.dispose();
    };
    THREE.SpotLightHelper.prototype.update = function() {
      var vector = new THREE.Vector3();
      var vector2 = new THREE.Vector3();
      return function() {
        var coneLength = this.light.distance ? this.light.distance : 10000;
        var coneWidth = coneLength * Math.tan(this.light.angle);
        this.cone.scale.set(coneWidth, coneWidth, coneLength);
        vector.setFromMatrixPosition(this.light.matrixWorld);
        vector2.setFromMatrixPosition(this.light.target.matrixWorld);
        this.cone.lookAt(vector2.sub(vector));
        this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      };
    }();
    THREE.VertexNormalsHelper = function(object, size, hex, linewidth) {
      this.object = object;
      this.size = (size !== undefined) ? size : 1;
      var color = (hex !== undefined) ? hex : 0xff0000;
      var width = (linewidth !== undefined) ? linewidth : 1;
      var nNormals = 0;
      var objGeometry = this.object.geometry;
      if (objGeometry instanceof THREE.Geometry) {
        nNormals = objGeometry.faces.length * 3;
      } else if (objGeometry instanceof THREE.BufferGeometry) {
        nNormals = objGeometry.attributes.normal.count;
      }
      var geometry = new THREE.BufferGeometry();
      var positions = new THREE.Float32Attribute(nNormals * 2 * 3, 3);
      geometry.addAttribute('position', positions);
      THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({
        color: color,
        linewidth: width
      }));
      this.matrixAutoUpdate = false;
      this.update();
    };
    THREE.VertexNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype);
    THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;
    THREE.VertexNormalsHelper.prototype.update = (function() {
      var v1 = new THREE.Vector3();
      var v2 = new THREE.Vector3();
      var normalMatrix = new THREE.Matrix3();
      return function update() {
        var keys = ['a', 'b', 'c'];
        this.object.updateMatrixWorld(true);
        normalMatrix.getNormalMatrix(this.object.matrixWorld);
        var matrixWorld = this.object.matrixWorld;
        var position = this.geometry.attributes.position;
        var objGeometry = this.object.geometry;
        if (objGeometry instanceof THREE.Geometry) {
          var vertices = objGeometry.vertices;
          var faces = objGeometry.faces;
          var idx = 0;
          for (var i = 0,
              l = faces.length; i < l; i++) {
            var face = faces[i];
            for (var j = 0,
                jl = face.vertexNormals.length; j < jl; j++) {
              var vertex = vertices[face[keys[j]]];
              var normal = face.vertexNormals[j];
              v1.copy(vertex).applyMatrix4(matrixWorld);
              v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
              position.setXYZ(idx, v1.x, v1.y, v1.z);
              idx = idx + 1;
              position.setXYZ(idx, v2.x, v2.y, v2.z);
              idx = idx + 1;
            }
          }
        } else if (objGeometry instanceof THREE.BufferGeometry) {
          var objPos = objGeometry.attributes.position;
          var objNorm = objGeometry.attributes.normal;
          var idx = 0;
          for (var j = 0,
              jl = objPos.count; j < jl; j++) {
            v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);
            v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));
            v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
            position.setXYZ(idx, v1.x, v1.y, v1.z);
            idx = idx + 1;
            position.setXYZ(idx, v2.x, v2.y, v2.z);
            idx = idx + 1;
          }
        }
        position.needsUpdate = true;
        return this;
      };
    }());
    THREE.WireframeHelper = function(object, hex) {
      var color = (hex !== undefined) ? hex : 0xffffff;
      THREE.LineSegments.call(this, new THREE.WireframeGeometry(object.geometry), new THREE.LineBasicMaterial({color: color}));
      this.matrix = object.matrixWorld;
      this.matrixAutoUpdate = false;
    };
    THREE.WireframeHelper.prototype = Object.create(THREE.LineSegments.prototype);
    THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;
    THREE.ImmediateRenderObject = function(material) {
      THREE.Object3D.call(this);
      this.material = material;
      this.render = function(renderCallback) {};
    };
    THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype);
    THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;
    THREE.MorphBlendMesh = function(geometry, material) {
      THREE.Mesh.call(this, geometry, material);
      this.animationsMap = {};
      this.animationsList = [];
      var numFrames = this.geometry.morphTargets.length;
      var name = "__default";
      var startFrame = 0;
      var endFrame = numFrames - 1;
      var fps = numFrames / 1;
      this.createAnimation(name, startFrame, endFrame, fps);
      this.setAnimationWeight(name, 1);
    };
    THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype);
    THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;
    THREE.MorphBlendMesh.prototype.createAnimation = function(name, start, end, fps) {
      var animation = {
        start: start,
        end: end,
        length: end - start + 1,
        fps: fps,
        duration: (end - start) / fps,
        lastFrame: 0,
        currentFrame: 0,
        active: false,
        time: 0,
        direction: 1,
        weight: 1,
        directionBackwards: false,
        mirroredLoop: false
      };
      this.animationsMap[name] = animation;
      this.animationsList.push(animation);
    };
    THREE.MorphBlendMesh.prototype.autoCreateAnimations = function(fps) {
      var pattern = /([a-z]+)_?(\d+)/;
      var firstAnimation,
          frameRanges = {};
      var geometry = this.geometry;
      for (var i = 0,
          il = geometry.morphTargets.length; i < il; i++) {
        var morph = geometry.morphTargets[i];
        var chunks = morph.name.match(pattern);
        if (chunks && chunks.length > 1) {
          var name = chunks[1];
          if (!frameRanges[name])
            frameRanges[name] = {
              start: Infinity,
              end: -Infinity
            };
          var range = frameRanges[name];
          if (i < range.start)
            range.start = i;
          if (i > range.end)
            range.end = i;
          if (!firstAnimation)
            firstAnimation = name;
        }
      }
      for (var name in frameRanges) {
        var range = frameRanges[name];
        this.createAnimation(name, range.start, range.end, fps);
      }
      this.firstAnimation = firstAnimation;
    };
    THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function(name) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.direction = 1;
        animation.directionBackwards = false;
      }
    };
    THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function(name) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.direction = -1;
        animation.directionBackwards = true;
      }
    };
    THREE.MorphBlendMesh.prototype.setAnimationFPS = function(name, fps) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.fps = fps;
        animation.duration = (animation.end - animation.start) / animation.fps;
      }
    };
    THREE.MorphBlendMesh.prototype.setAnimationDuration = function(name, duration) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.duration = duration;
        animation.fps = (animation.end - animation.start) / animation.duration;
      }
    };
    THREE.MorphBlendMesh.prototype.setAnimationWeight = function(name, weight) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.weight = weight;
      }
    };
    THREE.MorphBlendMesh.prototype.setAnimationTime = function(name, time) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.time = time;
      }
    };
    THREE.MorphBlendMesh.prototype.getAnimationTime = function(name) {
      var time = 0;
      var animation = this.animationsMap[name];
      if (animation) {
        time = animation.time;
      }
      return time;
    };
    THREE.MorphBlendMesh.prototype.getAnimationDuration = function(name) {
      var duration = -1;
      var animation = this.animationsMap[name];
      if (animation) {
        duration = animation.duration;
      }
      return duration;
    };
    THREE.MorphBlendMesh.prototype.playAnimation = function(name) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.time = 0;
        animation.active = true;
      } else {
        console.warn("THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()");
      }
    };
    THREE.MorphBlendMesh.prototype.stopAnimation = function(name) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.active = false;
      }
    };
    THREE.MorphBlendMesh.prototype.update = function(delta) {
      for (var i = 0,
          il = this.animationsList.length; i < il; i++) {
        var animation = this.animationsList[i];
        if (!animation.active)
          continue;
        var frameTime = animation.duration / animation.length;
        animation.time += animation.direction * delta;
        if (animation.mirroredLoop) {
          if (animation.time > animation.duration || animation.time < 0) {
            animation.direction *= -1;
            if (animation.time > animation.duration) {
              animation.time = animation.duration;
              animation.directionBackwards = true;
            }
            if (animation.time < 0) {
              animation.time = 0;
              animation.directionBackwards = false;
            }
          }
        } else {
          animation.time = animation.time % animation.duration;
          if (animation.time < 0)
            animation.time += animation.duration;
        }
        var keyframe = animation.start + THREE.Math.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);
        var weight = animation.weight;
        if (keyframe !== animation.currentFrame) {
          this.morphTargetInfluences[animation.lastFrame] = 0;
          this.morphTargetInfluences[animation.currentFrame] = 1 * weight;
          this.morphTargetInfluences[keyframe] = 0;
          animation.lastFrame = animation.currentFrame;
          animation.currentFrame = keyframe;
        }
        var mix = (animation.time % frameTime) / frameTime;
        if (animation.directionBackwards)
          mix = 1 - mix;
        if (animation.currentFrame !== animation.lastFrame) {
          this.morphTargetInfluences[animation.currentFrame] = mix * weight;
          this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;
        } else {
          this.morphTargetInfluences[animation.currentFrame] = weight;
        }
      }
    };
  })($__require('github:jspm/nodelibs-buffer@0.1.0').Buffer, $__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:three.js@0.73.0", ["npm:three.js@0.73.0/build/three"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:three.js@0.73.0/build/three');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:redux@3.0.5/lib/createStore", ["npm:redux@3.0.5/lib/utils/isPlainObject"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.__esModule = true;
  exports['default'] = createStore;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _utilsIsPlainObject = $__require('npm:redux@3.0.5/lib/utils/isPlainObject');
  var _utilsIsPlainObject2 = _interopRequireDefault(_utilsIsPlainObject);
  var ActionTypes = {INIT: '@@redux/INIT'};
  exports.ActionTypes = ActionTypes;
  function createStore(reducer, initialState) {
    if (typeof reducer !== 'function') {
      throw new Error('Expected the reducer to be a function.');
    }
    var currentReducer = reducer;
    var currentState = initialState;
    var listeners = [];
    var isDispatching = false;
    function getState() {
      return currentState;
    }
    function subscribe(listener) {
      listeners.push(listener);
      var isSubscribed = true;
      return function unsubscribe() {
        if (!isSubscribed) {
          return;
        }
        isSubscribed = false;
        var index = listeners.indexOf(listener);
        listeners.splice(index, 1);
      };
    }
    function dispatch(action) {
      if (!_utilsIsPlainObject2['default'](action)) {
        throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
      }
      if (typeof action.type === 'undefined') {
        throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
      }
      if (isDispatching) {
        throw new Error('Reducers may not dispatch actions.');
      }
      try {
        isDispatching = true;
        currentState = currentReducer(currentState, action);
      } finally {
        isDispatching = false;
      }
      listeners.slice().forEach(function(listener) {
        return listener();
      });
      return action;
    }
    function replaceReducer(nextReducer) {
      currentReducer = nextReducer;
      dispatch({type: ActionTypes.INIT});
    }
    dispatch({type: ActionTypes.INIT});
    return {
      dispatch: dispatch,
      subscribe: subscribe,
      getState: getState,
      replaceReducer: replaceReducer
    };
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:redux@3.0.5/lib/utils/isPlainObject", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.__esModule = true;
  exports['default'] = isPlainObject;
  var fnToString = function fnToString(fn) {
    return Function.prototype.toString.call(fn);
  };
  var objStringValue = fnToString(Object);
  function isPlainObject(obj) {
    if (!obj || typeof obj !== 'object') {
      return false;
    }
    var proto = typeof obj.constructor === 'function' ? Object.getPrototypeOf(obj) : Object.prototype;
    if (proto === null) {
      return true;
    }
    var constructor = proto.constructor;
    return typeof constructor === 'function' && constructor instanceof constructor && fnToString(constructor) === objStringValue;
  }
  module.exports = exports['default'];
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:redux@3.0.5/lib/utils/pick", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.__esModule = true;
  exports["default"] = pick;
  function pick(obj, fn) {
    return Object.keys(obj).reduce(function(result, key) {
      if (fn(obj[key])) {
        result[key] = obj[key];
      }
      return result;
    }, {});
  }
  module.exports = exports["default"];
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:redux@3.0.5/lib/utils/combineReducers", ["npm:redux@3.0.5/lib/createStore", "npm:redux@3.0.5/lib/utils/isPlainObject", "npm:redux@3.0.5/lib/utils/mapValues", "npm:redux@3.0.5/lib/utils/pick", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    exports.__esModule = true;
    exports['default'] = combineReducers;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {'default': obj};
    }
    var _createStore = $__require('npm:redux@3.0.5/lib/createStore');
    var _isPlainObject = $__require('npm:redux@3.0.5/lib/utils/isPlainObject');
    var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
    var _mapValues = $__require('npm:redux@3.0.5/lib/utils/mapValues');
    var _mapValues2 = _interopRequireDefault(_mapValues);
    var _pick = $__require('npm:redux@3.0.5/lib/utils/pick');
    var _pick2 = _interopRequireDefault(_pick);
    function getUndefinedStateErrorMessage(key, action) {
      var actionType = action && action.type;
      var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
      return 'Reducer "' + key + '" returned undefined handling ' + actionName + '. ' + 'To ignore an action, you must explicitly return the previous state.';
    }
    function getUnexpectedStateKeyWarningMessage(inputState, outputState, action) {
      var reducerKeys = Object.keys(outputState);
      var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';
      if (reducerKeys.length === 0) {
        return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
      }
      if (!_isPlainObject2['default'](inputState)) {
        return 'The ' + argumentName + ' has unexpected type of "' + ({}).toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
      }
      var unexpectedKeys = Object.keys(inputState).filter(function(key) {
        return reducerKeys.indexOf(key) < 0;
      });
      if (unexpectedKeys.length > 0) {
        return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
      }
    }
    function assertReducerSanity(reducers) {
      Object.keys(reducers).forEach(function(key) {
        var reducer = reducers[key];
        var initialState = reducer(undefined, {type: _createStore.ActionTypes.INIT});
        if (typeof initialState === 'undefined') {
          throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
        }
        var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
        if (typeof reducer(undefined, {type: type}) === 'undefined') {
          throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
        }
      });
    }
    function combineReducers(reducers) {
      var finalReducers = _pick2['default'](reducers, function(val) {
        return typeof val === 'function';
      });
      var sanityError;
      try {
        assertReducerSanity(finalReducers);
      } catch (e) {
        sanityError = e;
      }
      var defaultState = _mapValues2['default'](finalReducers, function() {
        return undefined;
      });
      return function combination(state, action) {
        if (state === undefined)
          state = defaultState;
        if (sanityError) {
          throw sanityError;
        }
        var hasChanged = false;
        var finalState = _mapValues2['default'](finalReducers, function(reducer, key) {
          var previousStateForKey = state[key];
          var nextStateForKey = reducer(previousStateForKey, action);
          if (typeof nextStateForKey === 'undefined') {
            var errorMessage = getUndefinedStateErrorMessage(key, action);
            throw new Error(errorMessage);
          }
          hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
          return nextStateForKey;
        });
        if (process.env.NODE_ENV !== 'production') {
          var warningMessage = getUnexpectedStateKeyWarningMessage(state, finalState, action);
          if (warningMessage) {
            console.error(warningMessage);
          }
        }
        return hasChanged ? finalState : state;
      };
    }
    module.exports = exports['default'];
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:redux@3.0.5/lib/utils/mapValues", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.__esModule = true;
  exports["default"] = mapValues;
  function mapValues(obj, fn) {
    return Object.keys(obj).reduce(function(result, key) {
      result[key] = fn(obj[key], key);
      return result;
    }, {});
  }
  module.exports = exports["default"];
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:redux@3.0.5/lib/utils/bindActionCreators", ["npm:redux@3.0.5/lib/utils/mapValues"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.__esModule = true;
  exports['default'] = bindActionCreators;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _mapValues = $__require('npm:redux@3.0.5/lib/utils/mapValues');
  var _mapValues2 = _interopRequireDefault(_mapValues);
  function bindActionCreator(actionCreator, dispatch) {
    return function() {
      return dispatch(actionCreator.apply(undefined, arguments));
    };
  }
  function bindActionCreators(actionCreators, dispatch) {
    if (typeof actionCreators === 'function') {
      return bindActionCreator(actionCreators, dispatch);
    }
    if (typeof actionCreators !== 'object' || actionCreators === null || actionCreators === undefined) {
      throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
    }
    return _mapValues2['default'](actionCreators, function(actionCreator) {
      return bindActionCreator(actionCreator, dispatch);
    });
  }
  module.exports = exports['default'];
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:redux@3.0.5/lib/utils/applyMiddleware", ["npm:redux@3.0.5/lib/utils/compose"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.__esModule = true;
  var _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  exports['default'] = applyMiddleware;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _compose = $__require('npm:redux@3.0.5/lib/utils/compose');
  var _compose2 = _interopRequireDefault(_compose);
  function applyMiddleware() {
    for (var _len = arguments.length,
        middlewares = Array(_len),
        _key = 0; _key < _len; _key++) {
      middlewares[_key] = arguments[_key];
    }
    return function(next) {
      return function(reducer, initialState) {
        var store = next(reducer, initialState);
        var _dispatch = store.dispatch;
        var chain = [];
        var middlewareAPI = {
          getState: store.getState,
          dispatch: function dispatch(action) {
            return _dispatch(action);
          }
        };
        chain = middlewares.map(function(middleware) {
          return middleware(middlewareAPI);
        });
        _dispatch = _compose2['default'].apply(undefined, chain)(store.dispatch);
        return _extends({}, store, {dispatch: _dispatch});
      };
    };
  }
  module.exports = exports['default'];
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:redux@3.0.5/lib/utils/compose", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.__esModule = true;
  exports["default"] = compose;
  function compose() {
    for (var _len = arguments.length,
        funcs = Array(_len),
        _key = 0; _key < _len; _key++) {
      funcs[_key] = arguments[_key];
    }
    return function(arg) {
      return funcs.reduceRight(function(composed, f) {
        return f(composed);
      }, arg);
    };
  }
  module.exports = exports["default"];
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:redux@3.0.5/lib/index", ["npm:redux@3.0.5/lib/createStore", "npm:redux@3.0.5/lib/utils/combineReducers", "npm:redux@3.0.5/lib/utils/bindActionCreators", "npm:redux@3.0.5/lib/utils/applyMiddleware", "npm:redux@3.0.5/lib/utils/compose"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.__esModule = true;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _createStore = $__require('npm:redux@3.0.5/lib/createStore');
  var _createStore2 = _interopRequireDefault(_createStore);
  var _utilsCombineReducers = $__require('npm:redux@3.0.5/lib/utils/combineReducers');
  var _utilsCombineReducers2 = _interopRequireDefault(_utilsCombineReducers);
  var _utilsBindActionCreators = $__require('npm:redux@3.0.5/lib/utils/bindActionCreators');
  var _utilsBindActionCreators2 = _interopRequireDefault(_utilsBindActionCreators);
  var _utilsApplyMiddleware = $__require('npm:redux@3.0.5/lib/utils/applyMiddleware');
  var _utilsApplyMiddleware2 = _interopRequireDefault(_utilsApplyMiddleware);
  var _utilsCompose = $__require('npm:redux@3.0.5/lib/utils/compose');
  var _utilsCompose2 = _interopRequireDefault(_utilsCompose);
  exports.createStore = _createStore2['default'];
  exports.combineReducers = _utilsCombineReducers2['default'];
  exports.bindActionCreators = _utilsBindActionCreators2['default'];
  exports.applyMiddleware = _utilsApplyMiddleware2['default'];
  exports.compose = _utilsCompose2['default'];
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:redux@3.0.5", ["npm:redux@3.0.5/lib/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:redux@3.0.5/lib/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.11.2/browser", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      setTimeout(drainQueue, 0);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.11.2", ["npm:process@0.11.2/browser"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:process@0.11.2/browser');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2/index", ["npm:process@0.11.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? process : $__require('npm:process@0.11.2');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2", ["github:jspm/nodelibs-process@0.1.2/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:jspm/nodelibs-process@0.1.2/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:ramda@0.19.1/dist/ramda", ["github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    ;
    (function() {
      'use strict';
      var __ = {'@@functional/placeholder': true};
      var _arity = function _arity(n, fn) {
        switch (n) {
          case 0:
            return function() {
              return fn.apply(this, arguments);
            };
          case 1:
            return function(a0) {
              return fn.apply(this, arguments);
            };
          case 2:
            return function(a0, a1) {
              return fn.apply(this, arguments);
            };
          case 3:
            return function(a0, a1, a2) {
              return fn.apply(this, arguments);
            };
          case 4:
            return function(a0, a1, a2, a3) {
              return fn.apply(this, arguments);
            };
          case 5:
            return function(a0, a1, a2, a3, a4) {
              return fn.apply(this, arguments);
            };
          case 6:
            return function(a0, a1, a2, a3, a4, a5) {
              return fn.apply(this, arguments);
            };
          case 7:
            return function(a0, a1, a2, a3, a4, a5, a6) {
              return fn.apply(this, arguments);
            };
          case 8:
            return function(a0, a1, a2, a3, a4, a5, a6, a7) {
              return fn.apply(this, arguments);
            };
          case 9:
            return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
              return fn.apply(this, arguments);
            };
          case 10:
            return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
              return fn.apply(this, arguments);
            };
          default:
            throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
        }
      };
      var _arrayFromIterator = function _arrayFromIterator(iter) {
        var list = [];
        var next;
        while (!(next = iter.next()).done) {
          list.push(next.value);
        }
        return list;
      };
      var _cloneRegExp = function _cloneRegExp(pattern) {
        return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
      };
      var _complement = function _complement(f) {
        return function() {
          return !f.apply(this, arguments);
        };
      };
      var _concat = function _concat(set1, set2) {
        set1 = set1 || [];
        set2 = set2 || [];
        var idx;
        var len1 = set1.length;
        var len2 = set2.length;
        var result = [];
        idx = 0;
        while (idx < len1) {
          result[result.length] = set1[idx];
          idx += 1;
        }
        idx = 0;
        while (idx < len2) {
          result[result.length] = set2[idx];
          idx += 1;
        }
        return result;
      };
      var _containsWith = function _containsWith(pred, x, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
          if (pred(x, list[idx])) {
            return true;
          }
          idx += 1;
        }
        return false;
      };
      var _filter = function _filter(fn, list) {
        var idx = 0;
        var len = list.length;
        var result = [];
        while (idx < len) {
          if (fn(list[idx])) {
            result[result.length] = list[idx];
          }
          idx += 1;
        }
        return result;
      };
      var _forceReduced = function _forceReduced(x) {
        return {
          '@@transducer/value': x,
          '@@transducer/reduced': true
        };
      };
      var _has = function _has(prop, obj) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      };
      var _identity = function _identity(x) {
        return x;
      };
      var _isArguments = function() {
        var toString = Object.prototype.toString;
        return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
          return toString.call(x) === '[object Arguments]';
        } : function _isArguments(x) {
          return _has('callee', x);
        };
      }();
      var _isArray = Array.isArray || function _isArray(val) {
        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
      };
      var _isInteger = Number.isInteger || function _isInteger(n) {
        return n << 0 === n;
      };
      var _isNumber = function _isNumber(x) {
        return Object.prototype.toString.call(x) === '[object Number]';
      };
      var _isObject = function _isObject(x) {
        return Object.prototype.toString.call(x) === '[object Object]';
      };
      var _isPlaceholder = function _isPlaceholder(a) {
        return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
      };
      var _isRegExp = function _isRegExp(x) {
        return Object.prototype.toString.call(x) === '[object RegExp]';
      };
      var _isString = function _isString(x) {
        return Object.prototype.toString.call(x) === '[object String]';
      };
      var _isTransformer = function _isTransformer(obj) {
        return typeof obj['@@transducer/step'] === 'function';
      };
      var _map = function _map(fn, functor) {
        var idx = 0;
        var len = functor.length;
        var result = Array(len);
        while (idx < len) {
          result[idx] = fn(functor[idx]);
          idx += 1;
        }
        return result;
      };
      var _of = function _of(x) {
        return [x];
      };
      var _pipe = function _pipe(f, g) {
        return function() {
          return g.call(this, f.apply(this, arguments));
        };
      };
      var _pipeP = function _pipeP(f, g) {
        return function() {
          var ctx = this;
          return f.apply(ctx, arguments).then(function(x) {
            return g.call(ctx, x);
          });
        };
      };
      var _quote = function _quote(s) {
        var escaped = s.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b').replace(/\f/g, '\\f').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/\v/g, '\\v').replace(/\0/g, '\\0');
        return '"' + escaped.replace(/"/g, '\\"') + '"';
      };
      var _reduced = function _reduced(x) {
        return x && x['@@transducer/reduced'] ? x : {
          '@@transducer/value': x,
          '@@transducer/reduced': true
        };
      };
      var _slice = function _slice(args, from, to) {
        switch (arguments.length) {
          case 1:
            return _slice(args, 0, args.length);
          case 2:
            return _slice(args, from, args.length);
          default:
            var list = [];
            var idx = 0;
            var len = Math.max(0, Math.min(args.length, to) - from);
            while (idx < len) {
              list[idx] = args[from + idx];
              idx += 1;
            }
            return list;
        }
      };
      var _toISOString = function() {
        var pad = function pad(n) {
          return (n < 10 ? '0' : '') + n;
        };
        return typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
          return d.toISOString();
        } : function _toISOString(d) {
          return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
        };
      }();
      var _xfBase = {
        init: function() {
          return this.xf['@@transducer/init']();
        },
        result: function(result) {
          return this.xf['@@transducer/result'](result);
        }
      };
      var _xwrap = function() {
        function XWrap(fn) {
          this.f = fn;
        }
        XWrap.prototype['@@transducer/init'] = function() {
          throw new Error('init not implemented on XWrap');
        };
        XWrap.prototype['@@transducer/result'] = function(acc) {
          return acc;
        };
        XWrap.prototype['@@transducer/step'] = function(acc, x) {
          return this.f(acc, x);
        };
        return function _xwrap(fn) {
          return new XWrap(fn);
        };
      }();
      var _aperture = function _aperture(n, list) {
        var idx = 0;
        var limit = list.length - (n - 1);
        var acc = new Array(limit >= 0 ? limit : 0);
        while (idx < limit) {
          acc[idx] = _slice(list, idx, idx + n);
          idx += 1;
        }
        return acc;
      };
      var _checkForMethod = function _checkForMethod(methodname, fn) {
        return function() {
          var length = arguments.length;
          if (length === 0) {
            return fn();
          }
          var obj = arguments[length - 1];
          return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length - 1));
        };
      };
      var _curry1 = function _curry1(fn) {
        return function f1(a) {
          if (arguments.length === 0 || _isPlaceholder(a)) {
            return f1;
          } else {
            return fn.apply(this, arguments);
          }
        };
      };
      var _curry2 = function _curry2(fn) {
        return function f2(a, b) {
          switch (arguments.length) {
            case 0:
              return f2;
            case 1:
              return _isPlaceholder(a) ? f2 : _curry1(function(_b) {
                return fn(a, _b);
              });
            default:
              return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function(_a) {
                return fn(_a, b);
              }) : _isPlaceholder(b) ? _curry1(function(_b) {
                return fn(a, _b);
              }) : fn(a, b);
          }
        };
      };
      var _curry3 = function _curry3(fn) {
        return function f3(a, b, c) {
          switch (arguments.length) {
            case 0:
              return f3;
            case 1:
              return _isPlaceholder(a) ? f3 : _curry2(function(_b, _c) {
                return fn(a, _b, _c);
              });
            case 2:
              return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function(_a, _c) {
                return fn(_a, b, _c);
              }) : _isPlaceholder(b) ? _curry2(function(_b, _c) {
                return fn(a, _b, _c);
              }) : _curry1(function(_c) {
                return fn(a, b, _c);
              });
            default:
              return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function(_a, _b) {
                return fn(_a, _b, c);
              }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function(_a, _c) {
                return fn(_a, b, _c);
              }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function(_b, _c) {
                return fn(a, _b, _c);
              }) : _isPlaceholder(a) ? _curry1(function(_a) {
                return fn(_a, b, c);
              }) : _isPlaceholder(b) ? _curry1(function(_b) {
                return fn(a, _b, c);
              }) : _isPlaceholder(c) ? _curry1(function(_c) {
                return fn(a, b, _c);
              }) : fn(a, b, c);
          }
        };
      };
      var _curryN = function _curryN(length, received, fn) {
        return function() {
          var combined = [];
          var argsIdx = 0;
          var left = length;
          var combinedIdx = 0;
          while (combinedIdx < received.length || argsIdx < arguments.length) {
            var result;
            if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
              result = received[combinedIdx];
            } else {
              result = arguments[argsIdx];
              argsIdx += 1;
            }
            combined[combinedIdx] = result;
            if (!_isPlaceholder(result)) {
              left -= 1;
            }
            combinedIdx += 1;
          }
          return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
        };
      };
      var _dispatchable = function _dispatchable(methodname, xf, fn) {
        return function() {
          var length = arguments.length;
          if (length === 0) {
            return fn();
          }
          var obj = arguments[length - 1];
          if (!_isArray(obj)) {
            var args = _slice(arguments, 0, length - 1);
            if (typeof obj[methodname] === 'function') {
              return obj[methodname].apply(obj, args);
            }
            if (_isTransformer(obj)) {
              var transducer = xf.apply(null, args);
              return transducer(obj);
            }
          }
          return fn.apply(this, arguments);
        };
      };
      var _dropLastWhile = function dropLastWhile(pred, list) {
        var idx = list.length - 1;
        while (idx >= 0 && pred(list[idx])) {
          idx -= 1;
        }
        return _slice(list, 0, idx + 1);
      };
      var _xall = function() {
        function XAll(f, xf) {
          this.xf = xf;
          this.f = f;
          this.all = true;
        }
        XAll.prototype['@@transducer/init'] = _xfBase.init;
        XAll.prototype['@@transducer/result'] = function(result) {
          if (this.all) {
            result = this.xf['@@transducer/step'](result, true);
          }
          return this.xf['@@transducer/result'](result);
        };
        XAll.prototype['@@transducer/step'] = function(result, input) {
          if (!this.f(input)) {
            this.all = false;
            result = _reduced(this.xf['@@transducer/step'](result, false));
          }
          return result;
        };
        return _curry2(function _xall(f, xf) {
          return new XAll(f, xf);
        });
      }();
      var _xany = function() {
        function XAny(f, xf) {
          this.xf = xf;
          this.f = f;
          this.any = false;
        }
        XAny.prototype['@@transducer/init'] = _xfBase.init;
        XAny.prototype['@@transducer/result'] = function(result) {
          if (!this.any) {
            result = this.xf['@@transducer/step'](result, false);
          }
          return this.xf['@@transducer/result'](result);
        };
        XAny.prototype['@@transducer/step'] = function(result, input) {
          if (this.f(input)) {
            this.any = true;
            result = _reduced(this.xf['@@transducer/step'](result, true));
          }
          return result;
        };
        return _curry2(function _xany(f, xf) {
          return new XAny(f, xf);
        });
      }();
      var _xaperture = function() {
        function XAperture(n, xf) {
          this.xf = xf;
          this.pos = 0;
          this.full = false;
          this.acc = new Array(n);
        }
        XAperture.prototype['@@transducer/init'] = _xfBase.init;
        XAperture.prototype['@@transducer/result'] = function(result) {
          this.acc = null;
          return this.xf['@@transducer/result'](result);
        };
        XAperture.prototype['@@transducer/step'] = function(result, input) {
          this.store(input);
          return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;
        };
        XAperture.prototype.store = function(input) {
          this.acc[this.pos] = input;
          this.pos += 1;
          if (this.pos === this.acc.length) {
            this.pos = 0;
            this.full = true;
          }
        };
        XAperture.prototype.getCopy = function() {
          return _concat(_slice(this.acc, this.pos), _slice(this.acc, 0, this.pos));
        };
        return _curry2(function _xaperture(n, xf) {
          return new XAperture(n, xf);
        });
      }();
      var _xdrop = function() {
        function XDrop(n, xf) {
          this.xf = xf;
          this.n = n;
        }
        XDrop.prototype['@@transducer/init'] = _xfBase.init;
        XDrop.prototype['@@transducer/result'] = _xfBase.result;
        XDrop.prototype['@@transducer/step'] = function(result, input) {
          if (this.n > 0) {
            this.n -= 1;
            return result;
          }
          return this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdrop(n, xf) {
          return new XDrop(n, xf);
        });
      }();
      var _xdropLast = function() {
        function XDropLast(n, xf) {
          this.xf = xf;
          this.pos = 0;
          this.full = false;
          this.acc = new Array(n);
        }
        XDropLast.prototype['@@transducer/init'] = _xfBase.init;
        XDropLast.prototype['@@transducer/result'] = function(result) {
          this.acc = null;
          return this.xf['@@transducer/result'](result);
        };
        XDropLast.prototype['@@transducer/step'] = function(result, input) {
          if (this.full) {
            result = this.xf['@@transducer/step'](result, this.acc[this.pos]);
          }
          this.store(input);
          return result;
        };
        XDropLast.prototype.store = function(input) {
          this.acc[this.pos] = input;
          this.pos += 1;
          if (this.pos === this.acc.length) {
            this.pos = 0;
            this.full = true;
          }
        };
        return _curry2(function _xdropLast(n, xf) {
          return new XDropLast(n, xf);
        });
      }();
      var _xdropRepeatsWith = function() {
        function XDropRepeatsWith(pred, xf) {
          this.xf = xf;
          this.pred = pred;
          this.lastValue = undefined;
          this.seenFirstValue = false;
        }
        XDropRepeatsWith.prototype['@@transducer/init'] = function() {
          return this.xf['@@transducer/init']();
        };
        XDropRepeatsWith.prototype['@@transducer/result'] = function(result) {
          return this.xf['@@transducer/result'](result);
        };
        XDropRepeatsWith.prototype['@@transducer/step'] = function(result, input) {
          var sameAsLast = false;
          if (!this.seenFirstValue) {
            this.seenFirstValue = true;
          } else if (this.pred(this.lastValue, input)) {
            sameAsLast = true;
          }
          this.lastValue = input;
          return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdropRepeatsWith(pred, xf) {
          return new XDropRepeatsWith(pred, xf);
        });
      }();
      var _xdropWhile = function() {
        function XDropWhile(f, xf) {
          this.xf = xf;
          this.f = f;
        }
        XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
        XDropWhile.prototype['@@transducer/result'] = _xfBase.result;
        XDropWhile.prototype['@@transducer/step'] = function(result, input) {
          if (this.f) {
            if (this.f(input)) {
              return result;
            }
            this.f = null;
          }
          return this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdropWhile(f, xf) {
          return new XDropWhile(f, xf);
        });
      }();
      var _xfilter = function() {
        function XFilter(f, xf) {
          this.xf = xf;
          this.f = f;
        }
        XFilter.prototype['@@transducer/init'] = _xfBase.init;
        XFilter.prototype['@@transducer/result'] = _xfBase.result;
        XFilter.prototype['@@transducer/step'] = function(result, input) {
          return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
        };
        return _curry2(function _xfilter(f, xf) {
          return new XFilter(f, xf);
        });
      }();
      var _xfind = function() {
        function XFind(f, xf) {
          this.xf = xf;
          this.f = f;
          this.found = false;
        }
        XFind.prototype['@@transducer/init'] = _xfBase.init;
        XFind.prototype['@@transducer/result'] = function(result) {
          if (!this.found) {
            result = this.xf['@@transducer/step'](result, void 0);
          }
          return this.xf['@@transducer/result'](result);
        };
        XFind.prototype['@@transducer/step'] = function(result, input) {
          if (this.f(input)) {
            this.found = true;
            result = _reduced(this.xf['@@transducer/step'](result, input));
          }
          return result;
        };
        return _curry2(function _xfind(f, xf) {
          return new XFind(f, xf);
        });
      }();
      var _xfindIndex = function() {
        function XFindIndex(f, xf) {
          this.xf = xf;
          this.f = f;
          this.idx = -1;
          this.found = false;
        }
        XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
        XFindIndex.prototype['@@transducer/result'] = function(result) {
          if (!this.found) {
            result = this.xf['@@transducer/step'](result, -1);
          }
          return this.xf['@@transducer/result'](result);
        };
        XFindIndex.prototype['@@transducer/step'] = function(result, input) {
          this.idx += 1;
          if (this.f(input)) {
            this.found = true;
            result = _reduced(this.xf['@@transducer/step'](result, this.idx));
          }
          return result;
        };
        return _curry2(function _xfindIndex(f, xf) {
          return new XFindIndex(f, xf);
        });
      }();
      var _xfindLast = function() {
        function XFindLast(f, xf) {
          this.xf = xf;
          this.f = f;
        }
        XFindLast.prototype['@@transducer/init'] = _xfBase.init;
        XFindLast.prototype['@@transducer/result'] = function(result) {
          return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
        };
        XFindLast.prototype['@@transducer/step'] = function(result, input) {
          if (this.f(input)) {
            this.last = input;
          }
          return result;
        };
        return _curry2(function _xfindLast(f, xf) {
          return new XFindLast(f, xf);
        });
      }();
      var _xfindLastIndex = function() {
        function XFindLastIndex(f, xf) {
          this.xf = xf;
          this.f = f;
          this.idx = -1;
          this.lastIdx = -1;
        }
        XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;
        XFindLastIndex.prototype['@@transducer/result'] = function(result) {
          return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
        };
        XFindLastIndex.prototype['@@transducer/step'] = function(result, input) {
          this.idx += 1;
          if (this.f(input)) {
            this.lastIdx = this.idx;
          }
          return result;
        };
        return _curry2(function _xfindLastIndex(f, xf) {
          return new XFindLastIndex(f, xf);
        });
      }();
      var _xmap = function() {
        function XMap(f, xf) {
          this.xf = xf;
          this.f = f;
        }
        XMap.prototype['@@transducer/init'] = _xfBase.init;
        XMap.prototype['@@transducer/result'] = _xfBase.result;
        XMap.prototype['@@transducer/step'] = function(result, input) {
          return this.xf['@@transducer/step'](result, this.f(input));
        };
        return _curry2(function _xmap(f, xf) {
          return new XMap(f, xf);
        });
      }();
      var _xtake = function() {
        function XTake(n, xf) {
          this.xf = xf;
          this.n = n;
        }
        XTake.prototype['@@transducer/init'] = _xfBase.init;
        XTake.prototype['@@transducer/result'] = _xfBase.result;
        XTake.prototype['@@transducer/step'] = function(result, input) {
          if (this.n === 0) {
            return _reduced(result);
          } else {
            this.n -= 1;
            return this.xf['@@transducer/step'](result, input);
          }
        };
        return _curry2(function _xtake(n, xf) {
          return new XTake(n, xf);
        });
      }();
      var _xtakeWhile = function() {
        function XTakeWhile(f, xf) {
          this.xf = xf;
          this.f = f;
        }
        XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
        XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;
        XTakeWhile.prototype['@@transducer/step'] = function(result, input) {
          return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
        };
        return _curry2(function _xtakeWhile(f, xf) {
          return new XTakeWhile(f, xf);
        });
      }();
      var add = _curry2(function add(a, b) {
        return a + b;
      });
      var adjust = _curry3(function adjust(fn, idx, list) {
        if (idx >= list.length || idx < -list.length) {
          return list;
        }
        var start = idx < 0 ? list.length : 0;
        var _idx = start + idx;
        var _list = _concat(list);
        _list[_idx] = fn(list[_idx]);
        return _list;
      });
      var all = _curry2(_dispatchable('all', _xall, function all(fn, list) {
        var idx = 0;
        while (idx < list.length) {
          if (!fn(list[idx])) {
            return false;
          }
          idx += 1;
        }
        return true;
      }));
      var always = _curry1(function always(val) {
        return function() {
          return val;
        };
      });
      var and = _curry2(function and(a, b) {
        return a && b;
      });
      var any = _curry2(_dispatchable('any', _xany, function any(fn, list) {
        var idx = 0;
        while (idx < list.length) {
          if (fn(list[idx])) {
            return true;
          }
          idx += 1;
        }
        return false;
      }));
      var aperture = _curry2(_dispatchable('aperture', _xaperture, _aperture));
      var append = _curry2(function append(el, list) {
        return _concat(list, [el]);
      });
      var apply = _curry2(function apply(fn, args) {
        return fn.apply(this, args);
      });
      var assoc = _curry3(function assoc(prop, val, obj) {
        var result = {};
        for (var p in obj) {
          result[p] = obj[p];
        }
        result[prop] = val;
        return result;
      });
      var assocPath = _curry3(function assocPath(path, val, obj) {
        switch (path.length) {
          case 0:
            return val;
          case 1:
            return assoc(path[0], val, obj);
          default:
            return assoc(path[0], assocPath(_slice(path, 1), val, Object(obj[path[0]])), obj);
        }
      });
      var bind = _curry2(function bind(fn, thisObj) {
        return _arity(fn.length, function() {
          return fn.apply(thisObj, arguments);
        });
      });
      var both = _curry2(function both(f, g) {
        return function _both() {
          return f.apply(this, arguments) && g.apply(this, arguments);
        };
      });
      var comparator = _curry1(function comparator(pred) {
        return function(a, b) {
          return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
        };
      });
      var cond = _curry1(function cond(pairs) {
        return function() {
          var idx = 0;
          while (idx < pairs.length) {
            if (pairs[idx][0].apply(this, arguments)) {
              return pairs[idx][1].apply(this, arguments);
            }
            idx += 1;
          }
        };
      });
      var countBy = _curry2(function countBy(fn, list) {
        var counts = {};
        var len = list.length;
        var idx = 0;
        while (idx < len) {
          var key = fn(list[idx]);
          counts[key] = (_has(key, counts) ? counts[key] : 0) + 1;
          idx += 1;
        }
        return counts;
      });
      var curryN = _curry2(function curryN(length, fn) {
        if (length === 1) {
          return _curry1(fn);
        }
        return _arity(length, _curryN(length, [], fn));
      });
      var dec = add(-1);
      var defaultTo = _curry2(function defaultTo(d, v) {
        return v == null || v !== v ? d : v;
      });
      var differenceWith = _curry3(function differenceWith(pred, first, second) {
        var out = [];
        var idx = 0;
        var firstLen = first.length;
        while (idx < firstLen) {
          if (!_containsWith(pred, first[idx], second) && !_containsWith(pred, first[idx], out)) {
            out.push(first[idx]);
          }
          idx += 1;
        }
        return out;
      });
      var dissoc = _curry2(function dissoc(prop, obj) {
        var result = {};
        for (var p in obj) {
          if (p !== prop) {
            result[p] = obj[p];
          }
        }
        return result;
      });
      var dissocPath = _curry2(function dissocPath(path, obj) {
        switch (path.length) {
          case 0:
            return obj;
          case 1:
            return dissoc(path[0], obj);
          default:
            var head = path[0];
            var tail = _slice(path, 1);
            return obj[head] == null ? obj : assoc(head, dissocPath(tail, obj[head]), obj);
        }
      });
      var divide = _curry2(function divide(a, b) {
        return a / b;
      });
      var dropWhile = _curry2(_dispatchable('dropWhile', _xdropWhile, function dropWhile(pred, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len && pred(list[idx])) {
          idx += 1;
        }
        return _slice(list, idx);
      }));
      var either = _curry2(function either(f, g) {
        return function _either() {
          return f.apply(this, arguments) || g.apply(this, arguments);
        };
      });
      var empty = _curry1(function empty(x) {
        return x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function() {
          return arguments;
        }() : void 0;
      });
      var evolve = _curry2(function evolve(transformations, object) {
        var result = {};
        var transformation,
            key,
            type;
        for (key in object) {
          transformation = transformations[key];
          type = typeof transformation;
          result[key] = type === 'function' ? transformation(object[key]) : type === 'object' ? evolve(transformations[key], object[key]) : object[key];
        }
        return result;
      });
      var find = _curry2(_dispatchable('find', _xfind, function find(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
          if (fn(list[idx])) {
            return list[idx];
          }
          idx += 1;
        }
      }));
      var findIndex = _curry2(_dispatchable('findIndex', _xfindIndex, function findIndex(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
          if (fn(list[idx])) {
            return idx;
          }
          idx += 1;
        }
        return -1;
      }));
      var findLast = _curry2(_dispatchable('findLast', _xfindLast, function findLast(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
          if (fn(list[idx])) {
            return list[idx];
          }
          idx -= 1;
        }
      }));
      var findLastIndex = _curry2(_dispatchable('findLastIndex', _xfindLastIndex, function findLastIndex(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
          if (fn(list[idx])) {
            return idx;
          }
          idx -= 1;
        }
        return -1;
      }));
      var forEach = _curry2(_checkForMethod('forEach', function forEach(fn, list) {
        var len = list.length;
        var idx = 0;
        while (idx < len) {
          fn(list[idx]);
          idx += 1;
        }
        return list;
      }));
      var fromPairs = _curry1(function fromPairs(pairs) {
        var idx = 0;
        var len = pairs.length;
        var out = {};
        while (idx < len) {
          if (_isArray(pairs[idx]) && pairs[idx].length) {
            out[pairs[idx][0]] = pairs[idx][1];
          }
          idx += 1;
        }
        return out;
      });
      var gt = _curry2(function gt(a, b) {
        return a > b;
      });
      var gte = _curry2(function gte(a, b) {
        return a >= b;
      });
      var has = _curry2(_has);
      var hasIn = _curry2(function hasIn(prop, obj) {
        return prop in obj;
      });
      var identical = _curry2(function identical(a, b) {
        if (a === b) {
          return a !== 0 || 1 / a === 1 / b;
        } else {
          return a !== a && b !== b;
        }
      });
      var identity = _curry1(_identity);
      var ifElse = _curry3(function ifElse(condition, onTrue, onFalse) {
        return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
          return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
        });
      });
      var inc = add(1);
      var insert = _curry3(function insert(idx, elt, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        var result = _slice(list);
        result.splice(idx, 0, elt);
        return result;
      });
      var insertAll = _curry3(function insertAll(idx, elts, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        return _concat(_concat(_slice(list, 0, idx), elts), _slice(list, idx));
      });
      var intersperse = _curry2(_checkForMethod('intersperse', function intersperse(separator, list) {
        var out = [];
        var idx = 0;
        var length = list.length;
        while (idx < length) {
          if (idx === length - 1) {
            out.push(list[idx]);
          } else {
            out.push(list[idx], separator);
          }
          idx += 1;
        }
        return out;
      }));
      var is = _curry2(function is(Ctor, val) {
        return val != null && val.constructor === Ctor || val instanceof Ctor;
      });
      var isArrayLike = _curry1(function isArrayLike(x) {
        if (_isArray(x)) {
          return true;
        }
        if (!x) {
          return false;
        }
        if (typeof x !== 'object') {
          return false;
        }
        if (x instanceof String) {
          return false;
        }
        if (x.nodeType === 1) {
          return !!x.length;
        }
        if (x.length === 0) {
          return true;
        }
        if (x.length > 0) {
          return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
        }
        return false;
      });
      var isNil = _curry1(function isNil(x) {
        return x == null;
      });
      var keys = function() {
        var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
        var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
        var hasArgsEnumBug = function() {
          'use strict';
          return arguments.propertyIsEnumerable('length');
        }();
        var contains = function contains(list, item) {
          var idx = 0;
          while (idx < list.length) {
            if (list[idx] === item) {
              return true;
            }
            idx += 1;
          }
          return false;
        };
        return typeof Object.keys === 'function' && !hasArgsEnumBug ? _curry1(function keys(obj) {
          return Object(obj) !== obj ? [] : Object.keys(obj);
        }) : _curry1(function keys(obj) {
          if (Object(obj) !== obj) {
            return [];
          }
          var prop,
              nIdx;
          var ks = [];
          var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
          for (prop in obj) {
            if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
              ks[ks.length] = prop;
            }
          }
          if (hasEnumBug) {
            nIdx = nonEnumerableProps.length - 1;
            while (nIdx >= 0) {
              prop = nonEnumerableProps[nIdx];
              if (_has(prop, obj) && !contains(ks, prop)) {
                ks[ks.length] = prop;
              }
              nIdx -= 1;
            }
          }
          return ks;
        });
      }();
      var keysIn = _curry1(function keysIn(obj) {
        var prop;
        var ks = [];
        for (prop in obj) {
          ks[ks.length] = prop;
        }
        return ks;
      });
      var length = _curry1(function length(list) {
        return list != null && is(Number, list.length) ? list.length : NaN;
      });
      var lt = _curry2(function lt(a, b) {
        return a < b;
      });
      var lte = _curry2(function lte(a, b) {
        return a <= b;
      });
      var mapAccum = _curry3(function mapAccum(fn, acc, list) {
        var idx = 0;
        var len = list.length;
        var result = [];
        var tuple = [acc];
        while (idx < len) {
          tuple = fn(tuple[0], list[idx]);
          result[idx] = tuple[1];
          idx += 1;
        }
        return [tuple[0], result];
      });
      var mapAccumRight = _curry3(function mapAccumRight(fn, acc, list) {
        var idx = list.length - 1;
        var result = [];
        var tuple = [acc];
        while (idx >= 0) {
          tuple = fn(tuple[0], list[idx]);
          result[idx] = tuple[1];
          idx -= 1;
        }
        return [tuple[0], result];
      });
      var match = _curry2(function match(rx, str) {
        return str.match(rx) || [];
      });
      var mathMod = _curry2(function mathMod(m, p) {
        if (!_isInteger(m)) {
          return NaN;
        }
        if (!_isInteger(p) || p < 1) {
          return NaN;
        }
        return (m % p + p) % p;
      });
      var max = _curry2(function max(a, b) {
        return b > a ? b : a;
      });
      var maxBy = _curry3(function maxBy(f, a, b) {
        return f(b) > f(a) ? b : a;
      });
      var mergeWithKey = _curry3(function mergeWithKey(fn, l, r) {
        var result = {};
        var k;
        for (k in l) {
          if (_has(k, l)) {
            result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
          }
        }
        for (k in r) {
          if (_has(k, r) && !_has(k, result)) {
            result[k] = r[k];
          }
        }
        return result;
      });
      var min = _curry2(function min(a, b) {
        return b < a ? b : a;
      });
      var minBy = _curry3(function minBy(f, a, b) {
        return f(b) < f(a) ? b : a;
      });
      var modulo = _curry2(function modulo(a, b) {
        return a % b;
      });
      var multiply = _curry2(function multiply(a, b) {
        return a * b;
      });
      var nAry = _curry2(function nAry(n, fn) {
        switch (n) {
          case 0:
            return function() {
              return fn.call(this);
            };
          case 1:
            return function(a0) {
              return fn.call(this, a0);
            };
          case 2:
            return function(a0, a1) {
              return fn.call(this, a0, a1);
            };
          case 3:
            return function(a0, a1, a2) {
              return fn.call(this, a0, a1, a2);
            };
          case 4:
            return function(a0, a1, a2, a3) {
              return fn.call(this, a0, a1, a2, a3);
            };
          case 5:
            return function(a0, a1, a2, a3, a4) {
              return fn.call(this, a0, a1, a2, a3, a4);
            };
          case 6:
            return function(a0, a1, a2, a3, a4, a5) {
              return fn.call(this, a0, a1, a2, a3, a4, a5);
            };
          case 7:
            return function(a0, a1, a2, a3, a4, a5, a6) {
              return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
            };
          case 8:
            return function(a0, a1, a2, a3, a4, a5, a6, a7) {
              return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
            };
          case 9:
            return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
              return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
            };
          case 10:
            return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
              return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            };
          default:
            throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
        }
      });
      var negate = _curry1(function negate(n) {
        return -n;
      });
      var none = _curry2(_complement(_dispatchable('any', _xany, any)));
      var not = _curry1(function not(a) {
        return !a;
      });
      var nth = _curry2(function nth(offset, list) {
        var idx = offset < 0 ? list.length + offset : offset;
        return _isString(list) ? list.charAt(idx) : list[idx];
      });
      var nthArg = _curry1(function nthArg(n) {
        return function() {
          return nth(n, arguments);
        };
      });
      var objOf = _curry2(function objOf(key, val) {
        var obj = {};
        obj[key] = val;
        return obj;
      });
      var of = _curry1(_of);
      var once = _curry1(function once(fn) {
        var called = false;
        var result;
        return _arity(fn.length, function() {
          if (called) {
            return result;
          }
          called = true;
          result = fn.apply(this, arguments);
          return result;
        });
      });
      var or = _curry2(function or(a, b) {
        return a || b;
      });
      var over = function() {
        var Identity = function(x) {
          return {
            value: x,
            map: function(f) {
              return Identity(f(x));
            }
          };
        };
        return _curry3(function over(lens, f, x) {
          return lens(function(y) {
            return Identity(f(y));
          })(x).value;
        });
      }();
      var pair = _curry2(function pair(fst, snd) {
        return [fst, snd];
      });
      var path = _curry2(function path(paths, obj) {
        var val = obj;
        var idx = 0;
        while (idx < paths.length) {
          if (val == null) {
            return;
          }
          val = val[paths[idx]];
          idx += 1;
        }
        return val;
      });
      var pathOr = _curry3(function pathOr(d, p, obj) {
        return defaultTo(d, path(p, obj));
      });
      var pathSatisfies = _curry3(function pathSatisfies(pred, propPath, obj) {
        return propPath.length > 0 && pred(path(propPath, obj));
      });
      var pick = _curry2(function pick(names, obj) {
        var result = {};
        var idx = 0;
        while (idx < names.length) {
          if (names[idx] in obj) {
            result[names[idx]] = obj[names[idx]];
          }
          idx += 1;
        }
        return result;
      });
      var pickAll = _curry2(function pickAll(names, obj) {
        var result = {};
        var idx = 0;
        var len = names.length;
        while (idx < len) {
          var name = names[idx];
          result[name] = obj[name];
          idx += 1;
        }
        return result;
      });
      var pickBy = _curry2(function pickBy(test, obj) {
        var result = {};
        for (var prop in obj) {
          if (test(obj[prop], prop, obj)) {
            result[prop] = obj[prop];
          }
        }
        return result;
      });
      var prepend = _curry2(function prepend(el, list) {
        return _concat([el], list);
      });
      var prop = _curry2(function prop(p, obj) {
        return obj[p];
      });
      var propOr = _curry3(function propOr(val, p, obj) {
        return obj != null && _has(p, obj) ? obj[p] : val;
      });
      var propSatisfies = _curry3(function propSatisfies(pred, name, obj) {
        return pred(obj[name]);
      });
      var props = _curry2(function props(ps, obj) {
        var len = ps.length;
        var out = [];
        var idx = 0;
        while (idx < len) {
          out[idx] = obj[ps[idx]];
          idx += 1;
        }
        return out;
      });
      var range = _curry2(function range(from, to) {
        if (!(_isNumber(from) && _isNumber(to))) {
          throw new TypeError('Both arguments to range must be numbers');
        }
        var result = [];
        var n = from;
        while (n < to) {
          result.push(n);
          n += 1;
        }
        return result;
      });
      var reduceRight = _curry3(function reduceRight(fn, acc, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
          acc = fn(acc, list[idx]);
          idx -= 1;
        }
        return acc;
      });
      var reduced = _curry1(_reduced);
      var remove = _curry3(function remove(start, count, list) {
        return _concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));
      });
      var replace = _curry3(function replace(regex, replacement, str) {
        return str.replace(regex, replacement);
      });
      var reverse = _curry1(function reverse(list) {
        return _isString(list) ? list.split('').reverse().join('') : _slice(list).reverse();
      });
      var scan = _curry3(function scan(fn, acc, list) {
        var idx = 0;
        var len = list.length;
        var result = [acc];
        while (idx < len) {
          acc = fn(acc, list[idx]);
          result[idx + 1] = acc;
          idx += 1;
        }
        return result;
      });
      var set = _curry3(function set(lens, v, x) {
        return over(lens, always(v), x);
      });
      var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
        return Array.prototype.slice.call(list, fromIndex, toIndex);
      }));
      var sort = _curry2(function sort(comparator, list) {
        return _slice(list).sort(comparator);
      });
      var sortBy = _curry2(function sortBy(fn, list) {
        return _slice(list).sort(function(a, b) {
          var aa = fn(a);
          var bb = fn(b);
          return aa < bb ? -1 : aa > bb ? 1 : 0;
        });
      });
      var splitAt = _curry2(function splitAt(index, array) {
        return [slice(0, index, array), slice(index, length(array), array)];
      });
      var splitEvery = _curry2(function splitEvery(n, list) {
        if (n <= 0) {
          throw new Error('First argument to splitEvery must be a positive integer');
        }
        var result = [];
        var idx = 0;
        while (idx < list.length) {
          result.push(slice(idx, idx += n, list));
        }
        return result;
      });
      var splitWhen = _curry2(function splitWhen(pred, list) {
        var idx = 0;
        var len = list.length;
        var prefix = [];
        while (idx < len && !pred(list[idx])) {
          prefix.push(list[idx]);
          idx += 1;
        }
        return [prefix, _slice(list, idx)];
      });
      var subtract = _curry2(function subtract(a, b) {
        return a - b;
      });
      var tail = _checkForMethod('tail', slice(1, Infinity));
      var take = _curry2(_dispatchable('take', _xtake, function take(n, xs) {
        return slice(0, n < 0 ? Infinity : n, xs);
      }));
      var takeLastWhile = _curry2(function takeLastWhile(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0 && fn(list[idx])) {
          idx -= 1;
        }
        return _slice(list, idx + 1, Infinity);
      });
      var takeWhile = _curry2(_dispatchable('takeWhile', _xtakeWhile, function takeWhile(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len && fn(list[idx])) {
          idx += 1;
        }
        return _slice(list, 0, idx);
      }));
      var tap = _curry2(function tap(fn, x) {
        fn(x);
        return x;
      });
      var times = _curry2(function times(fn, n) {
        var len = Number(n);
        var idx = 0;
        var list;
        if (len < 0 || isNaN(len)) {
          throw new RangeError('n must be a non-negative number');
        }
        list = new Array(len);
        while (idx < len) {
          list[idx] = fn(idx);
          idx += 1;
        }
        return list;
      });
      var toPairs = _curry1(function toPairs(obj) {
        var pairs = [];
        for (var prop in obj) {
          if (_has(prop, obj)) {
            pairs[pairs.length] = [prop, obj[prop]];
          }
        }
        return pairs;
      });
      var toPairsIn = _curry1(function toPairsIn(obj) {
        var pairs = [];
        for (var prop in obj) {
          pairs[pairs.length] = [prop, obj[prop]];
        }
        return pairs;
      });
      var transpose = _curry1(function transpose(outerlist) {
        var i = 0;
        var result = [];
        while (i < outerlist.length) {
          var innerlist = outerlist[i];
          var j = 0;
          while (j < innerlist.length) {
            if (typeof result[j] === 'undefined') {
              result[j] = [];
            }
            result[j].push(innerlist[j]);
            j += 1;
          }
          i += 1;
        }
        return result;
      });
      var trim = function() {
        var ws = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
        var zeroWidth = '\u200B';
        var hasProtoTrim = typeof String.prototype.trim === 'function';
        if (!hasProtoTrim || (ws.trim() || !zeroWidth.trim())) {
          return _curry1(function trim(str) {
            var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
            var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
            return str.replace(beginRx, '').replace(endRx, '');
          });
        } else {
          return _curry1(function trim(str) {
            return str.trim();
          });
        }
      }();
      var type = _curry1(function type(val) {
        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
      });
      var unapply = _curry1(function unapply(fn) {
        return function() {
          return fn(_slice(arguments));
        };
      });
      var unary = _curry1(function unary(fn) {
        return nAry(1, fn);
      });
      var uncurryN = _curry2(function uncurryN(depth, fn) {
        return curryN(depth, function() {
          var currentDepth = 1;
          var value = fn;
          var idx = 0;
          var endIdx;
          while (currentDepth <= depth && typeof value === 'function') {
            endIdx = currentDepth === depth ? arguments.length : idx + value.length;
            value = value.apply(this, _slice(arguments, idx, endIdx));
            currentDepth += 1;
            idx = endIdx;
          }
          return value;
        });
      });
      var unfold = _curry2(function unfold(fn, seed) {
        var pair = fn(seed);
        var result = [];
        while (pair && pair.length) {
          result[result.length] = pair[0];
          pair = fn(pair[1]);
        }
        return result;
      });
      var uniqWith = _curry2(function uniqWith(pred, list) {
        var idx = 0;
        var len = list.length;
        var result = [];
        var item;
        while (idx < len) {
          item = list[idx];
          if (!_containsWith(pred, item, result)) {
            result[result.length] = item;
          }
          idx += 1;
        }
        return result;
      });
      var unless = _curry3(function unless(pred, whenFalseFn, x) {
        return pred(x) ? x : whenFalseFn(x);
      });
      var update = _curry3(function update(idx, x, list) {
        return adjust(always(x), idx, list);
      });
      var useWith = _curry2(function useWith(fn, transformers) {
        return curryN(transformers.length, function() {
          var args = [];
          var idx = 0;
          while (idx < transformers.length) {
            args.push(transformers[idx].call(this, arguments[idx]));
            idx += 1;
          }
          return fn.apply(this, args.concat(_slice(arguments, transformers.length)));
        });
      });
      var values = _curry1(function values(obj) {
        var props = keys(obj);
        var len = props.length;
        var vals = [];
        var idx = 0;
        while (idx < len) {
          vals[idx] = obj[props[idx]];
          idx += 1;
        }
        return vals;
      });
      var valuesIn = _curry1(function valuesIn(obj) {
        var prop;
        var vs = [];
        for (prop in obj) {
          vs[vs.length] = obj[prop];
        }
        return vs;
      });
      var view = function() {
        var Const = function(x) {
          return {
            value: x,
            map: function() {
              return this;
            }
          };
        };
        return _curry2(function view(lens, x) {
          return lens(Const)(x).value;
        });
      }();
      var when = _curry3(function when(pred, whenTrueFn, x) {
        return pred(x) ? whenTrueFn(x) : x;
      });
      var where = _curry2(function where(spec, testObj) {
        for (var prop in spec) {
          if (_has(prop, spec) && !spec[prop](testObj[prop])) {
            return false;
          }
        }
        return true;
      });
      var wrap = _curry2(function wrap(fn, wrapper) {
        return curryN(fn.length, function() {
          return wrapper.apply(this, _concat([fn], arguments));
        });
      });
      var xprod = _curry2(function xprod(a, b) {
        var idx = 0;
        var ilen = a.length;
        var j;
        var jlen = b.length;
        var result = [];
        while (idx < ilen) {
          j = 0;
          while (j < jlen) {
            result[result.length] = [a[idx], b[j]];
            j += 1;
          }
          idx += 1;
        }
        return result;
      });
      var zip = _curry2(function zip(a, b) {
        var rv = [];
        var idx = 0;
        var len = Math.min(a.length, b.length);
        while (idx < len) {
          rv[idx] = [a[idx], b[idx]];
          idx += 1;
        }
        return rv;
      });
      var zipObj = _curry2(function zipObj(keys, values) {
        var idx = 0;
        var len = keys.length;
        var out = {};
        while (idx < len) {
          out[keys[idx]] = values[idx];
          idx += 1;
        }
        return out;
      });
      var zipWith = _curry3(function zipWith(fn, a, b) {
        var rv = [];
        var idx = 0;
        var len = Math.min(a.length, b.length);
        while (idx < len) {
          rv[idx] = fn(a[idx], b[idx]);
          idx += 1;
        }
        return rv;
      });
      var F = always(false);
      var T = always(true);
      var _clone = function _clone(value, refFrom, refTo) {
        var copy = function copy(copiedValue) {
          var len = refFrom.length;
          var idx = 0;
          while (idx < len) {
            if (value === refFrom[idx]) {
              return refTo[idx];
            }
            idx += 1;
          }
          refFrom[idx + 1] = value;
          refTo[idx + 1] = copiedValue;
          for (var key in value) {
            copiedValue[key] = _clone(value[key], refFrom, refTo);
          }
          return copiedValue;
        };
        switch (type(value)) {
          case 'Object':
            return copy({});
          case 'Array':
            return copy([]);
          case 'Date':
            return new Date(value.valueOf());
          case 'RegExp':
            return _cloneRegExp(value);
          default:
            return value;
        }
      };
      var _createPartialApplicator = function _createPartialApplicator(concat) {
        return _curry2(function(fn, args) {
          return _arity(Math.max(0, fn.length - args.length), function() {
            return fn.apply(this, concat(args, arguments));
          });
        });
      };
      var _dropLast = function dropLast(n, xs) {
        return take(n < xs.length ? xs.length - n : 0, xs);
      };
      var _equals = function _equals(a, b, stackA, stackB) {
        if (identical(a, b)) {
          return true;
        }
        if (type(a) !== type(b)) {
          return false;
        }
        if (a == null || b == null) {
          return false;
        }
        if (typeof a.equals === 'function' || typeof b.equals === 'function') {
          return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
        }
        switch (type(a)) {
          case 'Arguments':
          case 'Array':
          case 'Object':
            break;
          case 'Boolean':
          case 'Number':
          case 'String':
            if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {
              return false;
            }
            break;
          case 'Date':
            if (!identical(a.valueOf(), b.valueOf())) {
              return false;
            }
            break;
          case 'Error':
            return a.name === b.name && a.message === b.message;
          case 'RegExp':
            if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
              return false;
            }
            break;
          case 'Map':
          case 'Set':
            if (!_equals(_arrayFromIterator(a.entries()), _arrayFromIterator(b.entries()), stackA, stackB)) {
              return false;
            }
            break;
          case 'Int8Array':
          case 'Uint8Array':
          case 'Uint8ClampedArray':
          case 'Int16Array':
          case 'Uint16Array':
          case 'Int32Array':
          case 'Uint32Array':
          case 'Float32Array':
          case 'Float64Array':
            break;
          case 'ArrayBuffer':
            break;
          default:
            return false;
        }
        var keysA = keys(a);
        if (keysA.length !== keys(b).length) {
          return false;
        }
        var idx = stackA.length - 1;
        while (idx >= 0) {
          if (stackA[idx] === a) {
            return stackB[idx] === b;
          }
          idx -= 1;
        }
        stackA.push(a);
        stackB.push(b);
        idx = keysA.length - 1;
        while (idx >= 0) {
          var key = keysA[idx];
          if (!(_has(key, b) && _equals(b[key], a[key], stackA, stackB))) {
            return false;
          }
          idx -= 1;
        }
        stackA.pop();
        stackB.pop();
        return true;
      };
      var _makeFlat = function _makeFlat(recursive) {
        return function flatt(list) {
          var value,
              jlen,
              j;
          var result = [];
          var idx = 0;
          var ilen = list.length;
          while (idx < ilen) {
            if (isArrayLike(list[idx])) {
              value = recursive ? flatt(list[idx]) : list[idx];
              j = 0;
              jlen = value.length;
              while (j < jlen) {
                result[result.length] = value[j];
                j += 1;
              }
            } else {
              result[result.length] = list[idx];
            }
            idx += 1;
          }
          return result;
        };
      };
      var _reduce = function() {
        function _arrayReduce(xf, acc, list) {
          var idx = 0;
          var len = list.length;
          while (idx < len) {
            acc = xf['@@transducer/step'](acc, list[idx]);
            if (acc && acc['@@transducer/reduced']) {
              acc = acc['@@transducer/value'];
              break;
            }
            idx += 1;
          }
          return xf['@@transducer/result'](acc);
        }
        function _iterableReduce(xf, acc, iter) {
          var step = iter.next();
          while (!step.done) {
            acc = xf['@@transducer/step'](acc, step.value);
            if (acc && acc['@@transducer/reduced']) {
              acc = acc['@@transducer/value'];
              break;
            }
            step = iter.next();
          }
          return xf['@@transducer/result'](acc);
        }
        function _methodReduce(xf, acc, obj) {
          return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
        }
        var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
        return function _reduce(fn, acc, list) {
          if (typeof fn === 'function') {
            fn = _xwrap(fn);
          }
          if (isArrayLike(list)) {
            return _arrayReduce(fn, acc, list);
          }
          if (typeof list.reduce === 'function') {
            return _methodReduce(fn, acc, list);
          }
          if (list[symIterator] != null) {
            return _iterableReduce(fn, acc, list[symIterator]());
          }
          if (typeof list.next === 'function') {
            return _iterableReduce(fn, acc, list);
          }
          throw new TypeError('reduce: list must be array or iterable');
        };
      }();
      var _xdropLastWhile = function() {
        function XDropLastWhile(fn, xf) {
          this.f = fn;
          this.retained = [];
          this.xf = xf;
        }
        XDropLastWhile.prototype['@@transducer/init'] = _xfBase.init;
        XDropLastWhile.prototype['@@transducer/result'] = function(result) {
          this.retained = null;
          return this.xf['@@transducer/result'](result);
        };
        XDropLastWhile.prototype['@@transducer/step'] = function(result, input) {
          return this.f(input) ? this.retain(result, input) : this.flush(result, input);
        };
        XDropLastWhile.prototype.flush = function(result, input) {
          result = _reduce(this.xf['@@transducer/step'], result, this.retained);
          this.retained = [];
          return this.xf['@@transducer/step'](result, input);
        };
        XDropLastWhile.prototype.retain = function(result, input) {
          this.retained.push(input);
          return result;
        };
        return _curry2(function _xdropLastWhile(fn, xf) {
          return new XDropLastWhile(fn, xf);
        });
      }();
      var _xgroupBy = function() {
        function XGroupBy(f, xf) {
          this.xf = xf;
          this.f = f;
          this.inputs = {};
        }
        XGroupBy.prototype['@@transducer/init'] = _xfBase.init;
        XGroupBy.prototype['@@transducer/result'] = function(result) {
          var key;
          for (key in this.inputs) {
            if (_has(key, this.inputs)) {
              result = this.xf['@@transducer/step'](result, this.inputs[key]);
              if (result['@@transducer/reduced']) {
                result = result['@@transducer/value'];
                break;
              }
            }
          }
          this.inputs = null;
          return this.xf['@@transducer/result'](result);
        };
        XGroupBy.prototype['@@transducer/step'] = function(result, input) {
          var key = this.f(input);
          this.inputs[key] = this.inputs[key] || [key, []];
          this.inputs[key][1] = append(input, this.inputs[key][1]);
          return result;
        };
        return _curry2(function _xgroupBy(f, xf) {
          return new XGroupBy(f, xf);
        });
      }();
      var addIndex = _curry1(function addIndex(fn) {
        return curryN(fn.length, function() {
          var idx = 0;
          var origFn = arguments[0];
          var list = arguments[arguments.length - 1];
          var args = _slice(arguments);
          args[0] = function() {
            var result = origFn.apply(this, _concat(arguments, [idx, list]));
            idx += 1;
            return result;
          };
          return fn.apply(this, args);
        });
      });
      var binary = _curry1(function binary(fn) {
        return nAry(2, fn);
      });
      var clone = _curry1(function clone(value) {
        return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, [], []);
      });
      var curry = _curry1(function curry(fn) {
        return curryN(fn.length, fn);
      });
      var drop = _curry2(_dispatchable('drop', _xdrop, function drop(n, xs) {
        return slice(Math.max(0, n), Infinity, xs);
      }));
      var dropLast = _curry2(_dispatchable('dropLast', _xdropLast, _dropLast));
      var dropLastWhile = _curry2(_dispatchable('dropLastWhile', _xdropLastWhile, _dropLastWhile));
      var equals = _curry2(function equals(a, b) {
        return _equals(a, b, [], []);
      });
      var filter = _curry2(_dispatchable('filter', _xfilter, function(pred, filterable) {
        return _isObject(filterable) ? _reduce(function(acc, key) {
          if (pred(filterable[key])) {
            acc[key] = filterable[key];
          }
          return acc;
        }, {}, keys(filterable)) : _filter(pred, filterable);
      }));
      var flatten = _curry1(_makeFlat(true));
      var flip = _curry1(function flip(fn) {
        return curry(function(a, b) {
          var args = _slice(arguments);
          args[0] = b;
          args[1] = a;
          return fn.apply(this, args);
        });
      });
      var groupBy = _curry2(_dispatchable('groupBy', _xgroupBy, function groupBy(fn, list) {
        return _reduce(function(acc, elt) {
          var key = fn(elt);
          acc[key] = append(elt, acc[key] || (acc[key] = []));
          return acc;
        }, {}, list);
      }));
      var head = nth(0);
      var indexBy = _curry2(function indexBy(fn, list) {
        return _reduce(function(acc, elem) {
          var key = fn(elem);
          acc[key] = elem;
          return acc;
        }, {}, list);
      });
      var init = slice(0, -1);
      var intersectionWith = _curry3(function intersectionWith(pred, list1, list2) {
        var results = [];
        var idx = 0;
        while (idx < list1.length) {
          if (_containsWith(pred, list1[idx], list2)) {
            results[results.length] = list1[idx];
          }
          idx += 1;
        }
        return uniqWith(pred, results);
      });
      var invert = _curry1(function invert(obj) {
        var props = keys(obj);
        var len = props.length;
        var idx = 0;
        var out = {};
        while (idx < len) {
          var key = props[idx];
          var val = obj[key];
          var list = _has(val, out) ? out[val] : out[val] = [];
          list[list.length] = key;
          idx += 1;
        }
        return out;
      });
      var invertObj = _curry1(function invertObj(obj) {
        var props = keys(obj);
        var len = props.length;
        var idx = 0;
        var out = {};
        while (idx < len) {
          var key = props[idx];
          out[obj[key]] = key;
          idx += 1;
        }
        return out;
      });
      var isEmpty = _curry1(function isEmpty(x) {
        return x != null && equals(x, empty(x));
      });
      var last = nth(-1);
      var lastIndexOf = _curry2(function lastIndexOf(target, xs) {
        if (typeof xs.lastIndexOf === 'function' && !_isArray(xs)) {
          return xs.lastIndexOf(target);
        } else {
          var idx = xs.length - 1;
          while (idx >= 0) {
            if (equals(xs[idx], target)) {
              return idx;
            }
            idx -= 1;
          }
          return -1;
        }
      });
      var map = _curry2(_dispatchable('map', _xmap, function map(fn, functor) {
        switch (Object.prototype.toString.call(functor)) {
          case '[object Function]':
            return curryN(functor.length, function() {
              return fn.call(this, functor.apply(this, arguments));
            });
          case '[object Object]':
            return _reduce(function(acc, key) {
              acc[key] = fn(functor[key]);
              return acc;
            }, {}, keys(functor));
          default:
            return _map(fn, functor);
        }
      }));
      var mapObjIndexed = _curry2(function mapObjIndexed(fn, obj) {
        return _reduce(function(acc, key) {
          acc[key] = fn(obj[key], key, obj);
          return acc;
        }, {}, keys(obj));
      });
      var mergeWith = _curry3(function mergeWith(fn, l, r) {
        return mergeWithKey(function(_, _l, _r) {
          return fn(_l, _r);
        }, l, r);
      });
      var partial = _createPartialApplicator(_concat);
      var partialRight = _createPartialApplicator(flip(_concat));
      var partition = _curry2(function partition(pred, list) {
        return _reduce(function(acc, elt) {
          var xs = acc[pred(elt) ? 0 : 1];
          xs[xs.length] = elt;
          return acc;
        }, [[], []], list);
      });
      var pathEq = _curry3(function pathEq(_path, val, obj) {
        return equals(path(_path, obj), val);
      });
      var pluck = _curry2(function pluck(p, list) {
        return map(prop(p), list);
      });
      var project = useWith(_map, [pickAll, identity]);
      var propEq = _curry3(function propEq(name, val, obj) {
        return propSatisfies(equals(val), name, obj);
      });
      var propIs = _curry3(function propIs(type, name, obj) {
        return propSatisfies(is(type), name, obj);
      });
      var reduce = _curry3(_reduce);
      var reject = _curry2(function reject(pred, filterable) {
        return filter(_complement(pred), filterable);
      });
      var repeat = _curry2(function repeat(value, n) {
        return times(always(value), n);
      });
      var sum = reduce(add, 0);
      var takeLast = _curry2(function takeLast(n, xs) {
        return drop(n >= 0 ? xs.length - n : 0, xs);
      });
      var transduce = curryN(4, function transduce(xf, fn, acc, list) {
        return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
      });
      var unionWith = _curry3(function unionWith(pred, list1, list2) {
        return uniqWith(pred, _concat(list1, list2));
      });
      var whereEq = _curry2(function whereEq(spec, testObj) {
        return where(map(equals, spec), testObj);
      });
      var _flatCat = function() {
        var preservingReduced = function(xf) {
          return {
            '@@transducer/init': _xfBase.init,
            '@@transducer/result': function(result) {
              return xf['@@transducer/result'](result);
            },
            '@@transducer/step': function(result, input) {
              var ret = xf['@@transducer/step'](result, input);
              return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
            }
          };
        };
        return function _xcat(xf) {
          var rxf = preservingReduced(xf);
          return {
            '@@transducer/init': _xfBase.init,
            '@@transducer/result': function(result) {
              return rxf['@@transducer/result'](result);
            },
            '@@transducer/step': function(result, input) {
              return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
            }
          };
        };
      }();
      var _indexOf = function _indexOf(list, a, idx) {
        var inf,
            item;
        if (typeof list.indexOf === 'function') {
          switch (typeof a) {
            case 'number':
              if (a === 0) {
                inf = 1 / a;
                while (idx < list.length) {
                  item = list[idx];
                  if (item === 0 && 1 / item === inf) {
                    return idx;
                  }
                  idx += 1;
                }
                return -1;
              } else if (a !== a) {
                while (idx < list.length) {
                  item = list[idx];
                  if (typeof item === 'number' && item !== item) {
                    return idx;
                  }
                  idx += 1;
                }
                return -1;
              }
              return list.indexOf(a, idx);
            case 'string':
            case 'boolean':
            case 'function':
            case 'undefined':
              return list.indexOf(a, idx);
            case 'object':
              if (a === null) {
                return list.indexOf(a, idx);
              }
          }
        }
        while (idx < list.length) {
          if (equals(list[idx], a)) {
            return idx;
          }
          idx += 1;
        }
        return -1;
      };
      var _xchain = _curry2(function _xchain(f, xf) {
        return map(f, _flatCat(xf));
      });
      var allPass = _curry1(function allPass(preds) {
        return curryN(reduce(max, 0, pluck('length', preds)), function() {
          var idx = 0;
          var len = preds.length;
          while (idx < len) {
            if (!preds[idx].apply(this, arguments)) {
              return false;
            }
            idx += 1;
          }
          return true;
        });
      });
      var allUniq = _curry1(function allUniq(list) {
        var len = list.length;
        var idx = 0;
        while (idx < len) {
          if (_indexOf(list, list[idx], idx + 1) >= 0) {
            return false;
          }
          idx += 1;
        }
        return true;
      });
      var anyPass = _curry1(function anyPass(preds) {
        return curryN(reduce(max, 0, pluck('length', preds)), function() {
          var idx = 0;
          var len = preds.length;
          while (idx < len) {
            if (preds[idx].apply(this, arguments)) {
              return true;
            }
            idx += 1;
          }
          return false;
        });
      });
      var ap = _curry2(function ap(applicative, fn) {
        return typeof applicative.ap === 'function' ? applicative.ap(fn) : typeof applicative === 'function' ? curryN(Math.max(applicative.length, fn.length), function() {
          return applicative.apply(this, arguments)(fn.apply(this, arguments));
        }) : _reduce(function(acc, f) {
          return _concat(acc, map(f, fn));
        }, [], applicative);
      });
      var call = curry(function call(fn) {
        return fn.apply(this, _slice(arguments, 1));
      });
      var chain = _curry2(_dispatchable('chain', _xchain, function chain(fn, monad) {
        if (typeof monad === 'function') {
          return function() {
            return monad.call(this, fn.apply(this, arguments)).apply(this, arguments);
          };
        }
        return _makeFlat(false)(map(fn, monad));
      }));
      var commuteMap = _curry3(function commuteMap(fn, of, list) {
        function consF(acc, x) {
          return ap(map(prepend, fn(x)), acc);
        }
        return reduceRight(consF, of([]), list);
      });
      var constructN = _curry2(function constructN(n, Fn) {
        if (n > 10) {
          throw new Error('Constructor with greater than ten arguments');
        }
        if (n === 0) {
          return function() {
            return new Fn();
          };
        }
        return curry(nAry(n, function($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
          switch (arguments.length) {
            case 1:
              return new Fn($0);
            case 2:
              return new Fn($0, $1);
            case 3:
              return new Fn($0, $1, $2);
            case 4:
              return new Fn($0, $1, $2, $3);
            case 5:
              return new Fn($0, $1, $2, $3, $4);
            case 6:
              return new Fn($0, $1, $2, $3, $4, $5);
            case 7:
              return new Fn($0, $1, $2, $3, $4, $5, $6);
            case 8:
              return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
            case 9:
              return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
            case 10:
              return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
          }
        }));
      });
      var converge = _curry2(function converge(after, fns) {
        return curryN(Math.max.apply(Math, pluck('length', fns)), function() {
          var args = arguments;
          var context = this;
          return after.apply(context, _map(function(fn) {
            return fn.apply(context, args);
          }, fns));
        });
      });
      var dropRepeatsWith = _curry2(_dispatchable('dropRepeatsWith', _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
        var result = [];
        var idx = 1;
        var len = list.length;
        if (len !== 0) {
          result[0] = list[0];
          while (idx < len) {
            if (!pred(last(result), list[idx])) {
              result[result.length] = list[idx];
            }
            idx += 1;
          }
        }
        return result;
      }));
      var eqBy = _curry3(function eqBy(f, x, y) {
        return equals(f(x), f(y));
      });
      var eqProps = _curry3(function eqProps(prop, obj1, obj2) {
        return equals(obj1[prop], obj2[prop]);
      });
      var indexOf = _curry2(function indexOf(target, xs) {
        return typeof xs.indexOf === 'function' && !_isArray(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
      });
      var juxt = _curry1(function juxt(fns) {
        return function() {
          return map(apply(__, arguments), fns);
        };
      });
      var lens = _curry2(function lens(getter, setter) {
        return function(f) {
          return function(s) {
            return map(function(v) {
              return setter(v, s);
            }, f(getter(s)));
          };
        };
      });
      var lensIndex = _curry1(function lensIndex(n) {
        return lens(nth(n), update(n));
      });
      var lensPath = _curry1(function lensPath(p) {
        return lens(path(p), assocPath(p));
      });
      var lensProp = _curry1(function lensProp(k) {
        return lens(prop(k), assoc(k));
      });
      var liftN = _curry2(function liftN(arity, fn) {
        var lifted = curryN(arity, fn);
        return curryN(arity, function() {
          return _reduce(ap, map(lifted, arguments[0]), _slice(arguments, 1));
        });
      });
      var mean = _curry1(function mean(list) {
        return sum(list) / list.length;
      });
      var median = _curry1(function median(list) {
        var len = list.length;
        if (len === 0) {
          return NaN;
        }
        var width = 2 - len % 2;
        var idx = (len - width) / 2;
        return mean(_slice(list).sort(function(a, b) {
          return a < b ? -1 : a > b ? 1 : 0;
        }).slice(idx, idx + width));
      });
      var merge = mergeWith(function(l, r) {
        return r;
      });
      var mergeAll = _curry1(function mergeAll(list) {
        return reduce(merge, {}, list);
      });
      var pipe = function pipe() {
        if (arguments.length === 0) {
          throw new Error('pipe requires at least one argument');
        }
        return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
      };
      var pipeP = function pipeP() {
        if (arguments.length === 0) {
          throw new Error('pipeP requires at least one argument');
        }
        return _arity(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));
      };
      var product = reduce(multiply, 1);
      var sequence = _curry2(function sequence(of, traversable) {
        return typeof traversable.sequence === 'function' ? traversable.sequence(of) : reduceRight(function(acc, x) {
          return ap(map(prepend, x), acc);
        }, of([]), traversable);
      });
      var traverse = _curry3(function traverse(of, f, traversable) {
        return sequence(of, map(f, traversable));
      });
      var unnest = chain(_identity);
      var _contains = function _contains(a, list) {
        return _indexOf(list, a, 0) >= 0;
      };
      var _stepCat = function() {
        var _stepCatArray = {
          '@@transducer/init': Array,
          '@@transducer/step': function(xs, x) {
            return _concat(xs, [x]);
          },
          '@@transducer/result': _identity
        };
        var _stepCatString = {
          '@@transducer/init': String,
          '@@transducer/step': function(a, b) {
            return a + b;
          },
          '@@transducer/result': _identity
        };
        var _stepCatObject = {
          '@@transducer/init': Object,
          '@@transducer/step': function(result, input) {
            return merge(result, isArrayLike(input) ? objOf(input[0], input[1]) : input);
          },
          '@@transducer/result': _identity
        };
        return function _stepCat(obj) {
          if (_isTransformer(obj)) {
            return obj;
          }
          if (isArrayLike(obj)) {
            return _stepCatArray;
          }
          if (typeof obj === 'string') {
            return _stepCatString;
          }
          if (typeof obj === 'object') {
            return _stepCatObject;
          }
          throw new Error('Cannot create transformer for ' + obj);
        };
      }();
      var _toString = function _toString(x, seen) {
        var recur = function recur(y) {
          var xs = seen.concat([x]);
          return _contains(y, xs) ? '<Circular>' : _toString(y, xs);
        };
        var mapPairs = function(obj, keys) {
          return _map(function(k) {
            return _quote(k) + ': ' + recur(obj[k]);
          }, keys.slice().sort());
        };
        switch (Object.prototype.toString.call(x)) {
          case '[object Arguments]':
            return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';
          case '[object Array]':
            return '[' + _map(recur, x).concat(mapPairs(x, reject(function(k) {
              return /^\d+$/.test(k);
            }, keys(x)))).join(', ') + ']';
          case '[object Boolean]':
            return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
          case '[object Date]':
            return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';
          case '[object Null]':
            return 'null';
          case '[object Number]':
            return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
          case '[object String]':
            return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
          case '[object Undefined]':
            return 'undefined';
          default:
            if (typeof x.toString === 'function') {
              var repr = x.toString();
              if (repr !== '[object Object]') {
                return repr;
              }
            }
            return '{' + mapPairs(x, keys(x)).join(', ') + '}';
        }
      };
      var commute = commuteMap(identity);
      var compose = function compose() {
        if (arguments.length === 0) {
          throw new Error('compose requires at least one argument');
        }
        return pipe.apply(this, reverse(arguments));
      };
      var composeK = function composeK() {
        return compose.apply(this, prepend(identity, map(chain, arguments)));
      };
      var composeP = function composeP() {
        if (arguments.length === 0) {
          throw new Error('composeP requires at least one argument');
        }
        return pipeP.apply(this, reverse(arguments));
      };
      var construct = _curry1(function construct(Fn) {
        return constructN(Fn.length, Fn);
      });
      var contains = _curry2(_contains);
      var difference = _curry2(function difference(first, second) {
        var out = [];
        var idx = 0;
        var firstLen = first.length;
        while (idx < firstLen) {
          if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
            out[out.length] = first[idx];
          }
          idx += 1;
        }
        return out;
      });
      var dropRepeats = _curry1(_dispatchable('dropRepeats', _xdropRepeatsWith(equals), dropRepeatsWith(equals)));
      var into = _curry3(function into(acc, xf, list) {
        return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), acc, list);
      });
      var lift = _curry1(function lift(fn) {
        return liftN(fn.length, fn);
      });
      var omit = _curry2(function omit(names, obj) {
        var result = {};
        for (var prop in obj) {
          if (!_contains(prop, names)) {
            result[prop] = obj[prop];
          }
        }
        return result;
      });
      var pipeK = function pipeK() {
        return composeK.apply(this, reverse(arguments));
      };
      var toString = _curry1(function toString(val) {
        return _toString(val, []);
      });
      var uniqBy = _curry2(typeof Set === 'undefined' ? function uniqBy(fn, list) {
        var idx = 0;
        var applied = [];
        var result = [];
        var appliedItem,
            item;
        while (idx < list.length) {
          item = list[idx];
          appliedItem = fn(item);
          if (!_contains(appliedItem, applied)) {
            result.push(item);
            applied.push(appliedItem);
          }
          idx += 1;
        }
        return result;
      } : function uniqBySet(fn, list) {
        var set = new Set();
        var applied = [];
        var prevSetSize = 0;
        var result = [];
        var nullExists = false;
        var negZeroExists = false;
        var idx = 0;
        var appliedItem,
            item,
            newSetSize;
        while (idx < list.length) {
          item = list[idx];
          appliedItem = fn(item);
          switch (typeof appliedItem) {
            case 'number':
              if (appliedItem === 0 && !negZeroExists && 1 / appliedItem === -Infinity) {
                negZeroExists = true;
                result.push(item);
                break;
              }
            case 'string':
            case 'boolean':
            case 'function':
            case 'undefined':
              set.add(appliedItem);
              newSetSize = set.size;
              if (newSetSize > prevSetSize) {
                result.push(item);
                prevSetSize = newSetSize;
              }
              break;
            case 'object':
              if (appliedItem === null) {
                if (!nullExists) {
                  nullExists = true;
                  result.push(null);
                }
                break;
              }
            default:
              if (!_contains(appliedItem, applied)) {
                applied.push(appliedItem);
                result.push(item);
              }
          }
          idx += 1;
        }
        return result;
      });
      var without = _curry2(function(xs, list) {
        return reject(flip(_contains)(xs), list);
      });
      var complement = lift(not);
      var invoker = _curry2(function invoker(arity, method) {
        return curryN(arity + 1, function() {
          var target = arguments[arity];
          if (target != null && is(Function, target[method])) {
            return target[method].apply(target, _slice(arguments, 0, arity));
          }
          throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
        });
      });
      var join = invoker(1, 'join');
      var memoize = _curry1(function memoize(fn) {
        var cache = {};
        return _arity(fn.length, function() {
          var key = toString(arguments);
          if (!_has(key, cache)) {
            cache[key] = fn.apply(this, arguments);
          }
          return cache[key];
        });
      });
      var split = invoker(1, 'split');
      var test = _curry2(function test(pattern, str) {
        if (!_isRegExp(pattern)) {
          throw new TypeError('\u2018test\u2019 requires a value of type RegExp as its first argument; received ' + toString(pattern));
        }
        return _cloneRegExp(pattern).test(str);
      });
      var toLower = invoker(0, 'toLowerCase');
      var toUpper = invoker(0, 'toUpperCase');
      var uniq = uniqBy(identity);
      var concat = flip(invoker(1, 'concat'));
      var intersection = _curry2(function intersection(list1, list2) {
        return uniq(_filter(flip(_contains)(list1), list2));
      });
      var symmetricDifference = _curry2(function symmetricDifference(list1, list2) {
        return concat(difference(list1, list2), difference(list2, list1));
      });
      var symmetricDifferenceWith = _curry3(function symmetricDifferenceWith(pred, list1, list2) {
        return concat(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));
      });
      var union = _curry2(compose(uniq, _concat));
      var R = {
        F: F,
        T: T,
        __: __,
        add: add,
        addIndex: addIndex,
        adjust: adjust,
        all: all,
        allPass: allPass,
        allUniq: allUniq,
        always: always,
        and: and,
        any: any,
        anyPass: anyPass,
        ap: ap,
        aperture: aperture,
        append: append,
        apply: apply,
        assoc: assoc,
        assocPath: assocPath,
        binary: binary,
        bind: bind,
        both: both,
        call: call,
        chain: chain,
        clone: clone,
        commute: commute,
        commuteMap: commuteMap,
        comparator: comparator,
        complement: complement,
        compose: compose,
        composeK: composeK,
        composeP: composeP,
        concat: concat,
        cond: cond,
        construct: construct,
        constructN: constructN,
        contains: contains,
        converge: converge,
        countBy: countBy,
        curry: curry,
        curryN: curryN,
        dec: dec,
        defaultTo: defaultTo,
        difference: difference,
        differenceWith: differenceWith,
        dissoc: dissoc,
        dissocPath: dissocPath,
        divide: divide,
        drop: drop,
        dropLast: dropLast,
        dropLastWhile: dropLastWhile,
        dropRepeats: dropRepeats,
        dropRepeatsWith: dropRepeatsWith,
        dropWhile: dropWhile,
        either: either,
        empty: empty,
        eqBy: eqBy,
        eqProps: eqProps,
        equals: equals,
        evolve: evolve,
        filter: filter,
        find: find,
        findIndex: findIndex,
        findLast: findLast,
        findLastIndex: findLastIndex,
        flatten: flatten,
        flip: flip,
        forEach: forEach,
        fromPairs: fromPairs,
        groupBy: groupBy,
        gt: gt,
        gte: gte,
        has: has,
        hasIn: hasIn,
        head: head,
        identical: identical,
        identity: identity,
        ifElse: ifElse,
        inc: inc,
        indexBy: indexBy,
        indexOf: indexOf,
        init: init,
        insert: insert,
        insertAll: insertAll,
        intersection: intersection,
        intersectionWith: intersectionWith,
        intersperse: intersperse,
        into: into,
        invert: invert,
        invertObj: invertObj,
        invoker: invoker,
        is: is,
        isArrayLike: isArrayLike,
        isEmpty: isEmpty,
        isNil: isNil,
        join: join,
        juxt: juxt,
        keys: keys,
        keysIn: keysIn,
        last: last,
        lastIndexOf: lastIndexOf,
        length: length,
        lens: lens,
        lensIndex: lensIndex,
        lensPath: lensPath,
        lensProp: lensProp,
        lift: lift,
        liftN: liftN,
        lt: lt,
        lte: lte,
        map: map,
        mapAccum: mapAccum,
        mapAccumRight: mapAccumRight,
        mapObjIndexed: mapObjIndexed,
        match: match,
        mathMod: mathMod,
        max: max,
        maxBy: maxBy,
        mean: mean,
        median: median,
        memoize: memoize,
        merge: merge,
        mergeAll: mergeAll,
        mergeWith: mergeWith,
        mergeWithKey: mergeWithKey,
        min: min,
        minBy: minBy,
        modulo: modulo,
        multiply: multiply,
        nAry: nAry,
        negate: negate,
        none: none,
        not: not,
        nth: nth,
        nthArg: nthArg,
        objOf: objOf,
        of: of,
        omit: omit,
        once: once,
        or: or,
        over: over,
        pair: pair,
        partial: partial,
        partialRight: partialRight,
        partition: partition,
        path: path,
        pathEq: pathEq,
        pathOr: pathOr,
        pathSatisfies: pathSatisfies,
        pick: pick,
        pickAll: pickAll,
        pickBy: pickBy,
        pipe: pipe,
        pipeK: pipeK,
        pipeP: pipeP,
        pluck: pluck,
        prepend: prepend,
        product: product,
        project: project,
        prop: prop,
        propEq: propEq,
        propIs: propIs,
        propOr: propOr,
        propSatisfies: propSatisfies,
        props: props,
        range: range,
        reduce: reduce,
        reduceRight: reduceRight,
        reduced: reduced,
        reject: reject,
        remove: remove,
        repeat: repeat,
        replace: replace,
        reverse: reverse,
        scan: scan,
        sequence: sequence,
        set: set,
        slice: slice,
        sort: sort,
        sortBy: sortBy,
        split: split,
        splitAt: splitAt,
        splitEvery: splitEvery,
        splitWhen: splitWhen,
        subtract: subtract,
        sum: sum,
        symmetricDifference: symmetricDifference,
        symmetricDifferenceWith: symmetricDifferenceWith,
        tail: tail,
        take: take,
        takeLast: takeLast,
        takeLastWhile: takeLastWhile,
        takeWhile: takeWhile,
        tap: tap,
        test: test,
        times: times,
        toLower: toLower,
        toPairs: toPairs,
        toPairsIn: toPairsIn,
        toString: toString,
        toUpper: toUpper,
        transduce: transduce,
        transpose: transpose,
        traverse: traverse,
        trim: trim,
        type: type,
        unapply: unapply,
        unary: unary,
        uncurryN: uncurryN,
        unfold: unfold,
        union: union,
        unionWith: unionWith,
        uniq: uniq,
        uniqBy: uniqBy,
        uniqWith: uniqWith,
        unless: unless,
        unnest: unnest,
        update: update,
        useWith: useWith,
        values: values,
        valuesIn: valuesIn,
        view: view,
        when: when,
        where: where,
        whereEq: whereEq,
        without: without,
        wrap: wrap,
        xprod: xprod,
        zip: zip,
        zipObj: zipObj,
        zipWith: zipWith
      };
      if (typeof exports === 'object') {
        module.exports = R;
      } else if (typeof define === 'function' && define.amd) {
        define(function() {
          return R;
        });
      } else {
        this.R = R;
      }
    }.call(this));
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:ramda@0.19.1", ["npm:ramda@0.19.1/dist/ramda"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:ramda@0.19.1/dist/ramda');
  global.define = __define;
  return module.exports;
});

System.register('src/js/state.js', ['npm:redux@3.0.5', 'npm:ramda@0.19.1'], function (_export) {
    'use strict';

    var createStore, R, initialState, actionHandlers, store;

    function mainReducer(state, action) {
        if (state === undefined) state = initialState;

        var fn = actionHandlers[action.type];

        if (fn) {
            return R.merge(state, fn(R.clone(state), action));
        }

        return state;
    }

    return {
        setters: [function (_npmRedux305) {
            createStore = _npmRedux305.createStore;
        }, function (_npmRamda0191) {
            R = _npmRamda0191['default'];
        }],
        execute: function () {
            initialState = {
                background: {
                    speed: 0.2,
                    maxScale: 5,
                    minScale: 1
                }
            };
            actionHandlers = {};

            actionHandlers.setBgSpeed = function setBgSpeed(state, action) {
                state.background.speed = action.value;

                return state;
            };

            actionHandlers.setBgMaxScale = function setBgMaxScale(state, action) {
                state.background.maxScale = action.value;
                state.background.minScale = Math.min(state.background.minScale, state.background.maxScale);

                return state;
            };

            actionHandlers.setBgMinScale = function setBgMinScale(state, action) {
                state.background.minScale = action.value;
                state.background.maxScale = Math.max(state.background.maxScale, state.background.minScale);

                return state;
            };store = createStore(mainReducer);

            _export('store', store);
        }
    };
});
System.register('src/js/background.js', ['npm:babel-runtime@5.8.34/helpers/sliced-to-array', 'npm:three.js@0.73.0', 'src/js/state.js'], function (_export) {
    var _slicedToArray, THREE, store;

    function getElementDimensions(element) {
        return [element.offsetWidth, element.offsetHeight];
    }

    function createBackground(element) {
        var cubeSize = arguments.length <= 1 || arguments[1] === undefined ? 50 : arguments[1];

        var _getElementDimensions = getElementDimensions(element);

        var _getElementDimensions2 = _slicedToArray(_getElementDimensions, 2);

        var width = _getElementDimensions2[0];
        var height = _getElementDimensions2[1];

        var scopeFactor = 1000;
        var scene = new THREE.Scene();
        var renderer = new THREE.WebGLRenderer({ alpha: true });
        var camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, -2000, 2000);
        var cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);

        (function init() {
            var state = store.getState().background;

            // Add renderer to element
            renderer.setSize(width, height);
            element.appendChild(renderer.domElement);

            // Add resize listener
            window.addEventListener('resize', resize);

            // Put the camera in the right place
            camera.position.set(scopeFactor / 2, scopeFactor / 2, scopeFactor / 2);
            camera.lookAt(new THREE.Vector3(0, 0, 0));

            // Add cubes
            for (var xPos = -scopeFactor; xPos < scopeFactor; xPos += cubeSize) {
                for (var zPos = -scopeFactor; zPos < scopeFactor; zPos += cubeSize) {
                    var cube = new THREE.Mesh(cubeGeometry);
                    var edges = new THREE.EdgesHelper(cube, 0x000000);

                    // Widen the edge a bit and tweak its color
                    edges.material.linewidth = 2;
                    edges.material.color = cube.material.color.clone().add(new THREE.Color(-0.1, -0.1, -0.1));

                    // Set the position
                    cube.position.set(xPos, 0, zPos);

                    // Scale it randomly
                    cube.scale.setY(Math.max(state.minScale, Math.random(state.maxScale) * state.maxScale));

                    // Add scale direction for the animation
                    cube.scaleDirection = Math.random() > 0.5 ? 1 : -1;
                    cube.scaleSpeed = Math.random() * 0.9 + 0.1;

                    // Add it to the scene
                    scene.add(cube);
                    scene.add(edges);
                }
            }

            render();
        })();

        function resize() {
            var _getElementDimensions3 = getElementDimensions(element);

            var _getElementDimensions32 = _slicedToArray(_getElementDimensions3, 2);

            var width = _getElementDimensions32[0];
            var height = _getElementDimensions32[1];

            // Renderer
            renderer.setSize(width, height);

            // Camera
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        };

        function render(tFrame) {
            var state = store.getState().background;

            // Get next frame as early as possible
            window.requestAnimationFrame(render);

            // Re-scale the cubes
            scene.children.forEach(function scaleCube(cube) {
                // If they're at the extremity, reverse
                // Don't just *= -1 since they may be way outside the bounds
                if (cube.scale.y < state.minScale) {
                    cube.scaleDirection = 1;
                } else if (cube.scale.y > state.maxScale) {
                    cube.scaleDirection = -1;
                }

                var speed = store.getState().background.speed / 10 * cube.scaleSpeed;
                var delta = cube.scaleDirection * speed;

                cube.scale.setY(cube.scale.y + delta);
            });

            // Render all the objects
            renderer.render(scene, camera);
        };
    }

    return {
        setters: [function (_npmBabelRuntime5834HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5834HelpersSlicedToArray['default'];
        }, function (_npmThreeJs0730) {
            THREE = _npmThreeJs0730;
        }, function (_srcJsStateJs) {
            store = _srcJsStateJs.store;
        }],
        execute: function () {
            'use strict';

            _export('createBackground', createBackground);
        }
    };
});
System.register('src/js/main.js', ['npm:react@0.14.6', 'npm:react-dom@0.14.6', 'src/js/components/layout.js', 'src/js/background.js'], function (_export) {
  'use strict';

  var React, ReactDOM, App, createBackground;
  return {
    setters: [function (_npmReact0146) {
      React = _npmReact0146;
    }, function (_npmReactDom0146) {
      ReactDOM = _npmReactDom0146;
    }, function (_srcJsComponentsLayoutJs) {
      App = _srcJsComponentsLayoutJs.App;
    }, function (_srcJsBackgroundJs) {
      createBackground = _srcJsBackgroundJs.createBackground;
    }],
    execute: function () {

      (function main() {
        ReactDOM.render(React.createElement(App), document.getElementById('wrapper'));

        createBackground(document.getElementById('main-background'), 90);
      })();
    }
  };
});
//# sourceMappingURL=build.js.map